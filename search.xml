<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>利用TensorFlow实现的选课网验证码自动识别AI</title>
    <url>/2021/04/16/PKUAutoEletiveCaptchaHelper/</url>
    <content><![CDATA[<h1 id="利用TensorFlow实现的选课网验证码自动识别AI"><a href="#利用TensorFlow实现的选课网验证码自动识别AI" class="headerlink" title="利用TensorFlow实现的选课网验证码自动识别AI"></a>利用TensorFlow实现的选课网验证码自动识别AI</h1><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2021/04/16/PKUAutoEletiveCaptchaHelper/QRcode.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">扫描二维码阅读原文</div>
    <br>
</center>

<p>前几个星期受朋友的委托，开发了一款针对某大学选课网的验证码识别工具。朋友做的是补退选阶段自动选课部分，而我负责了其中的验证码识别模块。先说一说达到的效果吧，这款工具针对选课网验证码测试集识别率可以达到99.62%，单次识别耗时约0.03秒，实际运行准确率得等到下次选课才知道了，预计不会低于98%。部署在本地可以达到本校学生开发的自动选课工具的平均速度，识别准确度和速度均超越了调用商用验证码识别API。</p>
<a id="more"></a>
<h2 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h2><p>没过几天，我就收到了这样一大包带有标签的验证码图片：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2021/04/16/PKUAutoEletiveCaptchaHelper/g8gs_1615517901796011.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">g8gs_1615517901796011.png</div>
    <br>
</center>

<p>样本总数是19490个，全部爬取自北京大学选课网，并且在打码平台打好了标签。经过简单的观察和分析，我们可以归纳出验证码的以下几个特征：</p>
<ol>
<li>图片分别率为130*52，png格式。</li>
<li>图片只有一个通道，也就是说这张看起来是彩色的图像实际上是灰度图。</li>
<li>图片名前四个字字符即为对应的标签。</li>
<li>图片存在随机添加的噪点和线条，遮挡关系中均位于底层，因此对识别的影响程度不大。</li>
<li>字符有两种表现形式，一种是实心字符，另一种是空心的边框，对识别影响程度未知。</li>
<li>字符与字符间、字符与图片边界间可能存在遮挡关系，对识别影响程度较大。</li>
<li>验证码字符集是字母和数字的子集，具体来说不包含“0，1，i，j，o，z”这6个字符。</li>
<li>验证码不区分大小写，但图片中字符包含大小写。</li>
<li>同一验证码可能出现重复字符。</li>
<li>标签并非完全准确，后期统计估算的结果是，标签整体准确率约为90%。</li>
</ol>
<p>综合以上几点，我们需要做的是输入一张图片，输出一个字符串，这个字符串即为对该图片的识别结果。很显然这是一个多分类问题，分类总数是$30^4=8.1\times 10^5$。对于这个数量级的多分类问题，我对人工智能能否胜任还打了个问号。毕竟随机一个结果，正确的概率约等于中头奖。面向CSDN编程当然能查出不少别人的成功样例，但是别人的代码和我们目前的需求依然存在不小的差异。我也只能以一点点可怜的tensorflow基础开始写代码。</p>
<h2 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h2><p>tensorflow只能接受张量输入，因此我们首先要做的是把读取的图像转换成tensor类型。与此同时，我们还要从图片名中截出标签字段，转换成tensor一起送入神经网络训练。先把字母表写好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alphabet = [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>读入的标签也不能直接喂给模型，需要先转换成独热码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2vec</span>(<span class="params">text</span>):</span></span><br><span class="line">    vector = np.zeros([<span class="number">4</span>, <span class="number">30</span>])</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        idx = alphabet.index(c)</span><br><span class="line">        vector[i][idx] = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> vector</span><br></pre></td></tr></table></figure>
<p>在开始我们的工作前，我们还要把一大包图片分成训练集和测试集（当然keras也支持自动分割），我按照80%：20%的比例划分训练集和测试集。训练集中的损失函数值在反向传播时会更新所有的可训练参数，而测试集仅仅计算损失函数值，相当于预测。训练集和测试集不能有交集，否则达不到训练目的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">path=<span class="string">r&#x27;./img/&#x27;</span></span><br><span class="line">imglist=os.listdir(path)</span><br><span class="line">random.shuffle(imglist)</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;./img.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imglist:</span><br><span class="line">    f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;./img_test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imglist[:<span class="built_in">len</span>(imglist)//<span class="number">5</span>]:</span><br><span class="line">    f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;./img_train.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imglist[<span class="built_in">len</span>(imglist)//<span class="number">5</span>:]:</span><br><span class="line">    f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>有了这些字母表和函数，我们就可以愉快地往下写读文件的函数了。为了比较模型的稳定性，每次训练我都会随机划分训练集和测试集。我们把图片转换成numpy数组格式并进行归一化，tensorflow可直接读取numpy数组并转换成张量。归一化非常重要，否则你会看到模型loss函数和所有可训练参数直接飞升，通通显示NaN。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateds</span>(<span class="params">path, txt</span>):</span></span><br><span class="line">    f = <span class="built_in">open</span>(txt, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">    contents = f.readlines() </span><br><span class="line">    random.shuffle(contents)</span><br><span class="line">    f.close() </span><br><span class="line">    x, y_ = [], [] </span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">        value = text2vec(content[:<span class="number">4</span>])</span><br><span class="line">        img_path = path + content </span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path[:-<span class="number">1</span>])</span><br><span class="line">        img = np.array(img) </span><br><span class="line">        img = img / <span class="number">255.</span></span><br><span class="line">        x.append(img) </span><br><span class="line">        y_.append(value)</span><br><span class="line">    x = np.array(x)</span><br><span class="line">    y_ = np.array(y_)</span><br><span class="line">    x = x.astype(np.float32)</span><br><span class="line">    y_ = y_.astype(np.float32) </span><br><span class="line">    x = np.expand_dims(x, axis=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> x, y_ </span><br></pre></td></tr></table></figure>
<p>当然，实际的代码过程并没有我在这里展示的如此简单，一个极易被忽略的细节是通道。正常的RGB图有三个维度：宽度、高度和通道数。然而这奇葩的验证码竟然没有通道维！傻乎乎的我直接把tensor喂到模型中，报错显示维度不匹配。这小样竟然只有三个维度(None, 52, 130)，而二维卷积需要四个维度！琢磨了半天，我想直接给你加上通道维行不行，于是给图片张量添加了3号维度。竟然行了！这小家伙可是折磨了我整整一个晚上啊。</p>
<p>另外值得注意的是，二维卷积需求的张量维度分别是batch数、高度、宽度和通道数。碰巧numpy数组也是高度维在前，宽度维在后，如果反过来的话也很容易中招。</p>
<h2 id="利用keras搭建卷积神经网络"><a href="#利用keras搭建卷积神经网络" class="headerlink" title="利用keras搭建卷积神经网络"></a>利用keras搭建卷积神经网络</h2><p>keras已经把tensorflow的方法封装得相当到位了，搭建网络的过程并没有给我造成太大的困难。我先比较了一下常见的CNN代码实现难度，VGGNet算是最好写的，不用写类就能搞得定，而且代码结构也很规整。如果识别水平实在不行，那就再试试别的，比如InceptionNet或是ResNet。</p>
<p>我对VGGNet做了一些调整，在这里卷积神经网络基本结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Layer (type)                    Output Shape         Param #     Connected to                     </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">input_1 (InputLayer)            [(None, 52, 130, 1)] 0                                            </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d (Conv2D)                 (None, 52, 130, 32)  320         input_1[0][0]                    </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">...</span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dense_5 (Dense)                 (None, 30)           122910      dropout_6[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">tf.convert_to_tensor (TFOpLambd (4, None, 30)        0           dense_2[0][0]                    </span><br><span class="line">                                                                 dense_3[0][0]                    </span><br><span class="line">                                                                 dense_4[0][0]                    </span><br><span class="line">                                                                 dense_5[0][0]                       </span><br></pre></td></tr></table></figure>
<p>第一部分是10层卷积。使用3*3的卷积核，卷积核个数从32开始，每两层变成原来的两倍，与此同时深度也会变为原来的两倍。卷积步长为1，使用全零填充。接着进行批标准化操作，使用relu激活函数。每两层我们做一次2*2的最大池化，池化步长为2，使用全零填充。每两层我们舍弃一次，每层舍弃20%的节点以防止模型过拟合。</p>
<p>第二部分是两层4096个节点的全连接，全连接前先把张量拉直成一维，采用relu激活函数。最后一步是连接到输出层，这里我们使用了4个全连接层代表了输出的四个字符，在这里我们使用softmax激活函数使输出符合概率分布。为了匹配最终的输出结果，我们还要调换一下输出张量的维度顺序。</p>
<p>最后的模型代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> *</span><br><span class="line">input_tensor = Input((<span class="number">52</span>, <span class="number">130</span>, <span class="number">1</span>))</span><br><span class="line">x = input_tensor</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    x = Convolution2D(filters=<span class="number">32</span> * <span class="number">2</span> ** (i // <span class="number">2</span>), kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    x = BatchNormalization()(x)</span><br><span class="line">    x = Activation(activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        x = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">        x = Dropout(<span class="number">0.2</span>)(x)</span><br><span class="line">x = Flatten()(x)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    x = Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">x = tf.convert_to_tensor([Dense(<span class="number">30</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)(x) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)])</span><br><span class="line">x = tf.transpose(x, perm=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h2 id="训练卷积神经网络"><a href="#训练卷积神经网络" class="headerlink" title="训练卷积神经网络"></a>训练卷积神经网络</h2><p>炼丹炉已经造好，原料也已准备完毕，现在终于可以开始“炼丹”了。加载模型，设置好优化器，设置好损失函数和准确度，设置好存档和断点续训，设置好batch大小和epoch，设置好回调函数，喂入数据和标签，现在开始听天由命了，我也不知道这台机器能学成什么鬼样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> *</span><br><span class="line">train_path = <span class="string">&#x27;./img/&#x27;</span></span><br><span class="line">train_txt = <span class="string">&#x27;./venv/img_train.txt&#x27;</span></span><br><span class="line">test_path = <span class="string">&#x27;./img/&#x27;</span></span><br><span class="line">test_txt = <span class="string">&#x27;./img_test.txt&#x27;</span></span><br><span class="line">x_train, y_train = generateds(train_path, train_txt)</span><br><span class="line">x_test, y_test = generateds(test_path, test_txt)</span><br><span class="line">model = Model(input_tensor, x)</span><br><span class="line">optimizer = Adadelta(learning_rate=<span class="number">0.8</span>)</span><br><span class="line">reduce_lr = LearningRateScheduler(scheduler)</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,optimizer=optimizer,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">checkpoint_save_path = <span class="string">&quot;./captcha.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line">cp_callback = ModelCheckpoint(filepath=checkpoint_save_path,save_weights_only=<span class="literal">True</span>, save_best_only=<span class="literal">True</span>)</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">64</span>, epochs=<span class="number">20</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,callbacks=[cp_callback, reduce_lr])</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p>训了几个小时，我就发现有点不对劲了。loss函数和准确度几乎没有收敛的意思，仍在瞎蒙附近徘徊。这事就有点诡异了，按理说是会收敛的，难道是我的学习率还不够大？我的学习率是默认的0.01，这么复杂的模型，光是训练一轮就要40s，如果调大学习率恐怕会出现不收敛的情况。保险起见，我让它以低学习率通宵训练，看看800个epoch后是个什么样。</p>
<p>第二天早上起来，炼丹的结果让我喜出望外。一个晚上的风扇轰鸣没有白费，虽然开始的100个epoch的确是瞎蒙，但后来神经网络似乎找到了门道，准确度开始线性增长。单字符准确度从0.03增加到0.7，现在神经网络已经从人工智障逐步训练成人工智能了，但离应用还天远地远。4个字符组成的验证码准确度是单字符的4次方，也就是$0.7^4=0.2401$，从应用角度来看和完全不能用也没什么区别。也就是说，学到了，但没有完全学到。</p>
<p>接下来要做的事就简单了，我们仅需可劲地提高学习率。当然，高学习率也就导致了模型在短短10个epoch后准确率就达到90%，此后模型迅速出现过拟合现象。为此，我们需要设置指数衰减学习率，也就有了以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.backend <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scheduler</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> epoch != <span class="number">0</span>:</span><br><span class="line">        lr = get_value(model.optimizer.lr)</span><br><span class="line">        set_value(model.optimizer.lr, lr * <span class="number">0.5</span>)</span><br><span class="line">        print(<span class="string">&quot;lr changed to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(lr * <span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">return</span> get_value(model.optimizer.lr)</span><br></pre></td></tr></table></figure>
<p>为了直观地显示训练进度，可以使用matplotlib绘制acc曲线。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">acc = history.history[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_accuracy&#x27;</span>]</span><br><span class="line">acc = [i ** <span class="number">4</span> <span class="keyword">for</span> i <span class="keyword">in</span> acc]</span><br><span class="line">val_acc = [i ** <span class="number">4</span> <span class="keyword">for</span> i <span class="keyword">in</span> val_acc]</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(acc, label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc, label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="优化识别准确率"><a href="#优化识别准确率" class="headerlink" title="优化识别准确率"></a>优化识别准确率</h2><p>在接下来的几个小时里，通过不断调整模型参数，单字符准确度从0.7迅速增加到0.95，训练一次模型的时间也从30分钟缩短到15分钟。然而，$0.95^4\approx0.815$，这依然达不到可应用的水平。现在我可以一个个的看看模型和标签不一样的地方在哪里了。我们先写个译码函数把输出张量转换成字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">y</span>):</span></span><br><span class="line">    y = np.argmax(y, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([alphabet[x] <span class="keyword">for</span> x <span class="keyword">in</span> y])</span><br></pre></td></tr></table></figure>
<p>把所有图片一起喂进去，和标签不一样的全部打印出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_ans, y_ans = generateds(train_path, <span class="string">&#x27;./venv/img.txt&#x27;</span>)</span><br><span class="line">y_pred = model.predict(x_ans)</span><br><span class="line">ans = []</span><br><span class="line">pred = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y_ans:</span><br><span class="line">    ans.append(decode(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y_pred:</span><br><span class="line">    pred.append(decode(i))</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ans)):</span><br><span class="line">    <span class="keyword">if</span> ans[i] != pred[i]:</span><br><span class="line">        <span class="keyword">if</span> j % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(j)</span><br><span class="line">        print(ans[i], <span class="string">&#x27;  &#x27;</span>, pred[i])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">print(j)</span><br></pre></td></tr></table></figure>
<p>好家伙，打印出1500多个！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sgan    sgam</span><br><span class="line">mam7    mamv</span><br><span class="line">tfsm    tfsn</span><br><span class="line">5mdh    4mdh</span><br><span class="line">d8fr    dbfr</span><br><span class="line">dcsb    d2sb</span><br><span class="line">htvn    htvm</span><br><span class="line">qm46    qh46</span><br><span class="line">cwpa    gwpa</span><br><span class="line">glmf    glmt</span><br><span class="line">wm4e    wmhe</span><br><span class="line">hapl    hbpl</span><br><span class="line">srgk    spgk</span><br><span class="line">mxms    mxm5</span><br><span class="line">bums    bum5</span><br><span class="line">twut    twu7</span><br><span class="line">apvn    apvh</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>点进去一个，一看是标签错了。又点进去一个，又是标签错了……一个个看下来有八成都是标签的错。看来我的神经网络也没有那么不堪嘛。修改标签的这部分工作实在是令人难以忍受，我足足花了几乎两个整天才把1500多个验证码一一人工看过一遍。当然，蛮干是不可能的，最好的办法是一边修改标签一边重新训练模型提高准确度。后来的训练结果如下，仅仅训练20轮准确率就达到99%以上，此时甚至还在欠拟合区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Epoch 1&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 38s 140ms&#x2F;step - loss: 4.0398 - accuracy: 0.0437 - val_loss: 3.3373 - val_accuracy: 0.0412</span><br><span class="line">...</span><br><span class="line">Epoch 20&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 35s 145ms&#x2F;step - loss: 0.0197 - accuracy: 0.9933 - val_loss: 0.0234 - val_accuracy: 0.9951</span><br></pre></td></tr></table></figure>
<p>可视化结果如下：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2021/04/16/PKUAutoEletiveCaptchaHelper/final.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;"></div>
    <br>
</center>

<p>最后一次训练和标签不一致的样本数是75个，准确率达到99.62%。我们随便找个不一样的看看：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2021/04/16/PKUAutoEletiveCaptchaHelper/glmf_1615512501114772.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    "></div>
    <br>
</center>

<p>AI认为它是“glmf”，还是挺阴间的对吧？</p>
<h2 id="封装识别模块"><a href="#封装识别模块" class="headerlink" title="封装识别模块"></a>封装识别模块</h2><p>至此，我们的炼丹算是全部完成了，最后生成的模型文件有491MB。我们把模型的预测部分单独拎出来，封装成一个识别函数，输入图片路径返回字符串。把加载神经网络的部分封装成另一个函数，在主程序开始时调用以加载神经网络。实测加载神经网络大约需要1秒，每调用一次识别函数大约需要0.03秒。在识别函数处我预留了同时识别多张图片的接口，但目前还看不到有此需求。实际上由于并行计算的特性，一次识别不太多的多张图片所花的时间几乎相同。验证码识别部分的完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主程序开始时调用此函数加载神经网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    <span class="comment"># 输入层</span></span><br><span class="line">    x = Input((<span class="number">52</span>, <span class="number">130</span>, <span class="number">1</span>))</span><br><span class="line">    x = input_tensor</span><br><span class="line">    <span class="comment"># 10层卷积，每层批标准化，采用relu激活，每两层进行一次最大池化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        x = Convolution2D(filters=<span class="number">32</span> * <span class="number">2</span> ** (i // <span class="number">2</span>), kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">        x = BatchNormalization()(x)</span><br><span class="line">        x = Activation(activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            x = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    <span class="comment"># 拉直成一维送入全连接</span></span><br><span class="line">    x = Flatten()(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        x = Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment"># 输出层</span></span><br><span class="line">    x = tf.convert_to_tensor([Dense(<span class="number">30</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)(x) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)])</span><br><span class="line">    x = tf.transpose(x, perm=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="comment"># 加载神经网络</span></span><br><span class="line">    model = Model(input_tensor, x)</span><br><span class="line">    checkpoint = <span class="string">&quot;./captcha.ckpt&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(checkpoint + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">        model.load_weights(checkpoint)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别验证码，参数为图片路径和模型，返回值为识别结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">path, model</span>):</span></span><br><span class="line">    alphabet = [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">    <span class="comment"># 读取图片，预处理</span></span><br><span class="line">    x_arr = []</span><br><span class="line">    img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">    img = np.array(img)</span><br><span class="line">    img = img / <span class="number">255.</span></span><br><span class="line">    x_arr.append(img)</span><br><span class="line">    <span class="comment"># 转化为np_array并添加通道维</span></span><br><span class="line">    x_arr = np.array(x_arr)</span><br><span class="line">    x_arr = x_arr.astype(np.float32)</span><br><span class="line">    x_arr = np.expand_dims(x_arr, axis=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 识别结果并输出</span></span><br><span class="line">    y_arr = model.predict(x_arr)</span><br><span class="line">    pred = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> y_arr:</span><br><span class="line">        n = np.argmax(i, axis=<span class="number">1</span>)</span><br><span class="line">        pred.append(<span class="string">&#x27;&#x27;</span>.join([alphabet[j] <span class="keyword">for</span> j <span class="keyword">in</span> n]))</span><br><span class="line">    <span class="keyword">return</span> pred[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>newDSA</title>
    <url>/2021/04/20/newDSA/</url>
    <content><![CDATA[<h2 id="一-概论"><a href="#一-概论" class="headerlink" title="一    概论"></a>一    概论</h2><h3 id="1-1-数据结构和抽象数据类型"><a href="#1-1-数据结构和抽象数据类型" class="headerlink" title="1.1    数据结构和抽象数据类型"></a>1.1    数据结构和抽象数据类型</h3><p>数据结构包括逻辑、存储和运算三个部分。逻辑结构包括线性结构和非线性结构，线性结构包括线性表，非线性结构包括树和图。数据的存储结构是逻辑结构到物理存储单元的映射，包括顺序、链接、索引和散列。抽象数据类型（ADT）定义了一组运算的数学模型，与物理存储结构无关，它隐藏了运算实现的细节和内部数据结构，利于软件复用。</p>
<h3 id="1-2-算法特性和分类"><a href="#1-2-算法特性和分类" class="headerlink" title="1.2    算法特性和分类"></a>1.2    算法特性和分类</h3><p>算法具有通用性、有效性、确定性、有穷性的特点。基本算法分类包括穷举、回溯、搜索、递归、分治、贪心、动态规划等。</p>
<h3 id="1-3-算法复杂性分析"><a href="#1-3-算法复杂性分析" class="headerlink" title="1.3    算法复杂性分析"></a>1.3    算法复杂性分析</h3><p>令$p(n)$和$q(n)$是两个非负函数，称$p(n)$渐进地大于$q(n)$当且仅当</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}\frac{q(n)}{p(n)}=0</script><p>称$q(n)$渐进地小于$p(n)$当且仅当$p(n)$渐进地大于$q(n)$，称$p(n)$渐进地等于$q(n)$当且仅当$q(n)$不渐进地大于$p(n)$且$p(n)$不渐进地大于$q(n)$。</p>
<p>记法$f(n)=O(g(n))$中表示$f(n)$渐进地小于或等于$g(n)$。</p>
<p>记法$f(n)=\Omega(g(n))$中表示$f(n)$渐进地大于或等于$g(n)$。</p>
<p>记法$f(n)=\Theta(g(n))$中表示$f(n)$渐进地等于$g(n)$。</p>
<p>记法$f(n)=o(g(n))$中表示$f(n)$渐进地小于$g(n)$。</p>
<p>$g(n)$通常为系数为1的单项。</p>
<h2 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二    线性表"></a>二    线性表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>  &#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; 				 	<span class="comment">// 置空线性表</span></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;				 	<span class="comment">// 线性表为空时，返回True</span></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;		 		<span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;	 		<span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>; 			 	<span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">      <span class="function">T <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> p)</span></span>;			 	<span class="comment">// 返回位置p的元素值 </span></span><br><span class="line">      <span class="function">T <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;	 		<span class="comment">// 用value修改位置p的元素值</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myList.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  			<span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrList</span> :</span> <span class="keyword">public</span> List&lt;T&gt;  &#123;		<span class="comment">// 顺序表，向量</span></span><br><span class="line"><span class="keyword">private</span>:    					<span class="comment">// 线性表的取值类型和取值空间</span></span><br><span class="line">	<span class="keyword">int</span>  maxSize;            	<span class="comment">// 私有变量，顺序表实例的最大长度</span></span><br><span class="line">    <span class="keyword">int</span>  curLen; 		    		<span class="comment">// 私有变量，顺序表实例的当前长度</span></span><br><span class="line">    <span class="keyword">int</span>  position;				<span class="comment">// 私有变量，当前处理位置</span></span><br><span class="line">   	T  *aList ;            		<span class="comment">// 私有变量，存储顺序表的实例</span></span><br><span class="line"><span class="keyword">public</span>: 						<span class="comment">// 顺序表的运算集</span></span><br><span class="line">	arrList(<span class="keyword">const</span> <span class="keyword">int</span> size) &#123;  		<span class="comment">// 创建一个新的顺序表，参数为表实例的最大长度</span></span><br><span class="line">		maxSize = size;</span><br><span class="line">		aList = <span class="keyword">new</span> T[maxSize];</span><br><span class="line">		curLen = position = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~arrList() &#123;					<span class="comment">// 析构函数，用于消除该表实例</span></span><br><span class="line">		<span class="keyword">delete</span> [] aList;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;      			<span class="comment">// 将顺序表存储的内容清除，成为空表</span></span><br><span class="line">		<span class="keyword">delete</span> [] aList;</span><br><span class="line">		curLen = position = <span class="number">0</span>;</span><br><span class="line">		aList = <span class="keyword">new</span> T[maxSize];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;            		<span class="comment">// 返回此顺序表的当前实际长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;			<span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;	 	<span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>; 			<span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getPos</span><span class="params">(<span class="keyword">const</span> T value)</span></span>;		<span class="comment">// 在线性表中查找值为value的元素，并返回第1次出现的位置</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;                     <span class="comment">// 打印线性表 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  					<span class="comment">// 假定顺序表的元素类型为T </span></span><br><span class="line"><span class="keyword">int</span> arrList&lt;T&gt; :: getPos (<span class="keyword">const</span> T value) &#123;</span><br><span class="line">		<span class="keyword">int</span> i;     						<span class="comment">// 元素下标</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; curLen; i++)  &#123;				<span class="comment">// 依次比较</span></span><br><span class="line">	        <span class="keyword">if</span> (value == aList[i])			<span class="comment">// 下标为i的元素与value相等</span></span><br><span class="line">               <span class="keyword">return</span> i;				<span class="comment">// 返回下标i</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;						<span class="comment">// 顺序表没有元素值为value的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设元素的类型为T， aList是存储顺序表的数组， maxSize是其最大长度；</span></span><br><span class="line"><span class="comment">// p为新元素value的插入位置,</span></span><br><span class="line"><span class="comment">// 插入成功则返回true, 否则返回false</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  			      		<span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> arrList&lt;T&gt; :: insert(<span class="keyword">int</span> p, <span class="keyword">const</span> T value)  &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">if</span> (curLen &gt;= maxSize)  &#123; 		  		<span class="comment">// 检查顺序表是否溢出</span></span><br><span class="line">  	       <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The list is overflow&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; curLen)  &#123;		  		<span class="comment">// 检查插入位置是否合法</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insertion is illegal&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = curLen; i &gt; p; i--)</span><br><span class="line">	         aList[i] = aList[i<span class="number">-1</span>];   	 	 	<span class="comment">// 从表尾curLen -1起往右移动直到p</span></span><br><span class="line">		aList[p] = value;          		 	<span class="comment">// 位置p处插入新元素</span></span><br><span class="line">        curLen++;               		 	<span class="comment">// 表的实际长度增1 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  			    <span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> arrList&lt;T&gt; :: del(<span class="keyword">int</span> p)  &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (curLen &lt;= <span class="number">0</span> )  &#123; 				<span class="comment">// 检查顺序表是否为空</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; No element to delete \n&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; curLen<span class="number">-1</span>)  &#123;			<span class="comment">// 检查删除位置是否合法</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deletion is illegal\n&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = p; i &lt; curLen<span class="number">-1</span>; i++)</span><br><span class="line">        aList[i] = aList[i+<span class="number">1</span>];   	 		<span class="comment">// 从位置p开始每个元素左移直到curLen,</span></span><br><span class="line">    curLen--;               			<span class="comment">// 表的实际长度减1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  			    <span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">void</span> arrList&lt;T&gt; :: print()  &#123;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curLen; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; aList[i]; </span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  	 		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myList.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   	T  		data;							<span class="comment">// 用于保存结点元素的内容</span></span><br><span class="line">	Link 	* next;						<span class="comment">// 指向后继结点的指针</span></span><br><span class="line">	Link(<span class="keyword">const</span> T info, Link* nextValue = <span class="literal">NULL</span>)  &#123;	<span class="comment">// 具有两个参数的Link构造函数</span></span><br><span class="line">		data = info;</span><br><span class="line">		next = nextValue;</span><br><span class="line">	&#125;</span><br><span class="line">	Link(Link* nextValue = <span class="literal">NULL</span>)  &#123; 			<span class="comment">// 具有一个参数的Link构造函数</span></span><br><span class="line">		next = nextValue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【代码2.7】 单链表的类型定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkList</span>:</span> <span class="keyword">public</span> List&lt;T&gt;  &#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	Link&lt;T&gt;*  head;                    <span class="comment">// 单链表的头指针</span></span><br><span class="line">    Link&lt;T&gt;*  tail;    				<span class="comment">// 单链表的尾指针</span></span><br><span class="line">	<span class="function">Link&lt;T&gt;* <span class="title">setPos</span><span class="params">(<span class="keyword">int</span> p)</span></span>;				<span class="comment">// 返回线性表指向第p个元素的指针值     </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	lnkList(<span class="keyword">int</span>);						<span class="comment">// 构造函数</span></span><br><span class="line">	~lnkList();						<span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; 					<span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; 					 <span class="comment">// 将链表存储的内容清除，成为空表</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;                   	          <span class="comment">// 返回此顺序表的当前实际长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;				   <span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;			<span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>; 				     <span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;	       <span class="comment">// 返回位置p的元素值 </span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">getPos</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> T value)</span></span>;	<span class="comment">// 查找值为value的元素，并返回第1次出现的位置</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line">lnkList&lt;T&gt;::lnkList(<span class="keyword">int</span> defSize)&#123;</span><br><span class="line">		head = tail = <span class="keyword">new</span> Link&lt;T&gt;(<span class="number">9999</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">lnkList&lt;T&gt;::~lnkList()&#123;</span><br><span class="line">		Link&lt;T&gt; *tmp;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123; </span><br><span class="line"> 		      tmp = head;</span><br><span class="line">			  head = head-&gt;next;</span><br><span class="line">			  <span class="keyword">delete</span> tmp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  			<span class="comment">// 假定线性表的元素类型为T</span></span><br><span class="line">Link&lt;T&gt;* lnkList&lt;T&gt; :: setPos(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        Link&lt;T&gt; *p;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) 			       <span class="comment">// i为-1则定位到&quot;虚&quot;头结点</span></span><br><span class="line">		   <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        p = <span class="keyword">new</span> Link&lt;T&gt;(head-&gt;next);      <span class="comment">// 若i为0则定位到第一个结点     </span></span><br><span class="line">        </span><br><span class="line">	    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; count &lt; i) &#123;</span><br><span class="line"> 	           p = p-&gt; next;</span><br><span class="line">  	           count++;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> p;         		<span class="comment">// 指向第 i 结点，i＝0,1,…，当链表中结点数小于i时返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  			 		<span class="comment">// 线性表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> lnkList&lt;T&gt; :: insert(<span class="keyword">int</span> i, T value)  &#123;</span><br><span class="line">     Link&lt;T&gt; *p, *q;</span><br><span class="line">					</span><br><span class="line">     <span class="keyword">if</span> ((p = setPos(i<span class="number">-1</span>)) == <span class="literal">NULL</span>)&#123; 		<span class="comment">// p是第i个结点的前驱</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; the insertion point is illegal&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = <span class="keyword">new</span> Link&lt;T&gt;(value, p-&gt;next);</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    <span class="keyword">if</span> (p == tail)						<span class="comment">// 插入点在链尾，插入结点成为新的链尾</span></span><br><span class="line">		tail = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete a node from singly linked list</span></span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  					<span class="comment">// 线性表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> lnkList&lt;T&gt;:: del(<span class="keyword">int</span> i)  &#123;</span><br><span class="line">     Link&lt;T&gt; *p, *q; </span><br><span class="line">	 <span class="keyword">if</span>  ((p = setPos(i<span class="number">-1</span>)) == <span class="literal">NULL</span> )	&#123; 		<span class="comment">// 待删结点不存在，即给定的i大于当前链中元素个数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; the deletion point is illegal&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    q = p-&gt;next;							<span class="comment">// q是真正待删结点</span></span><br><span class="line">    <span class="keyword">if</span> (q == tail) &#123;						<span class="comment">// 待删结点为尾结点，则修改尾指针</span></span><br><span class="line">		  tail = p;</span><br><span class="line">		  <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>)  &#123;						<span class="comment">// 删除结点q 并修改链指针</span></span><br><span class="line">    	p-&gt;next = q-&gt;next;</span><br><span class="line">	    <span class="keyword">delete</span> q;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  			    <span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">void</span> lnkList&lt;T&gt; :: print() &#123;</span><br><span class="line">       	Link&lt;T&gt; *tmp = head;</span><br><span class="line">       	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;begin\n&quot;</span> ;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="literal">NULL</span>) &#123; </span><br><span class="line"> 	    	<span class="built_in">cout</span> &lt;&lt; tmp-&gt;data &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">      	    tmp = tmp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;end\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三-栈与队列"><a href="#三-栈与队列" class="headerlink" title="三    栈与队列"></a>三    栈与队列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> 					<span class="comment">// 栈的元素类型为 T</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: 	            			<span class="comment">// 栈的运算集</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;	   			<span class="comment">// 变为空栈</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span></span>; 		<span class="comment">// item入栈，成功则返回真，否则返回假</span></span><br><span class="line"> 	<span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;				<span class="comment">// 返回栈顶内容并弹出，成功返回真，否则返回假,</span></span><br><span class="line"> 	<span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T&amp; item)</span></span>;	  			<span class="comment">// 返回栈顶内容但不弹出成功返回真，否则返回假,</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; 	   			<span class="comment">// 若栈已空返回真</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;        			<span class="comment">// 若栈已满返回真</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;                            <span class="comment">// 用于保存结点元素的内容</span></span><br><span class="line">    Link *next;                        <span class="comment">// 指向后继结点的指针</span></span><br><span class="line"></span><br><span class="line">    Link(<span class="keyword">const</span> T info, Link *nextValue) &#123;    <span class="comment">// 具有两个参数的Link构造函数</span></span><br><span class="line">        data = info;</span><br><span class="line">        next = nextValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Link(Link *nextValue = <span class="literal">NULL</span>) &#123;    <span class="comment">// 具有两个参数的Link构造函数</span></span><br><span class="line">        next = nextValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkStack</span> :</span> <span class="keyword">public</span> Stack&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:                                <span class="comment">// 栈的链式存储</span></span><br><span class="line">    Link&lt;T&gt; *top;                    <span class="comment">// 指向栈顶的指针</span></span><br><span class="line">    <span class="keyword">int</span> size;                    <span class="comment">// 存放元素的个数</span></span><br><span class="line"><span class="keyword">public</span>:                                <span class="comment">// 栈运算的链式实现</span></span><br><span class="line">    lnkStack(<span class="keyword">int</span> defSize) &#123;                <span class="comment">// 构造函数</span></span><br><span class="line">        top = <span class="literal">NULL</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~lnkStack() &#123;                    <span class="comment">// 析构函数</span></span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 清空栈内容</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Link&lt;T&gt; *tmp = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;                <span class="comment">// 入栈操作的链式实现	</span></span><br><span class="line">        Link&lt;T&gt; *tmp = <span class="keyword">new</span> Link&lt;T&gt;(item, top);</span><br><span class="line">        top = tmp;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T *item)</span> </span>&#123;                <span class="comment">// 出栈的链式实现</span></span><br><span class="line">        Link&lt;T&gt; *tmp;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = top-&gt;data;</span><br><span class="line">        tmp = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = tmp;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T *item)</span> </span>&#123;                <span class="comment">// 返回栈顶内容，但不弹出</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = top-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  array-based stack: definition and implementation for some methods</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrStack</span> :</span> <span class="keyword">public</span> Stack&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:                            <span class="comment">// 栈的顺序存储</span></span><br><span class="line">    <span class="keyword">int</span> mSize;            <span class="comment">// 栈中最多可存放的元素个数</span></span><br><span class="line">    T *st;            <span class="comment">// 存放栈元素的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> top;                    <span class="comment">// 栈顶位置，应小于mSize </span></span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 栈的运算的顺序实现</span></span><br><span class="line">    arrStack(<span class="keyword">int</span> size) &#123;                <span class="comment">// 创建一个顺序栈的实例</span></span><br><span class="line">        mSize = size;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        st = <span class="keyword">new</span> T[mSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arrStack() &#123;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~arrStack() &#123;                    <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] st;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 清空栈内容</span></span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;            <span class="comment">// 入栈操作的顺序实现	</span></span><br><span class="line">        <span class="keyword">if</span> (top == mSize - <span class="number">1</span>) &#123;            <span class="comment">// 栈已满 </span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈满溢出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 新元素入栈并修改栈顶指针</span></span><br><span class="line">            st[++top] = item;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T *item)</span> </span>&#123;                                    <span class="comment">// 出栈的顺序实现</span></span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;                                   <span class="comment">// 栈为空</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *item = st[top--];             <span class="comment">// 返回栈顶元素并修改栈顶指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T *item)</span> </span>&#123;                     <span class="comment">// 返回栈顶内容，但不弹出</span></span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;                     <span class="comment">// 栈空</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *item = st[top];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (top == <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (top == mSize - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Class Declaration 类的说明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    arrStack&lt;<span class="keyword">double</span>&gt; s;        <span class="comment">// 这个栈用于压入保存操作数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">GetTwoOperands</span><span class="params">(<span class="keyword">double</span> &amp;opd1, <span class="keyword">double</span> &amp;opd2)</span></span>;    <span class="comment">// 从栈顶弹出两个操作数opd1和opd2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Compute</span><span class="params">(<span class="keyword">char</span> op)</span></span>;    <span class="comment">// 调用GetTwoOperands，并按op运算对两个操作数进行计算</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//       Calculator()&#123;&#125; ;		// 创建计算器实例，开辟一个空栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;            <span class="comment">// 后缀表达式的读入，在遇到符号&quot;=&quot;时 ，启动求值计算 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;        <span class="comment">// 计算器的清除，为随后的下一次计算做准备  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算器类class Calculator中部分成员函数的程序实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Calculator::GetTwoOperands</span><span class="params">(<span class="keyword">double</span> &amp;opd1, <span class="keyword">double</span> &amp;opd2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Missing operand!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.pop(&amp;opd1);                            <span class="comment">// 右操作数</span></span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Missing operand!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.pop(&amp;opd2);                        <span class="comment">// 左操作数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculator::Compute</span><span class="params">(<span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result;</span><br><span class="line">    <span class="keyword">double</span> operand1, operand2;</span><br><span class="line">    result = GetTwoOperands(operand1, operand2);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">                s.push(operand2 + operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">                s.push(operand2 - operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">                s.push(operand2 * operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                <span class="keyword">if</span> (operand1 == <span class="number">0.0</span>) &#123;</span><br><span class="line">                    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Divide by 0!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    s.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    s.push(operand2 / operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculator::Run</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> newOperand, res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c, c != <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                Compute(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="built_in">cin</span>.putback(c);</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; newOperand;</span><br><span class="line">                s.push(newOperand);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">        s.pop(&amp;res);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;                    <span class="comment">// 印出求值的最后结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>  &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: 			        		<span class="comment">// 队列的运算集</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;					<span class="comment">// 变为空队列</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T item)</span></span>; 		<span class="comment">// item入队，插入队尾，成功则返回真否则返回假</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T item)</span></span>;     	<span class="comment">// 返回队头元素并从队列中删除，成功则返回真</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">front</span><span class="params">(T* item)</span></span>;	       	<span class="comment">// 返回队头元素，但不删除，成功则返回真</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; 				<span class="comment">// 返回真，若队列已空</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;       			<span class="comment">// 返回真，若队列已满</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array-base queue</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrQueue</span> :</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;</span>T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mSize;                        <span class="comment">// 存放队列的数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> front;                            <span class="comment">// 表示队头所在位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> rear;                            <span class="comment">// 表示队尾所在位置的下标</span></span><br><span class="line">    T *qu;     <span class="comment">// 存放类型为T的队列元素的数组</span></span><br><span class="line"><span class="keyword">public</span>:                                <span class="comment">// 队列的运算集</span></span><br><span class="line">    arrQueue(<span class="keyword">int</span> size) &#123;                    <span class="comment">// 创建队列的实例</span></span><br><span class="line">        mSize = size + <span class="number">1</span>;                    <span class="comment">// 浪费一个存储空间，以区别队列空和队列满</span></span><br><span class="line">        qu = <span class="keyword">new</span> T[mSize];</span><br><span class="line">        front = rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~arrQueue() &#123;                    <span class="comment">// 消除该实例，并释放其空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] qu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> clear&#123;                        <span class="comment">// 清空队列</span></span><br><span class="line">            front = rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(T item)</span> </span>&#123;                <span class="comment">//  item入队，插入队尾</span></span><br><span class="line">        <span class="keyword">if</span> (((rear + <span class="number">1</span>) % mSize) == front) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列已满，溢出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qu[rear] = item;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % mSize;            <span class="comment">// 循环后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T &amp;item)</span> </span>&#123;                <span class="comment">// 返回队头元素并从队列中删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = qu[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % mSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">front</span><span class="params">(T &amp;item)</span> </span>&#123;                    <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = qu[front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Link.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkQueue</span> :</span> <span class="keyword">public</span> Queue&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;                            <span class="comment">// 队列中当前元素的个数</span></span><br><span class="line">    Link&lt;T&gt; *front;                            <span class="comment">// 表示队头的指针</span></span><br><span class="line">    Link&lt;T&gt; *rear;                            <span class="comment">// 表示队尾的指针</span></span><br><span class="line"><span class="keyword">public</span>:                                    <span class="comment">// 队列的运算集</span></span><br><span class="line">    lnkQueue(<span class="keyword">int</span> size) &#123;                        <span class="comment">// 创建队列的实例</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        front = rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~lnkQueue() &#123;                        <span class="comment">// 消除该实例，并释放其空间</span></span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                            <span class="comment">// 清空队列</span></span><br><span class="line">        <span class="keyword">while</span> (front != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rear = front;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> rear;</span><br><span class="line">        &#125;</span><br><span class="line">        rear = <span class="literal">NULL</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;                <span class="comment">//  item入队，插入队尾</span></span><br><span class="line">        <span class="keyword">if</span> (rear == <span class="literal">NULL</span>) &#123;                <span class="comment">// 空队列</span></span><br><span class="line">            front = rear = <span class="keyword">new</span> Link&lt;T&gt;(item, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 添加新的元素</span></span><br><span class="line">            rear-&gt;next = <span class="keyword">new</span> Link&lt;T&gt;(item, <span class="literal">NULL</span>);</span><br><span class="line">            rear = rear-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T *item)</span> </span>&#123;                    <span class="comment">// 返回队头元素并从队列中删除</span></span><br><span class="line">        Link&lt;T&gt; *tmp;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;                        <span class="comment">// 队列为空，没有元素可出队</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = front-&gt;data;</span><br><span class="line">        tmp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">            rear = <span class="literal">NULL</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getFront</span><span class="params">(T *item)</span> </span>&#123;                        <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;                        <span class="comment">// 队列为空，没有元素可出队</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = front-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Link&lt;T&gt; *p = front;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四-字符串"><a href="#四-字符串" class="headerlink" title="四    字符串"></a>四    字符串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String(<span class="keyword">char</span> *s) &#123;</span><br><span class="line">        size = <span class="built_in">strlen</span>(s);</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>];</span><br><span class="line">        assert(str != <span class="string">&#x27;\0&#x27;</span>);       <span class="comment">// 当开辟动态区域不成功时，运行异常退出</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">Substr</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> left = size - pos;                    <span class="comment">// 自下标pos向右计数到串尾查看剩余长度</span></span><br><span class="line">        String tmp;</span><br><span class="line">        <span class="keyword">char</span> *p, *q;</span><br><span class="line">        <span class="comment">// 以下7行语句，全是为取出子串做准备工作</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= size)                        <span class="comment">// 若下标pos值超过本串实际串长，则返回空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; left)                        <span class="comment">// 若n超过自pos以右的子串长度，则把n变小</span></span><br><span class="line">            n = left;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp.str;                    <span class="comment">// 释放原来的存储空间</span></span><br><span class="line">        tmp.str = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">        assert(tmp.str != <span class="literal">NULL</span>);                <span class="comment">// 若开辟动态存储空间失败，则退出</span></span><br><span class="line">        p = tmp.str;                        <span class="comment">//  p指向暂无内容的字符串</span></span><br><span class="line">        q = &amp;str[pos];                        <span class="comment">//  q指向本实例串str数组下标pos处</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            *p++ = *q++;                    <span class="comment">// 将q所指的内容赋值给 p，并同时后移</span></span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;                        <span class="comment">// 循环结束后，让temp.str的结尾为&#x27;\0&#x27;</span></span><br><span class="line">        tmp.size = n;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> String &amp;s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> String &amp;s) &#123;</span><br><span class="line">    os &lt;&lt; s.str;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPStrMatching</span><span class="params">(<span class="built_in">string</span> T, <span class="built_in">string</span> P,  <span class="keyword">int</span> *N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;							<span class="comment">// 模式的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;							<span class="comment">// 目标的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> pLen = P. length ( );             		<span class="comment">// 模式的长度</span></span><br><span class="line">    <span class="keyword">int</span> tLen = T.length( );					<span class="comment">// 目标的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tLen &lt; pLen) 				    		<span class="comment">// 如果目标比模式短，匹配无法成功</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);          			</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; pLen  &amp;&amp;  j &lt; tLen)  &#123;  		<span class="comment">// 反复比较对应字符来开始匹配</span></span><br><span class="line">       		<span class="keyword">if</span> ( i == <span class="number">-1</span>  ||  T[j] == P[i]) </span><br><span class="line">    			i++,  j++;</span><br><span class="line">    		<span class="keyword">else</span> i = N[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= pLen)</span><br><span class="line">    		<span class="keyword">return</span> (j - pLen + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">findNext</span><span class="params">(<span class="built_in">string</span> P)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span> m = P.length();    					<span class="comment">// m为字符串P的长度</span></span><br><span class="line">  	assert(m &gt; <span class="number">0</span>);     					<span class="comment">// 若m＝0，退出</span></span><br><span class="line">  	<span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[m];  				<span class="comment">// 动态存储区开辟整数数组</span></span><br><span class="line">    assert(next != <span class="number">0</span>);   					<span class="comment">// 若开辟存储区域失败，退出</span></span><br><span class="line">  	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) &#123; 						<span class="comment">// 计算i=1..m-1的next值</span></span><br><span class="line">		<span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; P[i] != P[k])  		<span class="comment">// 求最大首尾子串</span></span><br><span class="line">			k = next[k];		</span><br><span class="line">        i++;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">if</span> (i == m) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (P[i] == P[k] ) 				</span><br><span class="line">			next[i] = next[k];				<span class="comment">//  P[i]和P[k]相等，优化</span></span><br><span class="line">		<span class="keyword">else</span> next[i] = k;					<span class="comment">// 不需要优化，就是位置i的首尾子串长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="五-二叉树"><a href="#五-二叉树" class="headerlink" title="五    二叉树"></a>五    二叉树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  BinaryTreeNode.h  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;</span>T&gt;;	<span class="comment">//声明二叉树为结点类的友元类，便于访问私有数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T  info;				     	    	<span class="comment">//二叉树结点数据域</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* left;		   		<span class="comment">//二叉树结点指向左子树的指针</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* right;    			<span class="comment">//二叉树结点指向左子树的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTreeNode();							<span class="comment">//缺省构造函数</span></span><br><span class="line">	BinaryTreeNode(<span class="keyword">const</span> T&amp; inf);	 			<span class="comment">//给定数据的构造函数</span></span><br><span class="line">	BinaryTreeNode(<span class="keyword">const</span> T&amp; inf,BinaryTreeNode&lt;T&gt;* l, BinaryTreeNode&lt;T&gt;* r);<span class="comment">//给定了结点值和左右子树的构造函数</span></span><br><span class="line">	<span class="function">T  <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>;							<span class="comment">//返回当前结点的数据</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;*  <span class="title">leftchild</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//返回当前结点左子树</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;*  <span class="title">rightchild</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//返回当前结点右子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setLeftchild</span><span class="params">(BinaryTreeNode&lt;T&gt;*)</span> </span>;	<span class="comment">//设置当前结点的左子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setRightchild</span><span class="params">(BinaryTreeNode&lt;T&gt;*)</span> </span>;	<span class="comment">//设置当前结点的右子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>; 				<span class="comment">//设置当前结点的数据域</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span>  <span class="title">isLeaf</span><span class="params">()</span> <span class="keyword">const</span></span>;				<span class="comment">//判定当前结点是否为叶结点,若是返回true</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> BinaryTreeNode&lt;T&gt;&amp; Node)&#123;<span class="keyword">this</span> = Node;&#125;;<span class="comment">//重载赋值操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//****** BinaryTreeNode Implementation *******//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode()  &#123;</span><br><span class="line">	left = right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode(<span class="keyword">const</span> T&amp; inf)  &#123;	<span class="comment">//给定数据的构造函数</span></span><br><span class="line">	info = inf;</span><br><span class="line">	left = right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode(<span class="keyword">const</span> T&amp; inf,BinaryTreeNode* l, BinaryTreeNode* r)  &#123;<span class="comment">//给定数据的左右指针的构造函数</span></span><br><span class="line">	info = inf;</span><br><span class="line">	left = l;</span><br><span class="line">	right = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T  BinaryTreeNode&lt;T&gt;::value() <span class="keyword">const</span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> info; </span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;*  BinaryTreeNode&lt;T&gt;::leftchild() <span class="keyword">const</span>  &#123; <span class="comment">//返回当前结点指向左子树的指针</span></span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;												</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;*  BinaryTreeNode&lt;T&gt;::rightchild() <span class="keyword">const</span>  &#123; <span class="comment">//返回当前结点指向右子树的指针</span></span><br><span class="line">	<span class="keyword">return</span> right;								</span><br><span class="line">&#125;			</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setLeftchild(BinaryTreeNode&lt;T&gt;* subroot)  &#123; <span class="comment">//设置当前结点的左子树</span></span><br><span class="line">	left = subroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setRightchild(BinaryTreeNode&lt;T&gt;* subroot)  &#123; <span class="comment">//设置当前结点的右子树</span></span><br><span class="line">	right = subroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setValue(<span class="keyword">const</span> T&amp; val)  &#123;	<span class="comment">//设置当前结点的数据域</span></span><br><span class="line">	info = val; </span><br><span class="line">&#125; 									</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span>  BinaryTreeNode&lt;T&gt;::isLeaf() <span class="keyword">const</span>	 &#123;	<span class="comment">//判定当前结点是否为叶结点,若是返回true</span></span><br><span class="line">	<span class="keyword">return</span> (left == <span class="literal">NULL</span>) &amp;&amp; (right == <span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************BinaryTree.h****************//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BinaryTreeNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Tags</span>&#123;</span>Left,Right&#125;;    <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackElement</span>  &#123;</span>         <span class="comment">//StackElement</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer;</span><br><span class="line">	Tags tag;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	BinaryTreeNode&lt;T&gt;*  root;      			<span class="comment">//二叉树根结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTree()&#123;root = <span class="literal">NULL</span>;&#125;;				<span class="comment">//构造函数</span></span><br><span class="line">	~BinaryTree() &#123;DeleteBinaryTree(root);&#125;;	<span class="comment">//析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;						<span class="comment">//判定二叉树是否为空树</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">Root</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> root;&#125;;	<span class="comment">//返回二叉树根结点</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">Parent</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;<span class="comment">//返回current的父结点</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">LeftSibling</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;</span><br><span class="line">	<span class="comment">//返回current结点的左兄弟</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">RightSibling</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;</span><br><span class="line">	<span class="comment">//返回current结点的右兄弟</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(<span class="keyword">const</span> T&amp; info, BinaryTree&lt;T&gt;&amp; leftTree, BinaryTree&lt;T&gt;&amp; rightTree)</span></span>;</span><br><span class="line">	<span class="comment">//构造一棵以info为根、leftTree和rightTree为左右子树的新二叉树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;  	<span class="comment">//前序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;		<span class="comment">//中序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;	<span class="comment">//后序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归前序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归中序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归后序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>; 	<span class="comment">//按层次周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DeleteBinaryTree</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;	<span class="comment">//删除二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; Value;&#125;;           <span class="comment">//访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********  BianryTree Implementation  ***********//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;T&gt;:: isEmpty() <span class="keyword">const</span>  &#123;      <span class="comment">//判定二叉树是否为空树</span></span><br><span class="line">	<span class="keyword">return</span> ( root? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::Parent(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;						<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> != root &amp;&amp; <span class="literal">NULL</span> != current)  &#123;		</span><br><span class="line">		<span class="keyword">while</span>(!aStack.empty() || pointer)	&#123;</span><br><span class="line">			<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">				<span class="keyword">if</span>(current == pointer-&gt;leftchild() ||current == pointer-&gt;rightchild()) <span class="comment">//如果当前pointer的孩子就是current，返回parent</span></span><br><span class="line">					<span class="keyword">return</span> pointer;</span><br><span class="line">				aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">				pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  &#123;                         <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">				pointer = aStack.top();			<span class="comment">//栈顶元素退栈                 </span></span><br><span class="line">				aStack.pop();</span><br><span class="line">				pointer = pointer-&gt;rightchild();  	<span class="comment">//当前链接结构指向右孩子</span></span><br><span class="line">			&#125;<span class="comment">//endif</span></span><br><span class="line">		&#125; <span class="comment">//endwhile</span></span><br><span class="line">	&#125;<span class="comment">//endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::LeftSibling(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="comment">//返回current结点的左兄弟</span></span><br><span class="line">	<span class="keyword">if</span>(current)  &#123;</span><br><span class="line">		BinaryTreeNode&lt;T&gt;* temp = Parent(current);    <span class="comment">//返回current结点的父结点</span></span><br><span class="line">		<span class="keyword">if</span> ((temp == <span class="literal">NULL</span>) || current == temp-&gt;leftchild())</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">NULL</span>;	  <span class="comment">//如果父结点为空，或者current没有左兄弟，返回空</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> temp-&gt;leftchild();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::RightSibling(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="comment">//返回current结点的右兄弟</span></span><br><span class="line">	<span class="keyword">if</span>(current)  &#123;</span><br><span class="line">		BinaryTreeNode&lt;T&gt;* temp = Parent(current);<span class="comment">//返回current结点的父结点</span></span><br><span class="line">		<span class="keyword">if</span>(temp == <span class="literal">NULL</span>||current == temp-&gt;rightchild())</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">NULL</span>;		    <span class="comment">//如果父结点为空，或者current没有右兄弟</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> temp-&gt;rightchild();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: CreateTree (<span class="keyword">const</span> T&amp; info, BinaryTree&lt;T&gt;&amp; leftTree, BinaryTree&lt;T&gt;&amp; rightTree)  &#123;</span><br><span class="line">	<span class="comment">//由左子树leftTree、右子树rightTree和数据元素info创建一棵新树，根结点是info</span></span><br><span class="line">	<span class="comment">//其中this、leftTree、rightTree必须是不同的三棵树</span></span><br><span class="line">	root = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;(info, leftTree.root, rightTree.root);	<span class="comment">//创建新树</span></span><br><span class="line">	leftTree.root = rightTree.root = <span class="literal">NULL</span>;  <span class="comment">//原来两棵子树的根结点指空，避免访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: DeleteBinaryTree(BinaryTreeNode&lt;T&gt;* root)  &#123; <span class="comment">//以后序周游的方式删除二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root)  &#123;</span><br><span class="line">		DeleteBinaryTree(root-&gt;left);				<span class="comment">//递归删除左子树</span></span><br><span class="line">		DeleteBinaryTree(root-&gt;right);		    <span class="comment">//递归删除右子树</span></span><br><span class="line">		<span class="keyword">delete</span> root;							<span class="comment">//删除根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrder (BinaryTreeNode&lt;T&gt;* root)  &#123;  <span class="comment">//前序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">		PreOrder(root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		PreOrder(root-&gt;rightchild());			<span class="comment">//访问右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: InOrder (BinaryTreeNode&lt;T&gt;* root)  &#123;  <span class="comment">//中序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		InOrder (root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">		InOrder (root-&gt;rightchild());			<span class="comment">//访问右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: PostOrder (BinaryTreeNode&lt;T&gt;* root)  &#123; <span class="comment">//后序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		PostOrder(root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		PostOrder (root-&gt;rightchild());		<span class="comment">//访问右子树</span></span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;<span class="comment">//非递归前序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;						<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">while</span>(!aStack.empty() || pointer)	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">			Visit(pointer-&gt;value());			<span class="comment">//访问当前结点</span></span><br><span class="line">			aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  &#123;                         <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">			pointer = aStack.top();			<span class="comment">//栈顶元素退栈                 </span></span><br><span class="line">			aStack.pop();</span><br><span class="line">			pointer = pointer-&gt;rightchild();  	<span class="comment">//当前链接结构指向右孩子</span></span><br><span class="line">		&#125;<span class="comment">//endif</span></span><br><span class="line">    &#125; <span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::InOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;</span><br><span class="line">	<span class="comment">//非递归中序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;							<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">while</span>(!aStack.empty() || pointer)  &#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">			aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  &#123;                            <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">			pointer = aStack.top();</span><br><span class="line">			aStack.pop();					<span class="comment">//栈顶元素退栈    </span></span><br><span class="line">			Visit(pointer-&gt;value());		<span class="comment">//访问当前结点</span></span><br><span class="line">			pointer = pointer-&gt;rightchild(); 	<span class="comment">//当前链接结构指向右孩子             </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PostOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;</span><br><span class="line">	<span class="comment">//非递归后序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;							<span class="comment">//使用STL栈部分</span></span><br><span class="line">	StackElement&lt;T&gt; element;</span><br><span class="line">	<span class="built_in">stack</span>&lt;StackElement&lt;T &gt; &gt; aStack;			<span class="comment">//栈申明</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;							<span class="comment">//空树即返回</span></span><br><span class="line">	<span class="keyword">else</span> pointer = root;						<span class="comment">//保存输入参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!aStack.empty() || pointer) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pointer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			element.pointer = pointer;</span><br><span class="line">			element.tag = Left;</span><br><span class="line">			aStack.push(element);</span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//沿左子树方向向下周游</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		element = aStack.top();</span><br><span class="line">		aStack.pop();							<span class="comment">//托出栈顶元素</span></span><br><span class="line">		pointer = element.pointer;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (element.tag == Left)&#123;</span><br><span class="line">			<span class="comment">//从左子树回来</span></span><br><span class="line">			element.tag = Right;</span><br><span class="line">			aStack.push(element);</span><br><span class="line">			pointer = pointer-&gt;rightchild();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                                  <span class="comment">//从右子树回来</span></span><br><span class="line">			Visit(pointer-&gt;value());		    <span class="comment">//访问当前结点</span></span><br><span class="line">			pointer = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::LevelOrder(BinaryTreeNode&lt;T&gt;* root)	&#123;</span><br><span class="line">	<span class="comment">//按层次周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;							<span class="comment">//使用STL的队列</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;BinaryTreeNode&lt;T&gt;*&gt; aQueue;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;			<span class="comment">//保存输入参数</span></span><br><span class="line">	<span class="keyword">if</span> (pointer)</span><br><span class="line">		aQueue.push(pointer);                  <span class="comment">//根结点入队列</span></span><br><span class="line">	<span class="keyword">while</span> (!aQueue.empty())  &#123;                 <span class="comment">//队列非空</span></span><br><span class="line">		pointer = aQueue.front();			 	<span class="comment">//取队列首结点</span></span><br><span class="line">		aQueue.pop();                        <span class="comment">//当前结点出队列</span></span><br><span class="line">        Visit(pointer-&gt;value());					<span class="comment">//访问当前结点</span></span><br><span class="line">		<span class="keyword">if</span>(pointer-&gt;leftchild())</span><br><span class="line">			aQueue.push(pointer-&gt;leftchild());		<span class="comment">//左子树进队列</span></span><br><span class="line">		<span class="keyword">if</span>(pointer-&gt;rightchild())</span><br><span class="line">			aQueue.push(pointer-&gt;rightchild());	<span class="comment">//右子树进队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*******  BinarySearchTree.h  ******//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;BinaryTreeNode.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BinaryTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> :</span> <span class="keyword">public</span> BinaryTree&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinarySearchTree() &#123; <span class="keyword">this</span>-&gt;root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~BinarySearchTree() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(BinaryTreeNode&lt;T&gt; *newpointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt; *<span class="title">Root</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;root; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(BinaryTreeNode&lt;T&gt; *root, BinaryTreeNode&lt;T&gt; *newpointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(BinaryTreeNode&lt;T&gt; *pointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNodeEx</span><span class="params">(BinaryTreeNode&lt;T&gt; *pointer)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********  implemention ***********//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::Initialize(BinaryTreeNode&lt;T&gt; *newpointer) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root = newpointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::InsertNode(BinaryTreeNode&lt;T&gt; *root,</span><br><span class="line">                                     BinaryTreeNode&lt;T&gt; *newpointer) &#123;                          <span class="comment">//向二叉搜索树插入新结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;                 <span class="comment">//如果是空树，初始化</span></span><br><span class="line">        Initialize(newpointer);            <span class="comment">//用指针newpointer初始化二叉搜索树树根，赋值实现</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        pointer = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newpointer-&gt;value() == pointer-&gt;value())</span><br><span class="line">            <span class="keyword">return</span>;                      <span class="comment">//相等则不用插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newpointer-&gt;value() &lt; pointer-&gt;value()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pointer-&gt;leftchild() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pointer-&gt;left = newpointer;        <span class="comment">//作为左子树</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> pointer = pointer-&gt;leftchild();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pointer-&gt;rightchild() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pointer-&gt;right = newpointer;      <span class="comment">//作为右子树</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> pointer = pointer-&gt;rightchild();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void BinarySearchTree&lt;T&gt;::DeleteNode(BinaryTreeNode&lt;T&gt;* pointer)  &#123;      //教材中写出这个算法</span></span><br><span class="line"><span class="comment">	//二叉搜索树中结点的删除</span></span><br><span class="line"><span class="comment">	BinaryTreeNode&lt;T&gt;* temppointer = NULL;</span></span><br><span class="line"><span class="comment">	if(!pointer)                            //如果删除的是空结点，则返回</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	BinaryTreeNode&lt;T&gt;* parent = Parent(pointer);</span></span><br><span class="line"><span class="comment">	if (pointer-&gt;leftchild() == NULL)  &#123;</span></span><br><span class="line"><span class="comment">		//被删结点无左子树，则将其右子树的根代替该删除结点</span></span><br><span class="line"><span class="comment">		if (parent == NULL)                 //被删除结点是根结点</span></span><br><span class="line"><span class="comment">			root = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		else if (parent-&gt;leftchild() == pointer)</span></span><br><span class="line"><span class="comment">			parent-&gt;left = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">			parent-&gt;right = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		delete pointer;                     //删除该结点</span></span><br><span class="line"><span class="comment">		pointer = NULL;</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	else                                 //左子树不为空时</span></span><br><span class="line"><span class="comment">		temppointer = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	while (temppointer-&gt;rightchild() != NULL)  //在左子树中找对称序的最后一个结点</span></span><br><span class="line"><span class="comment">		temppointer = temppointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">	//被删除结点的右子树作为temppointer的右子树</span></span><br><span class="line"><span class="comment">	temppointer-&gt;right = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">	//被删除结点的左子树根代替被删除结点</span></span><br><span class="line"><span class="comment">	if(NULL == parent)</span></span><br><span class="line"><span class="comment">		root = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	else if (parent-&gt;leftchild() == pointer)</span></span><br><span class="line"><span class="comment">		parent-&gt;left = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	else </span></span><br><span class="line"><span class="comment">		parent-&gt;right = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	delete pointer;                          //删除该结点</span></span><br><span class="line"><span class="comment">	pointer = NULL;</span></span><br><span class="line"><span class="comment">	return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::DeleteNodeEx(BinaryTreeNode&lt;T&gt; *pointer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pointer == <span class="literal">NULL</span>)                    <span class="comment">// 若待删除结点不存在，返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *temppointer;         <span class="comment">// 用于保存替换结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *tempparent = <span class="literal">NULL</span>;  <span class="comment">// 用于保存替换结点的父结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *parent = Parent(pointer); <span class="comment">// 保存删除结点的父结点</span></span><br><span class="line">    <span class="comment">// 如果待删除结点的左子树为空，就将它的右子树代替它</span></span><br><span class="line">    <span class="keyword">if</span> (pointer-&gt;leftchild() == <span class="literal">NULL</span>)</span><br><span class="line">        temppointer = pointer-&gt;rightchild();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当待删除结点左子树不为空，就在左子树中寻找最大结点替换待删除结点</span></span><br><span class="line">        temppointer = pointer-&gt;leftchild();</span><br><span class="line">        <span class="keyword">while</span> (temppointer-&gt;rightchild() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tempparent = temppointer;</span><br><span class="line">            temppointer = temppointer-&gt;rightchild();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除替换结点</span></span><br><span class="line">        <span class="keyword">if</span> (tempparent == <span class="literal">NULL</span>)</span><br><span class="line">            pointer-&gt;left = temppointer-&gt;leftchild();</span><br><span class="line">        <span class="keyword">else</span> tempparent-&gt;right = temppointer-&gt;leftchild();</span><br><span class="line">        temppointer-&gt;left = pointer-&gt;leftchild();    <span class="comment">// 继承pointer的左子树</span></span><br><span class="line">        temppointer-&gt;right = pointer-&gt;rightchild();  <span class="comment">// 继承pointer的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用替换结点去替代真正的删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = temppointer;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;leftchild() == pointer)</span><br><span class="line">        parent-&gt;left = temppointer;</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;right = temppointer;</span><br><span class="line">    <span class="keyword">delete</span> pointer;                            <span class="comment">// 删除该结点</span></span><br><span class="line">    pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************  算法5.12 堆的类定义和筛选法  **********************/</span></span><br><span class="line"><span class="comment">/****************           MinHeap.h           **********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> &#123;</span>                            <span class="comment">//最小堆类定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heapArray;                            <span class="comment">//存放堆数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> CurrentSize;                        <span class="comment">//当前堆中元素数目</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                            <span class="comment">//堆所能容纳的最大元素数目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> pos_x, <span class="keyword">int</span> pos_y)</span></span>;        <span class="comment">//交换位置x和y的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">()</span></span>;                        <span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinHeap(<span class="keyword">const</span> <span class="keyword">int</span> n);                 <span class="comment">//构造函数,n表示初始化堆的最大元素数目</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MinHeap() &#123; <span class="keyword">delete</span>[]heapArray; &#125;;    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                            <span class="comment">// 如果堆空，则返回真</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//如果是叶结点，返回TRUE</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回左孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rightchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回右孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//返回父结点位置</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> pos, T &amp;node)</span></span>;            <span class="comment">//删除给定下标的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T &amp;newNode)</span></span>;            <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="function">T &amp;<span class="title">RemoveMin</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶删除最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftUp</span><span class="params">(<span class="keyword">int</span> position)</span></span>;             <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftDown</span><span class="params">(<span class="keyword">int</span> left)</span></span>;             <span class="comment">//筛选法函数，参数left表示开始处理的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">MinHeap&lt;T&gt;::MinHeap(<span class="keyword">const</span> <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    CurrentSize = <span class="number">0</span>;</span><br><span class="line">    MaxSize = n;                        <span class="comment">//初始化堆容量为n</span></span><br><span class="line">    heapArray = <span class="keyword">new</span> T[MaxSize];            <span class="comment">//创建堆空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处进行堆元素的赋值工作</span></span><br><span class="line">    heapArray[<span class="number">0</span>] = <span class="number">19</span>;                 <span class="comment">//亦可以用插入的办法构造</span></span><br><span class="line">    heapArray[<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line">    heapArray[<span class="number">2</span>] = <span class="number">35</span>;</span><br><span class="line">    heapArray[<span class="number">3</span>] = <span class="number">65</span>;</span><br><span class="line">    heapArray[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    heapArray[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">    heapArray[<span class="number">6</span>] = <span class="number">7</span>;</span><br><span class="line">    heapArray[<span class="number">7</span>] = <span class="number">45</span>;</span><br><span class="line">    CurrentSize = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    BuildHeap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::isEmpty() &#123;            <span class="comment">// 如果堆空，则返回真&#123;</span></span><br><span class="line">    <span class="keyword">return</span> ((CurrentSize) ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::isLeaf(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &gt;= CurrentSize / <span class="number">2</span>) &amp;&amp; (pos &lt; CurrentSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::BuildHeap() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = CurrentSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)    <span class="comment">//反复调用筛选函数</span></span><br><span class="line">        SiftDown(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::leftchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">1</span>;                        <span class="comment">//返回左孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::rightchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">2</span>;                          <span class="comment">//返回右孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::parent(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos - <span class="number">1</span>) / <span class="number">2</span>;                           <span class="comment">//返回父结点位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::Insert(<span class="keyword">const</span> T &amp;newNode) &#123;  <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == MaxSize)                   <span class="comment">//堆空间已经满</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    heapArray[CurrentSize] = newNode;</span><br><span class="line">    SiftUp(CurrentSize);                       <span class="comment">//向上调整</span></span><br><span class="line">    CurrentSize++;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::SiftUp(<span class="keyword">int</span> position) &#123;    <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="keyword">int</span> temppos = position;</span><br><span class="line">    T temp = heapArray[temppos];</span><br><span class="line">    <span class="keyword">while</span> ((temppos &gt; <span class="number">0</span>) &amp;&amp; (heapArray[parent(temppos)] &gt; temp)) &#123;</span><br><span class="line">        heapArray[temppos] = heapArray[parent(temppos)];</span><br><span class="line">        temppos = parent(temppos);</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[temppos] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::swap(<span class="keyword">int</span> pos_x, <span class="keyword">int</span> pos_y)     <span class="comment">//交换位置x和y的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    T temp = heapArray[pos_x];</span><br><span class="line">    heapArray[pos_x] = heapArray[pos_y];</span><br><span class="line">    heapArray[pos_y] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T &amp;MinHeap&lt;T&gt;::RemoveMin() &#123;                <span class="comment">//从堆顶删除最小值</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Can&#x27;t Delete&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        swap(<span class="number">0</span>, --CurrentSize);                    <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (CurrentSize &gt; <span class="number">1</span>)</span><br><span class="line">            SiftDown(<span class="number">0</span>);                        <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        <span class="keyword">return</span> heapArray[CurrentSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::Remove(<span class="keyword">int</span> pos, T &amp;node) &#123;    <span class="comment">// 删除给定下标的元素</span></span><br><span class="line">    <span class="keyword">if</span> ((pos &lt; <span class="number">0</span>) || (pos &gt;= CurrentSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    node = heapArray[pos];</span><br><span class="line">    heapArray[pos] = heapArray[--CurrentSize];        <span class="comment">// 用最后的元素值替代删除位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (heapArray[parent(pos)] &gt; heapArray[pos])</span><br><span class="line">        SiftUp(pos);                        <span class="comment">// 当前元素小于父结点，需要上升调整</span></span><br><span class="line">    <span class="keyword">else</span> SiftDown(pos);                        <span class="comment">// 当前元素大于父结点，向下筛</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::SiftDown(<span class="keyword">int</span> left) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = left;                                <span class="comment">// 标识父结点</span></span><br><span class="line">    <span class="keyword">int</span> j = leftchild(i);                            <span class="comment">// 标识关键值较小的子结点</span></span><br><span class="line">    T temp = heapArray[i];                    <span class="comment">// 保存父结点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; CurrentSize) &#123;                    <span class="comment">// 过筛</span></span><br><span class="line">        <span class="keyword">if</span> ((j &lt; CurrentSize - <span class="number">1</span>) &amp;&amp; (heapArray[j] &gt; heapArray[j + <span class="number">1</span>]))</span><br><span class="line">            j++;                                <span class="comment">// j指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; heapArray[j]) &#123;</span><br><span class="line">            heapArray[i] = heapArray[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = leftchild(j);                        <span class="comment">// 向下继续</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -------- HuffmanTree.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T info;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *parent;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *left;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HuffmanTreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">leftchild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> left; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">rightchild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> right; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info &gt; HN.info; &#125;; <span class="comment">// 注意要重载运算符</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info &lt; HN.info; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info == HN.info; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *root;                    <span class="comment">//Huffman树的树根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把ht1和ht2为根的Huffman子树合并成一棵以parent为根的二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MergeTree</span><span class="params">(HuffmanTreeNode&lt;T&gt; &amp;ht1, HuffmanTreeNode&lt;T&gt; &amp;ht2, HuffmanTreeNode&lt;T&gt; *parent)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(HuffmanTreeNode&lt;T&gt; *root)</span></span>;<span class="comment">//删除Huffman树或其子树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造Huffman树，weight是存储权值的数组，n是数组长度</span></span><br><span class="line">    HuffmanTree(T weight[], <span class="keyword">int</span> n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~HuffmanTree() &#123; DeleteTree(root); &#125;;    <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(HuffmanTreeNode&lt;T&gt; *root)</span></span>;          <span class="comment">//中序周游 </span></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">GetRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">HuffmanTree&lt;T&gt;::HuffmanTree(T weight[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">    MinHeap&lt;HuffmanTreeNode&lt;T&gt; &gt; heap(n);        <span class="comment">//定义最小值堆</span></span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *parent, firstchild, secondchild;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *NodeList = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;                    <span class="comment">//初始化</span></span><br><span class="line">        NodeList[i].info = weight[i];</span><br><span class="line">        NodeList[i].parent = NodeList[i].left = NodeList[i].right = <span class="literal">NULL</span>;</span><br><span class="line">        heap.Insert(NodeList[i]);                <span class="comment">//向堆中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;                    <span class="comment">//通过n-1次合并建立Huffman树</span></span><br><span class="line">        parent = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;;</span><br><span class="line">        firstchild = heap.RemoveMin();                <span class="comment">//选择权值最小的结点</span></span><br><span class="line">        secondchild = heap.RemoveMin();                <span class="comment">//选择权值次小的结点</span></span><br><span class="line">        MergeTree(firstchild, secondchild, parent);    <span class="comment">//合并权值最小的两棵树</span></span><br><span class="line">        heap.Insert(*parent);                    <span class="comment">//把parent插入到堆中去</span></span><br><span class="line">        root = parent;                            <span class="comment">//建立根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[]NodeList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::DeleteTree(HuffmanTreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        DeleteTree(root-&gt;left);</span><br><span class="line">        DeleteTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::InOrder(HuffmanTreeNode&lt;T&gt; *root) &#123; <span class="comment">//中序周游</span></span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        InOrder(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        InOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::MergeTree(HuffmanTreeNode&lt;T&gt; &amp;ht1, HuffmanTreeNode&lt;T&gt; &amp;ht2, HuffmanTreeNode&lt;T&gt; *parent) &#123;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *l = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;();</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *r = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    *l = ht1; <span class="comment">// 不能写为l = &amp;ht1，注意地址引用，开辟的是新空间，或者应用拷贝构造函数，只是有些麻烦</span></span><br><span class="line">    *r = ht2;</span><br><span class="line"></span><br><span class="line">    parent-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    parent-&gt;left = l;</span><br><span class="line">    parent-&gt;right = r;</span><br><span class="line">    parent-&gt;info = ht1.info + ht2.info;</span><br><span class="line">    ht1.parent = ht2.parent = parent; <span class="comment">// 指向父节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="六-树"><a href="#六-树" class="headerlink" title="六    树"></a>六    树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>        <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value);             <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~TreeNode() &#123;&#125;;                 <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span>;                         <span class="comment">//如果结点是叶，返回true</span></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span></span>;                             <span class="comment">//返回结点的值 </span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span></span>;         <span class="comment">//返回第一个左孩子</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span></span>;         <span class="comment">//返回右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;)</span></span>;                     <span class="comment">//设置结点的值 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span></span>;     <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span></span>;   <span class="comment">//设置右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertFirst</span><span class="params">(TreeNode&lt;T&gt; *node)</span></span>;     <span class="comment">//以第一个左孩子身份插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertNext</span><span class="params">(TreeNode&lt;T&gt; *node)</span></span>;     <span class="comment">//以右兄弟的身份插入结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt;::TreeNode(<span class="keyword">const</span> T &amp;value) &#123;    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    m_Value = value;</span><br><span class="line">    pChild = <span class="literal">NULL</span>;</span><br><span class="line">    pSibling = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> TreeNode&lt;T&gt;::isLeaf() &#123;</span><br><span class="line">    <span class="comment">//如果结点是叶，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (pChild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T TreeNode&lt;T&gt;::Value() &#123;                    <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="keyword">return</span> m_Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt; *TreeNode&lt;T&gt;::LeftMostChild() &#123; <span class="comment">//返回第一个左孩子</span></span><br><span class="line">    <span class="keyword">return</span> pChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt; *TreeNode&lt;T&gt;::RightSibling() &#123;    <span class="comment">//返回右兄弟</span></span><br><span class="line">    <span class="keyword">return</span> pSibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setValue(T &amp;value) &#123;</span><br><span class="line">    <span class="comment">//设置结点的值</span></span><br><span class="line">    m_Value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setChild(TreeNode&lt;T&gt; *pointer) &#123;  <span class="comment">//设置左孩子</span></span><br><span class="line">    pChild = pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setSibling(TreeNode&lt;T&gt; *pointer) &#123;  <span class="comment">//设置右兄弟</span></span><br><span class="line">    pSibling = pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::InsertFirst(TreeNode&lt;T&gt; *node) &#123;</span><br><span class="line">    <span class="comment">//以第一个孩子的身份插入结点</span></span><br><span class="line">    <span class="keyword">if</span> (pChild)</span><br><span class="line">        node-&gt;pSibling = pChild;</span><br><span class="line">    pChild = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::InsertNext(TreeNode&lt;T&gt; *node) &#123; <span class="comment">//以右兄弟的身份插入结点</span></span><br><span class="line">    <span class="keyword">if</span> (pSibling)</span><br><span class="line">        node-&gt;pSibling = pSibling;</span><br><span class="line">    pSibling = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;queue&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode &lt;T&gt; *root;                         <span class="comment">//树根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DestroyNodes</span><span class="params">(TreeNode &lt;T&gt; *root)</span></span>;       <span class="comment">//删除以root为根的子树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree();                                        <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Tree();                            <span class="comment">//析构函数</span></span><br><span class="line">    TreeNode &lt;T&gt; *getRoot();                        <span class="comment">//返回树中的根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateRoot</span><span class="params">(<span class="keyword">const</span> T &amp;rootValue)</span></span>;     <span class="comment">//创建树中的根结点，使根结点元素的值为rootValue</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                             <span class="comment">//判断是否为空树，如果是则返回true</span></span><br><span class="line">    TreeNode &lt;T&gt; *Parent(TreeNode &lt;T&gt; *current);        <span class="comment">//返回current结点的父结点</span></span><br><span class="line">    TreeNode &lt;T&gt; *PrevSibling(TreeNode &lt;T&gt; *current); <span class="comment">//返回current结点的前一个邻居结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteSubTree</span><span class="params">(TreeNode &lt;T&gt; *subroot)</span></span>;        <span class="comment">//删除以subroot为根的子树的所有结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RootFirstTraverse</span><span class="params">(TreeNode &lt;T&gt; *root)</span></span>;        <span class="comment">//先根深度优先周游树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RootLastTraverse</span><span class="params">(TreeNode &lt;T&gt; *root)</span></span>;        <span class="comment">//后根深度优先周游树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WidthTraverse</span><span class="params">(TreeNode &lt;T&gt; *root)</span></span>;            <span class="comment">//广度优先周游树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123;                            <span class="comment">//访问</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Tree&lt;T&gt;::Tree() &#123;                            <span class="comment">//构造函数</span></span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Tree&lt;T&gt;::~Tree() &#123;                            <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">while</span> (root)</span><br><span class="line">        DeleteSubTree(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode &lt;T&gt; *Tree&lt;T&gt;::getRoot() &#123;            <span class="comment">//返回树中的根结点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::CreateRoot(<span class="keyword">const</span> T &amp;rootValue) &#123;<span class="comment">//创建树中的根结点，使根结点元素的值为rootValue</span></span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode&lt;T&gt;(rootValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Tree&lt;T&gt;::isEmpty() &#123;         <span class="comment">//判断是否为空树，如果是则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode &lt;T&gt; *Tree&lt;T&gt;::PrevSibling(TreeNode &lt;T&gt; *current) &#123;<span class="comment">//返回current结点的前一个邻居结点</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;                                <span class="comment">//使用STL队列</span></span><br><span class="line">    <span class="built_in">queue</span> &lt; TreeNode &lt; T &gt; * &gt; aQueue;</span><br><span class="line">    TreeNode &lt;T&gt; *pointer = root;                        <span class="comment">//标识当前结点</span></span><br><span class="line">    TreeNode &lt;T&gt; *prev = <span class="literal">NULL</span>;                        <span class="comment">//标识当前结点的前一个兄弟结点</span></span><br><span class="line">    <span class="comment">//当前结点为空，树为空或所求结点为根结点时，返回NULL	</span></span><br><span class="line">    <span class="keyword">if</span> ((current == <span class="literal">NULL</span>) || (pointer == <span class="literal">NULL</span>) || (current == root))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (pointer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointer == current)</span><br><span class="line">            <span class="keyword">return</span> prev;                            <span class="comment">//找到当前结点</span></span><br><span class="line">        aQueue.push(pointer);</span><br><span class="line">        prev = pointer;</span><br><span class="line">        pointer = pointer-&gt;pSibling;                    <span class="comment">//沿当前结点右兄弟结点链寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!aQueue.empty()) &#123;</span><br><span class="line">        prev = <span class="literal">NULL</span>;</span><br><span class="line">        pointer = aQueue.front();</span><br><span class="line">        aQueue.pop();                                <span class="comment">//出队列</span></span><br><span class="line">        pointer = pointer-&gt;LeftMostChild();            <span class="comment">//下降到左子结点</span></span><br><span class="line">        <span class="keyword">while</span> (pointer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pointer == current)</span><br><span class="line">                <span class="keyword">return</span> prev;</span><br><span class="line">            aQueue.push(pointer);</span><br><span class="line">            prev = pointer;</span><br><span class="line">            pointer = pointer-&gt;pSibling;                <span class="comment">//沿当前结点右兄弟结点链寻找</span></span><br><span class="line">        &#125;<span class="comment">//end while</span></span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode &lt;T&gt; *Tree&lt;T&gt;::Parent(TreeNode &lt;T&gt; *current) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;                                <span class="comment">// 使用STL队列</span></span><br><span class="line">    <span class="built_in">queue</span> &lt; TreeNode &lt; T &gt; * &gt; aQueue;</span><br><span class="line">    TreeNode &lt;T&gt; *pointer = root;</span><br><span class="line">    TreeNode &lt;T&gt; *upperlevelpointer = <span class="literal">NULL</span>;            <span class="comment">// 用于记录parent结点</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span> &amp;&amp; pointer != current) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pointer) &#123;                            <span class="comment">// 森林中所有根结点进队列</span></span><br><span class="line">            <span class="keyword">if</span> (current == pointer)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;                    <span class="comment">// 根的父结点指针为空，返回</span></span><br><span class="line">            aQueue.push(pointer);</span><br><span class="line">            pointer = pointer-&gt;RightSibling();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!aQueue.empty()) &#123;</span><br><span class="line">            pointer = aQueue.front();                    <span class="comment">// 取队列首结点指针</span></span><br><span class="line">            aQueue.pop();                            <span class="comment">// 出队列	</span></span><br><span class="line">            upperlevelpointer = pointer;                    <span class="comment">// 指向上一层的结点</span></span><br><span class="line">            pointer = pointer-&gt;LeftMostChild();        <span class="comment">// 指向当前结点的最左孩子</span></span><br><span class="line">            <span class="keyword">while</span> (pointer) &#123;                        <span class="comment">// 当前结点的子结点进队列</span></span><br><span class="line">                <span class="keyword">if</span> (current == pointer)</span><br><span class="line">                    <span class="keyword">return</span> upperlevelpointer;        <span class="comment">// 返回父结点指针</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    aQueue.push(pointer);</span><br><span class="line">                    pointer = pointer-&gt;RightSibling();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//end while</span></span><br><span class="line">        &#125;<span class="comment">//end while</span></span><br><span class="line">    &#125;<span class="comment">//end if</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::DestroyNodes(TreeNode &lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="comment">//删除以root为根的子树的所有结点</span></span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        DestroyNodes(root-&gt;LeftMostChild());    <span class="comment">//递归删除第一子树</span></span><br><span class="line">        DestroyNodes(root-&gt;RightSibling());        <span class="comment">//递归删除其他子树</span></span><br><span class="line">        <span class="keyword">delete</span> root;                            <span class="comment">//删除根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::DeleteSubTree(TreeNode &lt;T&gt; *subroot) &#123;</span><br><span class="line">    <span class="comment">// 删除以subroot为根的子树的所有结点</span></span><br><span class="line">    <span class="keyword">if</span> (subroot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode &lt;T&gt; *pointer = Parent(subroot);    <span class="comment">// 找subroot的父结点</span></span><br><span class="line">    <span class="keyword">if</span> (pointer == <span class="literal">NULL</span>)                            <span class="comment">// subroot就是森林第一个树根</span></span><br><span class="line">        root = subroot-&gt;RightSibling();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pointer-&gt;LeftMostChild() == subroot)        <span class="comment">// subroot为最左子结点的情况</span></span><br><span class="line">        pointer-&gt;setChild(subroot-&gt;RightSibling());</span><br><span class="line">    <span class="keyword">else</span> &#123;                                    <span class="comment">// subroot有左兄弟</span></span><br><span class="line">        pointer = pointer-&gt;LeftMostChild();        <span class="comment">// 下降到最左兄弟</span></span><br><span class="line">        <span class="keyword">while</span> (pointer-&gt;RightSibling() != subroot)    <span class="comment">// 顺右链找到直接左兄弟</span></span><br><span class="line">            pointer = pointer-&gt;RightSibling();</span><br><span class="line">        pointer-&gt;setSibling(subroot-&gt;RightSibling());</span><br><span class="line">    &#125;</span><br><span class="line">    subroot-&gt;setSibling(<span class="literal">NULL</span>);</span><br><span class="line">    DestroyNodes(subroot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//树的深度、广度周游算法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::RootFirstTraverse(TreeNode &lt;T&gt; *root) &#123;    <span class="comment">//先根深度优先周游树</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != root) &#123;</span><br><span class="line">        Visit(root-&gt;Value());                      <span class="comment">//访问当前结点</span></span><br><span class="line">        RootFirstTraverse(root-&gt;LeftMostChild());   <span class="comment">//周游头一棵树树根的子树</span></span><br><span class="line">        root = root-&gt;RightSibling();                  <span class="comment">//周游其他的树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::RootLastTraverse(TreeNode &lt;T&gt; *root) &#123;    <span class="comment">//后根深度优先周游树</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != root) &#123;</span><br><span class="line">        RootLastTraverse(root-&gt;LeftMostChild());  <span class="comment">//周游头一棵树树根的子树</span></span><br><span class="line">        Visit(root-&gt;Value());                    <span class="comment">//访问当前结点</span></span><br><span class="line">        root = root-&gt;RightSibling();                <span class="comment">//周游其他的树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::WidthTraverse(TreeNode &lt;T&gt; *root) &#123;  <span class="comment">// 广度优先周游树</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;                             <span class="comment">// 使用STL队列</span></span><br><span class="line">    <span class="built_in">queue</span> &lt; TreeNode &lt; T &gt; * &gt; aQueue;</span><br><span class="line">    TreeNode &lt;T&gt; *pointer = root;                <span class="comment">// 根作为当前结点</span></span><br><span class="line">    <span class="keyword">while</span> (pointer) &#123;</span><br><span class="line">        aQueue.push(pointer);                  <span class="comment">// 当前结点进入队列</span></span><br><span class="line">        pointer = pointer-&gt;RightSibling();         <span class="comment">// 指向当前结点的右兄弟</span></span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">    <span class="keyword">while</span> (!aQueue.empty()) &#123;</span><br><span class="line">        pointer = aQueue.front();                <span class="comment">// 取队列首结点指针</span></span><br><span class="line">        aQueue.pop();                         <span class="comment">// 出队列</span></span><br><span class="line">        Visit(pointer-&gt;Value());                 <span class="comment">// 访问当前结点</span></span><br><span class="line">        pointer = pointer-&gt;LeftMostChild();       <span class="comment">// 指向当前结点的最左孩子</span></span><br><span class="line">        <span class="keyword">while</span> (pointer) &#123;                       <span class="comment">// 当前结点的子结点进队列</span></span><br><span class="line">            aQueue.push(pointer);</span><br><span class="line">            pointer = pointer-&gt;RightSibling();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类ParTreeNode描述了树的结点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParTreeNode</span> &#123;</span>                        <span class="comment">//树结点定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;                    <span class="comment">//结点的值</span></span><br><span class="line">    ParTreeNode&lt;T&gt; *parent;                    <span class="comment">//父结点指针</span></span><br><span class="line">    <span class="keyword">int</span> nCount;                            <span class="comment">//以此结点为根的子树的总结点个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ParTreeNode();                            <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ParTreeNode() &#123;&#125;;                <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span></span>;                            <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span></span>;            <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function">ParTreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">()</span></span>;            <span class="comment">//返回父结点指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(ParTreeNode&lt;T&gt; *par)</span></span>;    <span class="comment">//设置父结点指针</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;                        <span class="comment">//返回结点数目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> count)</span></span>;        <span class="comment">//设置结点数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ParTreeNode抽象数据类型成员函数的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode&lt;T&gt;::ParTreeNode() &#123;            <span class="comment">//构造函数</span></span><br><span class="line">    parent = <span class="literal">NULL</span>;</span><br><span class="line">    nCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T ParTreeNode&lt;T&gt;::getValue() &#123;                <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setValue(<span class="keyword">const</span> T &amp;val) &#123;            <span class="comment">//设置结点的值</span></span><br><span class="line">    value = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode&lt;T&gt; *ParTreeNode&lt;T&gt;::getParent() &#123;            <span class="comment">//返回父结点指针</span></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setParent(ParTreeNode&lt;T&gt; *par) &#123;   <span class="comment">//设置父结点指针</span></span><br><span class="line">    parent = par;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> ParTreeNode&lt;T&gt;::getCount() &#123;                        <span class="comment">//返回结点数目</span></span><br><span class="line">    <span class="keyword">return</span> nCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setCount(<span class="keyword">const</span> <span class="keyword">int</span> count) &#123;        <span class="comment">//设置结点数目</span></span><br><span class="line">    nCount = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类ParTree描述了树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParTree</span> &#123;</span>                                <span class="comment">//树定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ParTreeNode &lt;T&gt; *<span class="built_in">array</span>;                        <span class="comment">//存储树结点的数组</span></span><br><span class="line">    <span class="keyword">int</span> Size;                                    <span class="comment">//数组大小</span></span><br><span class="line">    ParTree(<span class="keyword">const</span> <span class="keyword">int</span> size);                    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ParTree();                            <span class="comment">//析构函数</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *Find(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span>;<span class="comment">//查找node结点的根结点</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *FindPC(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span>; <span class="comment">// 带压缩</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                    <span class="comment">//把下标为i，j的结点合并成一棵子树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnionPC</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                 <span class="comment">//带压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Different</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                <span class="comment">//判定下标为i，j的结点是否在一棵树中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的成员函数的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTree&lt;T&gt;::ParTree(<span class="keyword">const</span> <span class="keyword">int</span> size) &#123;            <span class="comment">//构造函数</span></span><br><span class="line">    Size = size;</span><br><span class="line">    <span class="built_in">array</span> = <span class="keyword">new</span> ParTreeNode&lt;T&gt;[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTree&lt;T&gt;::~ParTree() &#123;                        <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：找到目标结点的根结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode &lt;T&gt; *ParTree&lt;T&gt;::Find(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span> &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointer = node;</span><br><span class="line">    <span class="keyword">while</span> (pointer-&gt;getParent() != <span class="literal">NULL</span>)</span><br><span class="line">        pointer = pointer-&gt;getParent();</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：带路径压缩的Find算法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode &lt;T&gt; *ParTree&lt;T&gt;::FindPC(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;getParent() == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    node-&gt;setParent(FindPC(node-&gt;getParent()));</span><br><span class="line">    <span class="keyword">return</span> node-&gt;getParent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：判定下标为i，j的结点是否在一棵树中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> ParTree&lt;T&gt;::Different(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = Find(&amp;<span class="built_in">array</span>[i]);        <span class="comment">//找到结点i的根</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = Find(&amp;<span class="built_in">array</span>[j]);        <span class="comment">//找到结点j的根</span></span><br><span class="line">    <span class="keyword">return</span> pointeri != pointerj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把下标为i，j的结点合并成一棵子树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTree&lt;T&gt;::Union(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = Find(&amp;<span class="built_in">array</span>[i]);        <span class="comment">//找到结点i的根</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = Find(&amp;<span class="built_in">array</span>[j]);        <span class="comment">//找到结点j的根</span></span><br><span class="line">    <span class="keyword">if</span> (pointeri != pointerj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointeri-&gt;getCount() &gt;= pointerj-&gt;getCount()) &#123;</span><br><span class="line">            pointerj-&gt;setParent(pointeri);</span><br><span class="line">            pointeri-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pointeri-&gt;setParent(pointerj);</span><br><span class="line">            pointerj-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：归并两个集合， 带压缩</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTree&lt;T&gt;::UnionPC(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = FindPC(&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = FindPC(&amp;<span class="built_in">array</span>[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointeri != pointerj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointeri-&gt;getCount() &gt;= pointerj-&gt;getCount()) &#123;</span><br><span class="line">            pointerj-&gt;setParent(pointeri);</span><br><span class="line">            pointeri-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pointeri-&gt;setParent(pointerj);</span><br><span class="line">            pointerj-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;TreeNode.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10                             <span class="comment">//结点数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>           <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带“双标记”的先根次序 结点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualTagTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T info;                   <span class="comment">//树结点信息</span></span><br><span class="line">    <span class="keyword">int</span> ltag;                   <span class="comment">//左标记</span></span><br><span class="line">    <span class="keyword">int</span> rtag;                 <span class="comment">//右标记</span></span><br><span class="line"></span><br><span class="line">    DualTagTreeNode() &#123;&#125;;               <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~DualTagTreeNode() &#123;&#125;;      <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结点类的ADT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line">        m_Value = value;</span><br><span class="line">        pChild = <span class="literal">NULL</span>;</span><br><span class="line">        pSibling = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Value; &#125;;                     <span class="comment">// 获得结点的信息</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pChild; &#125;;   <span class="comment">// 返回第一个左子树</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pSibling; &#125;;  <span class="comment">// 返回第一个右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;value)</span> </span>&#123; m_Value = value; &#125;;      <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pChild = pointer; &#125;;   <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pSibling = pointer; &#125;;  <span class="comment">//设置右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树类ADT，只写出了相关的变量及函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode&lt;T&gt; *root;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">(TreeNode&lt;T&gt; *root, TreeNode&lt;T&gt; *current)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree() &#123; root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    Tree(DualTagTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count); <span class="comment">//带双标记先根次序构造算法</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;          <span class="comment">//返回树中的根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; Value; &#125;;           <span class="comment">//访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RootFirstTraverse</span><span class="params">(TreeNode&lt;T&gt; *root)</span></span>;      <span class="comment">//先根次序周游，作为测试使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：带双标记先根次序构造算法 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Tree&lt;T&gt;::Tree(DualTagTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count) &#123;</span><br><span class="line"><span class="comment">//利用带双标记位的先根次序表示的树构造左孩子右兄弟方式表示的树</span></span><br><span class="line">    <span class="comment">//使用STL中的stack</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> &lt; TreeNode&lt;T&gt; * &gt; aStack;</span><br><span class="line">    <span class="comment">//准备建立根结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">    root = pointer;</span><br><span class="line">    <span class="comment">//处理一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pointer-&gt;setValue(nodeArray[i].info);</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].rtag == <span class="number">0</span>)</span><br><span class="line">            aStack.push(pointer);                        <span class="comment">//将结点压栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pointer-&gt;setSibling(<span class="literal">NULL</span>);                    <span class="comment">//右兄弟设为空</span></span><br><span class="line">        TreeNode&lt;T&gt; *temppointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].ltag == <span class="number">0</span>)</span><br><span class="line">            pointer-&gt;setChild(temppointer);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pointer-&gt;setChild(<span class="literal">NULL</span>);                    <span class="comment">//左孩子设为空</span></span><br><span class="line">            pointer = aStack.top();</span><br><span class="line">            aStack.pop();</span><br><span class="line">            pointer-&gt;setSibling(temppointer);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer = temppointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理最后一个结点</span></span><br><span class="line">    pointer-&gt;setValue(nodeArray[count - <span class="number">1</span>].info);</span><br><span class="line">    pointer-&gt;setChild(<span class="literal">NULL</span>);</span><br><span class="line">    pointer-&gt;setSibling(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：先根深度遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::RootFirstTraverse(TreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Visit(root-&gt;Value());</span><br><span class="line">        RootFirstTraverse(root-&gt;LeftMostChild());</span><br><span class="line">        root = root-&gt;RightSibling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构.图6.5(a)所示的森林</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;      A              G      \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   /  |  \\         /   \\   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  B   C    D      H     I   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;     / \\          |         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    E   F         J         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  0 , there is    a right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  1 , there isn&#x27;t a right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  0 , there is    a left child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  1 , there isn&#x27;t a left child&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构的带双标记先根次序表示 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayNode</span><span class="params">(<span class="keyword">char</span> *Info, <span class="keyword">int</span> *nRtag, <span class="keyword">int</span> *nLtag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;info   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Info[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nRtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nRtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nLtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：周游树，在这里只列举一种（先根次序）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Tree&lt;<span class="keyword">char</span>&gt; *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;FirstRoot traverse:  &quot;</span>;</span><br><span class="line">    tree-&gt;RootFirstTraverse(tree-&gt;getRoot()); <span class="comment">// 先根深度优先周游</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示森林结构</span></span><br><span class="line">    DisplayTree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带双标记先根次序构造算法，图6.5(a)所示的森林的带双标记位的先根次序表示为例</span></span><br><span class="line">    <span class="keyword">char</span> strInfo[N] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;I&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nRtag[N] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nLtag[N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dualtag_FirstRoot create tree.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//打印带双标记位的先根次序表示</span></span><br><span class="line">    DisplayNode(strInfo, nRtag, nLtag);</span><br><span class="line"></span><br><span class="line">    DualTagTreeNode&lt;<span class="keyword">char</span>&gt; *nodeArray = <span class="keyword">new</span> DualTagTreeNode&lt;<span class="keyword">char</span>&gt;[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;                <span class="comment">//设置带双标记位的先根次序结点类</span></span><br><span class="line">        nodeArray[i].info = strInfo[i];</span><br><span class="line">        nodeArray[i].rtag = nRtag[i];</span><br><span class="line">        nodeArray[i].ltag = nLtag[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Tree&lt;<span class="keyword">char</span>&gt; <span class="title">aTree</span><span class="params">(nodeArray, N)</span></span>; <span class="comment">// 建树</span></span><br><span class="line">    Traverse(&amp;aTree);               <span class="comment">// 周游树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10                             <span class="comment">// 结点数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>           <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带“双标记”的次序结点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualTagWidthTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T info;                   <span class="comment">//树结点信息</span></span><br><span class="line">    <span class="keyword">int</span> ltag;                  <span class="comment">//左标记</span></span><br><span class="line">    <span class="keyword">int</span> rtag;                 <span class="comment">//右标记</span></span><br><span class="line"></span><br><span class="line">    DualTagWidthTreeNode() &#123;&#125;;               <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~DualTagWidthTreeNode() &#123;&#125;;      <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结点类的ADT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line">        m_Value = value;</span><br><span class="line">        pChild = <span class="literal">NULL</span>;</span><br><span class="line">        pSibling = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Value; &#125;;                     <span class="comment">// 获得结点的信息</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pChild; &#125;;   <span class="comment">// 返回第一个左子树</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pSibling; &#125;;  <span class="comment">// 返回第一个右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;value)</span> </span>&#123; m_Value = value; &#125;;      <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pChild = pointer; &#125;;   <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pSibling = pointer; &#125;;  <span class="comment">//设置右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树类ADT，只写出了相关的变量及函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode&lt;T&gt; *root;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">(TreeNode&lt;T&gt; *root, TreeNode&lt;T&gt; *current)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree() &#123; root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    Tree(DualTagWidthTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count); <span class="comment">//带双标记先根次序构造算法 </span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;          <span class="comment">//返回树中的根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; Value; &#125;;           <span class="comment">//访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RootFirstTraverse</span><span class="params">(TreeNode&lt;T&gt; *root)</span></span>;      <span class="comment">//先根次序周游，作为测试使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：带双标记层次次序构造算法 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Tree&lt;T&gt;::Tree(DualTagWidthTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="comment">//由带双标记位的层次次序表示构造左孩子右兄弟方式表示的树</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;                                 <span class="comment">//使用STL队列</span></span><br><span class="line">    <span class="built_in">queue</span> &lt; TreeNode&lt;T&gt; * &gt; aQueue;</span><br><span class="line">    <span class="comment">//准备建立根结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">    root = pointer;</span><br><span class="line">    <span class="comment">//处理一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pointer-&gt;setValue(nodeArray[i].info);</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].ltag == <span class="number">0</span>)</span><br><span class="line">            aQueue.push(pointer);                       <span class="comment">//将结点入队</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pointer-&gt;setChild(<span class="literal">NULL</span>);                   <span class="comment">//左孩子设为空</span></span><br><span class="line">        TreeNode&lt;T&gt; *temppointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].rtag == <span class="number">0</span>)</span><br><span class="line">            pointer-&gt;setSibling(temppointer);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pointer-&gt;setSibling(<span class="literal">NULL</span>);                    <span class="comment">//右兄弟设为空</span></span><br><span class="line">            pointer = aQueue.front();                     <span class="comment">//取队列首结点指针</span></span><br><span class="line">            aQueue.pop();                            <span class="comment">//队首元素出队列</span></span><br><span class="line">            pointer-&gt;setChild(temppointer);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer = temppointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理最后一个结点</span></span><br><span class="line">    pointer-&gt;setValue(nodeArray[count - <span class="number">1</span>].info);</span><br><span class="line">    pointer-&gt;setChild(<span class="literal">NULL</span>);</span><br><span class="line">    pointer-&gt;setSibling(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：先根深度遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::RootFirstTraverse(TreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Visit(root-&gt;Value());</span><br><span class="line">        RootFirstTraverse(root-&gt;LeftMostChild());</span><br><span class="line">        root = root-&gt;RightSibling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：周游树，在这里只列举一种（先根次序）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Tree&lt;<span class="keyword">char</span>&gt; *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;FirstRoot traverse:  &quot;</span>;</span><br><span class="line">    tree-&gt;RootFirstTraverse(tree-&gt;getRoot()); <span class="comment">// 先根深度优先周游</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构.图6.5(a)所示的森林</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;      A              G      \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   /  |  \\         /   \\   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  B   C    D      H     I   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;     / \\          |         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    E   F         J         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  0  have right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  1  havn&#x27;t right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  0  have left child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  1  havn&#x27;t left child&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构的带双标记层次次序表示 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayNode</span><span class="params">(<span class="keyword">char</span> *Info, <span class="keyword">int</span> *nRtag, <span class="keyword">int</span> *nLtag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;info   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Info[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nRtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nRtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nLtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示森林结构</span></span><br><span class="line">    DisplayTree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带双标记层次次序构造算法，图6.5(a)所示的森林的带双标记位的层次次序表示为例</span></span><br><span class="line">    <span class="keyword">char</span> strInfo[N] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;J&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nRtag[N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nLtag[N] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dualtag_Width create tree.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//打印带双标记位的层次次序表示 </span></span><br><span class="line">    DisplayNode(strInfo, nRtag, nLtag);</span><br><span class="line"></span><br><span class="line">    DualTagWidthTreeNode&lt;<span class="keyword">char</span>&gt; *nodeArray = <span class="keyword">new</span> DualTagWidthTreeNode&lt;<span class="keyword">char</span>&gt;[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;                <span class="comment">//设置带双标记位的层次次序结点类 </span></span><br><span class="line">        nodeArray[i].info = strInfo[i];</span><br><span class="line">        nodeArray[i].rtag = nRtag[i];</span><br><span class="line">        nodeArray[i].ltag = nLtag[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Tree&lt;<span class="keyword">char</span>&gt; <span class="title">aTree</span><span class="params">(nodeArray, N)</span></span>; <span class="comment">// 建树</span></span><br><span class="line">    Traverse(&amp;aTree);               <span class="comment">// 周游树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="七-图"><a href="#七-图" class="headerlink" title="七    图"></a>七    图</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//***********   Graph.h   ************//</span></span><br><span class="line"><span class="comment">//图的基类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Edge类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> weight;    <span class="comment">//weight是边的权</span></span><br><span class="line">    <span class="keyword">int</span> from;      <span class="comment">//from是边的始点</span></span><br><span class="line">    <span class="keyword">int</span> to;        <span class="comment">//to是边的终点</span></span><br><span class="line">    Edge() &#123;        <span class="comment">// 构造函数</span></span><br><span class="line">        from = <span class="number">-1</span>;</span><br><span class="line">        to = <span class="number">-1</span>;</span><br><span class="line">        weight = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Edge(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">int</span> w) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">        from = f;</span><br><span class="line">        to = t;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &lt; arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight == arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &gt; arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &lt;= arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &gt;= arg.weight); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> numVertex;             <span class="comment">//图的顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> numEdge;                <span class="comment">//图的边的数目</span></span><br><span class="line">    <span class="keyword">int</span> *Mark;                    <span class="comment">/*Mark指针指向保存有图的顶点的标志位的数组,标志位用来标记某顶点是否被访问过*/</span></span><br><span class="line">    <span class="keyword">int</span> *Indegree;                <span class="comment">//Indegree指针指向保存有图的顶点的入度的数组</span></span><br><span class="line">    Graph(<span class="keyword">int</span> numVert) &#123;        <span class="comment">//构造函数</span></span><br><span class="line">        numVertex = numVert;      <span class="comment">//确定图的顶点的个数</span></span><br><span class="line">        numEdge = <span class="number">0</span>;                <span class="comment">//确定图的边的数目</span></span><br><span class="line">        Indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex]; <span class="comment">/*为保存图的顶点的入度申请数组,Indegree为数组指针*/</span></span><br><span class="line">        Mark = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex];     <span class="comment">/*为图的顶点的标志位申请数组,Mark为数组指针*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;    <span class="comment">/*确定图的顶点的标志位和入度,即所有顶点的标志位初始化为未被访问过,入度初始化为0*/</span></span><br><span class="line">            Mark[i] = UNVISITED;</span><br><span class="line">            Indegree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graph() &#123;                <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] Mark;</span><br><span class="line">        <span class="keyword">delete</span>[] Indegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;    <span class="comment">// 返回与顶点oneVertex相关联的第一条边</span></span><br><span class="line">        Edge myEdge;</span><br><span class="line">        myEdge.from = oneVertex;</span><br><span class="line">        myEdge.to = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> myEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123;      <span class="comment">// 返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        <span class="keyword">return</span> preEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">VerticesNum</span><span class="params">()</span> </span>&#123;        <span class="comment">//返回图的顶点个数</span></span><br><span class="line">        <span class="keyword">return</span> numVertex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">EdgesNum</span><span class="params">()</span> </span>&#123;            <span class="comment">//返回图的边数</span></span><br><span class="line">        <span class="keyword">return</span> numEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FromVertex</span><span class="params">(Edge oneEdge)</span> </span>&#123;  <span class="comment">// 返回oneEdge的始点</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ToVertex</span><span class="params">(Edge oneEdge)</span> </span>&#123;    <span class="comment">// 返回oneEdge的终点</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Weight</span><span class="params">(Edge oneEdge)</span> </span>&#123;        <span class="comment">// 返回oneEdge的权值</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEdge</span><span class="params">(Edge oneEdge)</span> </span>&#123;    <span class="comment">//如果oneEdge是边则返回TRUE，否则返回FALSE</span></span><br><span class="line">        <span class="keyword">if</span> (oneEdge.weight &gt; <span class="number">0</span> &amp;&amp; oneEdge.weight &lt; INFINITE &amp;&amp; oneEdge.to &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************** Link.h **************//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listUnit</span> &#123;</span>    <span class="comment">//邻接表表目中数据部分的结构定义</span></span><br><span class="line">    <span class="keyword">int</span> vertex;      <span class="comment">//边的终点</span></span><br><span class="line">    <span class="keyword">int</span> weight;      <span class="comment">//边的权</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span>   <span class="comment">//链表元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Elem element;      <span class="comment">//表目的数据</span></span><br><span class="line">    Link *next;        <span class="comment">//表目指针，指向下一个表目</span></span><br><span class="line">    Link(<span class="keyword">const</span> Elem &amp;elemval, Link *nextval = <span class="literal">NULL</span>) &#123; <span class="comment">//构造函数</span></span><br><span class="line">        element = elemval;</span><br><span class="line">        next = nextval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Link(Link *nextval = <span class="literal">NULL</span>) &#123;                    <span class="comment">//构造函数</span></span><br><span class="line">        next = nextval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span>   <span class="comment">//链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Link&lt;Elem&gt; *head;  <span class="comment">//head指针并不储存任何实际元素，其存在只是为了操作方便</span></span><br><span class="line">    LList() &#123;          <span class="comment">//构造函数</span></span><br><span class="line">        head = <span class="keyword">new</span> Link&lt;Elem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeall</span><span class="params">()</span> </span>&#123;  <span class="comment">//释放边表所有表目占据的空间</span></span><br><span class="line">        Link&lt;Elem&gt; *fence;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123; <span class="comment">//逐步释放每个表目占据的空间</span></span><br><span class="line">            fence = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> fence;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~LList() &#123;                <span class="comment">//析构函数</span></span><br><span class="line">        removeall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphl</span> :</span> <span class="keyword">public</span> Graph &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LList&lt;listUnit&gt; *graList;  <span class="comment">//graList是保存所有边表的数组	</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graphl(<span class="keyword">int</span> numVert) : Graph(numVert) &#123; <span class="comment">//构造函数</span></span><br><span class="line">        graList = <span class="keyword">new</span> LList&lt;listUnit&gt;[numVertex]; <span class="comment">/*为graList数组申请空间，图有</span></span><br><span class="line"><span class="comment">										  numVertex个顶点，则有numVertex个边表*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graphl() &#123;                        <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] graList;                   <span class="comment">//释放空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;   <span class="comment">//返回顶点oneVertex的第一条边</span></span><br><span class="line">        Edge myEdge;                   <span class="comment">//边myEdge将作为函数的返回值</span></span><br><span class="line">        myEdge.from = oneVertex;       <span class="comment">//将顶点oneVertex作为边myEdge的始点</span></span><br><span class="line">        <span class="comment">/*graList[oneVertex].head保存的是顶点oneVertex的边表，</span></span><br><span class="line"><span class="comment">        temp-&gt;next指向顶点oneVertex的第一条边(如果temp-&gt;next</span></span><br><span class="line"><span class="comment">        不为null)*/</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[oneVertex].head;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;        <span class="comment">//如果顶点oneVertex的第一条边确实存在</span></span><br><span class="line">            myEdge.to = temp-&gt;next-&gt;element.vertex;</span><br><span class="line">            myEdge.weight = temp-&gt;next-&gt;element.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果找到了顶点oneVertex的第一条边,则返回的myEdge确实是一条边;如果没有</span></span><br><span class="line"><span class="comment">        找到顶点oneVertex的第一条边,则myEdge的成员变量to为-1,根据IsEdge函数判</span></span><br><span class="line"><span class="comment">        断可知myEdge不是一条边*/</span></span><br><span class="line">        <span class="keyword">return</span> myEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123;  <span class="comment">// 返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        Edge myEdge;                    <span class="comment">// myEdge的初始成员变量to为-1</span></span><br><span class="line">        myEdge.from = preEdge.from;        <span class="comment">// 将边的始点置为与上一条边的相同</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[preEdge.from].head;        <span class="comment">// temp指向边表头一个</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt;= preEdge.to)</span><br><span class="line">            temp = temp-&gt;next;            <span class="comment">// 确定边preEdge的位置</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;        <span class="comment">// 边preEdge的下一条边存在</span></span><br><span class="line">            myEdge.to = temp-&gt;next-&gt;element.vertex;</span><br><span class="line">            myEdge.weight = temp-&gt;next-&gt;element.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge;                    <span class="comment">// 如果没有找到第一条边，myEdge.to=-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;  <span class="comment">//为图设定一条边</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[from].head;  <span class="comment">/*graList[from].head保存的是顶点from的</span></span><br><span class="line"><span class="comment">													边表，temp-&gt;next指向顶点from的第一条边</span></span><br><span class="line"><span class="comment">													(如果temp-&gt;next不为null)*/</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt; to)</span><br><span class="line">            temp = temp-&gt;next;   <span class="comment">/*确定边(from,to)或&lt;from,to&gt;在边表中的位置,如果不存在,</span></span><br><span class="line"><span class="comment">									则边(from,to)或&lt;from,to&gt;为新加的一条边*/</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;  <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中不存在且在边表中其后</span></span><br><span class="line"><span class="comment">									已无其它边,则在边表中加入这条边*/</span></span><br><span class="line">            temp-&gt;next = <span class="keyword">new</span> Link&lt;listUnit&gt;;</span><br><span class="line">            temp-&gt;next-&gt;element.vertex = to;</span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex == to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中已存在,</span></span><br><span class="line"><span class="comment">												故只需要改变边的权值*/</span></span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex &gt; to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中不存在,但在边表中</span></span><br><span class="line"><span class="comment">												其后存在其它边,则在边表中插入这条边*/</span></span><br><span class="line">            Link&lt;listUnit&gt; *other = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = <span class="keyword">new</span> Link&lt;listUnit&gt;;</span><br><span class="line">            temp-&gt;next-&gt;element.vertex = to;</span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            temp-&gt;next-&gt;next = other;</span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;          <span class="comment">//删掉图的一条边</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[from].head;  <span class="comment">/*graList[from].head保存的是顶点from的边表，temp-&gt;next指向顶点from的第一条边(如果temp-&gt;next不为null)*/</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt; to)</span><br><span class="line">            temp = temp-&gt;next;    <span class="comment">/*确定边(from,to)或&lt;from,to&gt;在边表中的位置(如果该边存在)*/</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;        <span class="comment">//边(from,to)或&lt;from,to&gt;在边表中不存在,则不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex &gt; to)</span><br><span class="line">            <span class="keyword">return</span>;        <span class="comment">//边(from,to)或&lt;from,to&gt;在边表中不存在,则不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex == to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中存在且确</span></span><br><span class="line"><span class="comment">											   定了该边在边表中的位置,则从边表中将其删掉*/</span></span><br><span class="line">            Link&lt;listUnit&gt; *other = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp-&gt;next;</span><br><span class="line">            temp-&gt;next = other;</span><br><span class="line">            numEdge--;</span><br><span class="line">            Indegree[to]--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IniGraphl</span><span class="params">(Graphl *Graphl, <span class="keyword">int</span> A[N][N])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::IniGraphl</span><span class="params">(Graphl *Graphl, <span class="keyword">int</span> A[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                Graphl-&gt;setEdge(i, j, A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：深度优先搜索算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;    <span class="comment">//深度优先搜索算法实现</span></span><br><span class="line">    G.Mark[v] = VISITED;       <span class="comment">//访问顶点v，并标记其标志位</span></span><br><span class="line">    Visit(G, v);</span><br><span class="line">    <span class="comment">//访问V邻接到的未被访问过的顶点，并递归地按照深度优先的方式进行周游</span></span><br><span class="line">    <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED)</span><br><span class="line">            DFS(G, G.ToVertex(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;           <span class="comment">// 广度优先搜索算法的实现</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;                    <span class="comment">// 初始化广度优先周游要用到的队列</span></span><br><span class="line">    Visit(G, v);                       <span class="comment">// 问顶点v，并标记其标志位</span></span><br><span class="line">    G.Mark[v] = VISITED;</span><br><span class="line">    Q.push(v);                       <span class="comment">// v入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">// 如果队列仍然有元素</span></span><br><span class="line">        <span class="keyword">int</span> u = Q.front();              <span class="comment">// 队列顶部元素</span></span><br><span class="line">        Q.pop();                     <span class="comment">// 队列顶部元素出队</span></span><br><span class="line">        <span class="comment">// 该顶点邻接到的每一个未访问顶点都入队</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(u); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED) &#123;</span><br><span class="line">                Visit(G, G.ToVertex(e));</span><br><span class="line">                G.Mark[G.ToVertex(e)] = VISITED;</span><br><span class="line">                Q.push(G.ToVertex(e));  <span class="comment">// 入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示顶点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;V&#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的相邻矩阵表示法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphm</span> :</span> <span class="keyword">public</span> Graph &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> **matrix;                <span class="comment">//指向相邻矩阵的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IniGraphm</span><span class="params">(Graphm *Graphm, <span class="keyword">int</span> A[N][N])</span></span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;            <span class="comment">// 深度优先搜索  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;            <span class="comment">// 广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;        <span class="comment">// 访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graphm(<span class="keyword">int</span> numVert) : Graph(numVert) &#123;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">int</span> i, j;            <span class="comment">//i, j作为for循环中的计数器</span></span><br><span class="line">        matrix = (<span class="keyword">int</span> **) <span class="keyword">new</span> <span class="keyword">int</span> *[numVertex]; <span class="comment">/*申请matrix数组,该数组有numVertex个元素,每个元素是整型指针类型*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numVertex; i++)        <span class="comment">/*matrix数组的每个元素,都指向一个具有numVertex个元素的数组*/</span></span><br><span class="line">            matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">             i &lt; numVertex; i++)       <span class="comment">/*相邻矩阵的所有元素都初始化为0,如果矩阵元素matrix[i][j]不为0,则表明顶点i与顶点j之间有一条边,边的权即为matrix[i][j]的值*/</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numVertex; j++)</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graphm() &#123;                            <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++)</span><br><span class="line">            <span class="keyword">delete</span>[] matrix[i];            <span class="comment">//释放每个matrix[i]申请的空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] matrix;                <span class="comment">//释放matrix指针指向的空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;    <span class="comment">//返回顶点oneVertex的第一条边</span></span><br><span class="line">        Edge myEdge;                        <span class="comment">//边myEdge将作为函数的返回值</span></span><br><span class="line">        myEdge.from = oneVertex;            <span class="comment">//将顶点oneVertex作为边myEdge的始点</span></span><br><span class="line">        <span class="comment">//  myEdge.to = -1; </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;<span class="comment">/* 下面寻找第一个使得matrix[oneVertex][i]</span></span><br><span class="line"><span class="comment">												不为0的i值，那么边(oneVertex,i)或者</span></span><br><span class="line"><span class="comment">												弧&lt;oneVertex,i&gt;即为顶点oneVertex</span></span><br><span class="line"><span class="comment">												的第一条边，将顶点i作为边myEdge的终点边myEdge</span></span><br><span class="line"><span class="comment">			                                    的权为矩阵元素matrix[oneVertex][i]的值*/</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[oneVertex][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                myEdge.to = i;</span><br><span class="line">                myEdge.weight = matrix[oneVertex][i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge;<span class="comment">/*如果找到了顶点oneVertex的第一条边,则返回的myEdge确实是一条边；</span></span><br><span class="line"><span class="comment">		              如果没有找到顶点oneVertex的第一条边,则myEdge的成员变量to为-1，</span></span><br><span class="line"><span class="comment">		              根据IsEdge函数判断可知myEdge不是一条边*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123; <span class="comment">//返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        Edge myEdge;</span><br><span class="line">        myEdge.from = preEdge.from; <span class="comment">/*将边myEdge的始点置为与上一条边preEdge的始点相同*/</span></span><br><span class="line">        <span class="keyword">if</span> (preEdge.to &lt; numVertex) &#123;</span><br><span class="line">            <span class="comment">//如果preEdge.to+1&gt;=numVertex,那么就不存在下一条边了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = preEdge.to + <span class="number">1</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">                <span class="comment">/*寻找下一个使得//matrix[preEdge.from][i]不为0的i值,那么</span></span><br><span class="line"><span class="comment">                (preEdge.from,i)或者&lt;preEdge.from,i&gt;即为顶点preEdge.from的下一条边*/</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[preEdge.from][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    myEdge.to = i;</span><br><span class="line">                    myEdge.weight = matrix[preEdge.from][i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge; <span class="comment">/*如果找到了顶点preEdge.from的下一条边，则返回的myEdge确实是一条边；</span></span><br><span class="line"><span class="comment">					   如果没有找到顶点preEdge.from的下一条边，则myEdge的成员变量to为-1，</span></span><br><span class="line"><span class="comment">						根据IsEdge函数判断可知myEdge不是一条边*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;    <span class="comment">//为图设定一条边</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[from][to] &lt;= <span class="number">0</span>) &#123;  <span class="comment">/*如果matrix[from][to]&lt;=0，则边(from,to) 或者&lt;from,to&gt;</span></span><br><span class="line"><span class="comment">			                       将是新增的一条边，否则该边已经存在（现在只是对该边进行修改）*/</span></span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[from][to] = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;     <span class="comment">//删除图的一条边</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[from][to] &gt; <span class="number">0</span>) &#123; <span class="comment">/*如果matrix[from][to]&gt;0，则边(from,to)或者&lt;from,to&gt;确实存在，</span></span><br><span class="line"><span class="comment">			                      否则该边实际上并不存在（从而不必对图的边数和顶点to的入度进行修改）*/</span></span><br><span class="line">            numEdge--;</span><br><span class="line">            Indegree[to]--;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[from][to] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::IniGraphm</span><span class="params">(Graphm *Graphm, <span class="keyword">int</span> A[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                Graphm-&gt;setEdge(i, j, A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：深度优先搜索算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;    <span class="comment">//深度优先搜索算法实现</span></span><br><span class="line">    G.Mark[v] = VISITED;       <span class="comment">//访问顶点v，并标记其标志位</span></span><br><span class="line">    Visit(G, v);</span><br><span class="line">    <span class="comment">//访问V邻接到的未被访问过的顶点，并递归地按照深度优先的方式进行周游</span></span><br><span class="line">    <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED)</span><br><span class="line">            DFS(G, G.ToVertex(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">// 广度优先搜索算法的实现</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;                    <span class="comment">// 初始化广度优先周游要用到的队列</span></span><br><span class="line">    Visit(G, v);                       <span class="comment">// 问顶点v，并标记其标志位</span></span><br><span class="line">    G.Mark[v] = VISITED;</span><br><span class="line">    Q.push(v);                       <span class="comment">// v入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">// 如果队列仍然有元素</span></span><br><span class="line">        <span class="keyword">int</span> u = Q.front();              <span class="comment">// 队列顶部元素</span></span><br><span class="line">        Q.pop();                     <span class="comment">// 队列顶部元素出队</span></span><br><span class="line">        <span class="comment">// 该顶点邻接到的每一个未访问顶点都入队</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(u); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED) &#123;</span><br><span class="line">                Visit(G, G.ToVertex(e));</span><br><span class="line">                G.Mark[G.ToVertex(e)] = VISITED;</span><br><span class="line">                Q.push(G.ToVertex(e));  <span class="comment">// 入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示顶点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;V&#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图的相邻矩阵表示存储图，实现图的拓扑排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示排序后的序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************************************************</span></span><br><span class="line"><span class="comment">//[算法7.7] 队列实现的图拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopsortbyQueue</span><span class="params">(Graph &amp;G)</span> </span>&#123;      <span class="comment">//队列方式实现的拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)    <span class="comment">//初始化Mark数组</span></span><br><span class="line">        G.Mark[i] = UNVISITED;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Q.push(i);                <span class="comment">//图中入度为0的顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">//如果队列中还有图的顶点</span></span><br><span class="line">        <span class="keyword">int</span> V = Q.front();</span><br><span class="line">        Q.pop();                     <span class="comment">//一个顶点出队</span></span><br><span class="line">        Visit(G, V);</span><br><span class="line">        G.Mark[V] = VISITED;</span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(V); G.IsEdge(e); e = G.NextEdge(e)) &#123;</span><br><span class="line">            G.Indegree[G.ToVertex(e)]--;  <span class="comment">//所有与之相邻的顶点入度-1</span></span><br><span class="line">            <span class="keyword">if</span> (G.Indegree[G.ToVertex(e)] == <span class="number">0</span>)</span><br><span class="line">                Q.push(G.ToVertex(e));   <span class="comment">//入度为0的顶点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[i] == UNVISITED) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 此图有环！&quot;</span>;        <span class="comment">//图有环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//C0  C1  C2  C3  C4  C5  C6  C7  C8	</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;  <span class="comment">//该图为图7.18表示课程优先关系的有向无环图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>;              <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Top sort by Queue is : &quot;</span>;</span><br><span class="line">    TopsortbyQueue(aGraphm);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOK! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图的相邻矩阵表示方法,还要用到最小值堆</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 9999    <span class="comment">//设置最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph_matrix.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[代码7.8] Dijkstra算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span>  &#123;</span>      <span class="comment">//定义Dist类，下面的Dijkstra算法和Floyd算法要用到</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	 <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">	 <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">	 <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">	 Dist() &#123;&#125;;</span><br><span class="line">	 ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Dist &amp; arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length==arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&gt;arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&lt;=arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&gt;=arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra算法，其中参数G是图，参数s是源顶点，D是保存最短距离及其路径的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; G, <span class="keyword">int</span> s, Dist* &amp;D)</span>  </span>&#123;</span><br><span class="line">	D = <span class="keyword">new</span> Dist[G. VerticesNum()];          	<span class="comment">// D数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;   	<span class="comment">// 初始化Mark数组、D数组</span></span><br><span class="line">		G.Mark[i] = UNVISITED;</span><br><span class="line">        D[i].index = i;</span><br><span class="line">        D[i].length = INFINITE;</span><br><span class="line">        D[i].pre = s;</span><br><span class="line">    &#125;</span><br><span class="line">    D[s].length = <span class="number">0</span>; </span><br><span class="line">    <span class="function">MinHeap&lt;Dist&gt; <span class="title">H</span><span class="params">(G. EdgesNum())</span></span>;       	<span class="comment">// 最小值堆（minheap）</span></span><br><span class="line">    H.Insert(D[s]);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> FOUND = <span class="literal">false</span>;</span><br><span class="line">        Dist d;</span><br><span class="line">        <span class="keyword">while</span> (!H.isEmpty())  &#123;</span><br><span class="line">			d = H.RemoveMin(); </span><br><span class="line">			<span class="keyword">if</span>(G.Mark[d.index]==UNVISITED) &#123;                <span class="comment">//打印出路径信息</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;vertex index: &quot;</span> &lt;&lt;d.index&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;vertex pre  : &quot;</span> &lt;&lt;d.pre  &lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;V0 --&gt; V&quot;</span> &lt;&lt; d.index &lt;&lt;<span class="string">&quot;  length    : &quot;</span> &lt;&lt;d.length&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (G.Mark[d.index] == UNVISITED) &#123; <span class="comment">//找到距离s最近的顶点</span></span><br><span class="line">				FOUND = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span> (!FOUND)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> v = d.index;</span><br><span class="line">		G.Mark[v] = VISITED;           		<span class="comment">// 把该点加入已访问组</span></span><br><span class="line">		<span class="comment">// 因为v的加入，需要刷新v邻接点的D值</span></span><br><span class="line">		<span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e);e = G.NextEdge(e))</span><br><span class="line">			<span class="keyword">if</span> (D[G.ToVertex(e)].length &gt; (D[v].length+G.Weight(e))) &#123;</span><br><span class="line">				D[G.ToVertex(e)].length = D[v].length+G.Weight(e);</span><br><span class="line">				D[G.ToVertex(e)].pre = v;</span><br><span class="line">				H.Insert(D[G.ToVertex(e)]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] =  &#123;          <span class="comment">//图7.20  单源最短路径的示例</span></span><br><span class="line"><span class="comment">//  v0  v1  v2  v3  v4  </span></span><br><span class="line">	 <span class="number">0</span>, <span class="number">10</span>,  <span class="number">0</span>, <span class="number">30</span>, <span class="number">100</span>,</span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>, <span class="number">50</span>,  <span class="number">0</span>,  <span class="number">0</span>, </span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, <span class="number">10</span>, </span><br><span class="line">     <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>,  <span class="number">0</span>, <span class="number">60</span>, </span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line"> aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"> Dist *D;</span><br><span class="line"> Dijkstra(aGraphm, <span class="number">0</span>, D);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图用相邻矩阵表示方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"><span class="comment">//这里要注意 图类中的边为无穷大的时候也应该看成是一条边</span></span><br><span class="line"><span class="comment">//所以要修改一下IsEdge函数的定义</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span> &#123;</span>      <span class="comment">//定义Dist类，下面的Dijkstra算法和Floyd算法要用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">    <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">    Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[算法7.9] Floyd算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(Graph &amp;G, Dist **&amp;D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, v;                               <span class="comment">// i,j,v是计数器</span></span><br><span class="line">    D = <span class="keyword">new</span> Dist *[G.VerticesNum()];          <span class="comment">// 为数组D申请空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        D[i] = <span class="keyword">new</span> Dist[G.VerticesNum()];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)          <span class="comment">// 初始化数组D</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.VerticesNum(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                D[i][j].length = <span class="number">0</span>;</span><br><span class="line">                D[i][j].pre = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                D[i][j].length = INFINITE;</span><br><span class="line">                D[i][j].pre = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.VerticesNum(); v++)</span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e)) &#123;</span><br><span class="line">            D[v][G.ToVertex(e)].length = G.Weight(e);</span><br><span class="line">            D[v][G.ToVertex(e)].pre = v;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果两个顶点间的最短路径经过顶点v，则更新最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.VerticesNum(); v++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.VerticesNum(); j++)</span><br><span class="line">                <span class="keyword">if</span> (D[i][j].length &gt; (D[i][v].length + D[v][j].length)) &#123;</span><br><span class="line">                    D[i][j].length = D[i][v].length + D[v][j].length;</span><br><span class="line">                    D[i][j].pre = D[v][j].pre;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line"><span class="comment">//	V0    V1    V2</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">3</span>, INFINITE, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Dist **D;</span><br><span class="line">    Floyd(aGraphm, D);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; D[i][j].length &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7         <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span> &#123;</span>      <span class="comment">//定义Dist类，下面的Prim算法要用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">    <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">    Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graphm &amp;G, <span class="keyword">int</span> s, Dist *&amp;D)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minVertex</span><span class="params">(Graph &amp;G, Dist *&amp;D)</span> </span>&#123;            <span class="comment">// 在Dist数组中找最小值</span></span><br><span class="line">    <span class="keyword">int</span> i, v;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[i] == UNVISITED) &#123;</span><br><span class="line">            v = i;                        <span class="comment">// 让v为随意一个未访问的定义</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> ((G.Mark[i] == UNVISITED) &amp;&amp; (D[i] &lt; D[v]))</span><br><span class="line">            v = i;                        <span class="comment">// 保存目前发现的具有最小距离的顶点</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最小支撑树的Prim算法，</span></span><br><span class="line"><span class="comment">//参数G是图，参数s是开始顶点，参数MST是保存最小支撑树中所有边的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdgetoMST</span><span class="params">(Edge e, Edge *&amp;MST, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MST[n] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> s, Edge *&amp;MST)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MSTtag = <span class="number">0</span>;                       <span class="comment">// 最小生成树边的标号</span></span><br><span class="line">    MST = <span class="keyword">new</span> Edge[G.VerticesNum() - <span class="number">1</span>];</span><br><span class="line">    Dist *D;</span><br><span class="line">    D = <span class="keyword">new</span> Dist[G.VerticesNum()];            <span class="comment">// D数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;    <span class="comment">// 初始化Mark数组、D数组</span></span><br><span class="line">        G.Mark[i] = UNVISITED;</span><br><span class="line">        D[i].index = i;</span><br><span class="line">        D[i].length = INFINITE;</span><br><span class="line">        D[i].pre = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    D[s].length = <span class="number">0</span>;</span><br><span class="line">    G.Mark[s] = VISITED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum() - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (D[v] == INFINITY) <span class="keyword">return</span>;        <span class="comment">// 非连通，有不可达顶点，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为v的加入，需要刷新v邻接点的D值</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] != VISITED &amp;&amp; (D[G.ToVertex(e)].length &gt; e.weight)) &#123;</span><br><span class="line">                D[G.ToVertex(e)].length = e.weight;</span><br><span class="line">                D[G.ToVertex(e)].pre = v;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        v = minVertex(G, D);</span><br><span class="line"></span><br><span class="line">        G.Mark[v] = VISITED;</span><br><span class="line">        <span class="function">Edge <span class="title">edge</span><span class="params">(D[v].pre, D[v].index, D[v].length)</span></span>;</span><br><span class="line"></span><br><span class="line">        AddEdgetoMST(edge, MST, MSTtag++);  <span class="comment">// 将边e加到MST中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//   v0  v1  v2  v3  v4  v5  v6     </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">20</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;                                    <span class="comment">//图7.24 带权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Edge *D;</span><br><span class="line">    Prim(aGraphm, <span class="number">0</span>, D);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;V&quot;</span> &lt;&lt; D[i].from &lt;&lt; <span class="string">&quot;-&gt;V&quot;</span> &lt;&lt; D[i].to &lt;&lt; <span class="string">&quot;   Weight is : &quot;</span> &lt;&lt; D[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7         <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ParTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最小支撑树的Kruskal算法，</span></span><br><span class="line"><span class="comment">//参数G是图，参数MST是保存最小支撑树中所有边的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdgetoMST</span><span class="params">(Edge e, Edge *&amp;MST, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MST[n] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Graph &amp;G, Edge *&amp;MST)</span> </span>&#123;</span><br><span class="line">    <span class="function">ParTree&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(G.VerticesNum())</span></span>;           <span class="comment">//等价类</span></span><br><span class="line">    <span class="function">MinHeap&lt;Edge&gt; <span class="title">H</span><span class="params">(G.EdgesNum())</span></span>;        <span class="comment">//最小值堆（minheap）    </span></span><br><span class="line">    MST = <span class="keyword">new</span> Edge[G.VerticesNum() - <span class="number">1</span>];      <span class="comment">//最小支撑树</span></span><br><span class="line">    <span class="keyword">int</span> MSTtag = <span class="number">0</span>;                         <span class="comment">//最小支撑树边的标号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)  <span class="comment">//将图的所有边插入最小值堆H中</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(i); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.FromVertex(e) &lt; G.ToVertex(e))  <span class="comment">//因为是无向图，所以应防止重复插入</span></span><br><span class="line">                H.Insert(e);</span><br><span class="line">    <span class="keyword">int</span> EquNum = G.VerticesNum();              <span class="comment">//开始时有|V|个等价类</span></span><br><span class="line">    <span class="keyword">while</span> (EquNum &gt; <span class="number">1</span>) &#123;                     <span class="comment">//合并等价类</span></span><br><span class="line">        Edge e = H.RemoveMin();               <span class="comment">//获得下一条权最小的边</span></span><br><span class="line">        <span class="keyword">if</span> (e.weight == INFINITE) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不存在最小支撑树.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] MST;                     <span class="comment">//释放空间</span></span><br><span class="line">            MST = <span class="literal">NULL</span>;                   <span class="comment">//MST是空数组</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> from = G.FromVertex(e);            <span class="comment">//记录该条边的信息</span></span><br><span class="line">        <span class="keyword">int</span> to = G.ToVertex(e);</span><br><span class="line">        <span class="keyword">if</span> (A.Different(from, to)) &#123;            <span class="comment">//如果边e的两个顶点不在一个等价类</span></span><br><span class="line">            A.Union(from, to);     <span class="comment">//将边e的两个顶点所在的两个等价类合并为一个</span></span><br><span class="line">            AddEdgetoMST(e, MST, MSTtag++); <span class="comment">//将边e加到MST</span></span><br><span class="line">            EquNum--;                     <span class="comment">//将等价类的个数减1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//   v0  v1  v2  v3  v4  v5  v6     </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">20</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;                                    <span class="comment">//图7.24 带权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Edge *D;</span><br><span class="line">    Kruskal(aGraphm, D);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;V&quot;</span> &lt;&lt; D[i].from &lt;&lt; <span class="string">&quot;-&gt;V&quot;</span> &lt;&lt; D[i].to &lt;&lt; <span class="string">&quot;   Weight is : &quot;</span> &lt;&lt; D[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八-内排序"><a href="#八-内排序" class="headerlink" title="八    内排序"></a>八    内排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接插入排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    Record TempRecord;                        <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;                    <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        TempRecord = Array[i];                    <span class="comment">// 先把记录Array[i]保留在临时记录变量中</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                            <span class="comment">// 内存循环变量从j从i-1开始</span></span><br><span class="line">        <span class="comment">// 往前寻找记录i的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; TempRecord &lt; Array[j]) &#123;</span><br><span class="line">            Array[j + <span class="number">1</span>] = Array[j];                <span class="comment">// 将那些大于等于记录i的记录后移</span></span><br><span class="line">            j = j - <span class="number">1</span>;                        <span class="comment">// 下标j前移</span></span><br><span class="line">        &#125;</span><br><span class="line">        Array[j + <span class="number">1</span>] = TempRecord;                <span class="comment">// 此时j+1就是记录i的正确位置，回填</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    InsertSort(Array, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class Record&gt;</span></span><br><span class="line"><span class="comment">void ModInsSort(Record Array[], int n, int delta) &#123;	</span></span><br><span class="line"><span class="comment">	// 针对变化的增量而修改的插入排序算法，参数delta表示当前的增量</span></span><br><span class="line"><span class="comment">	Record TempRecord;						// 临时变量</span></span><br><span class="line"><span class="comment">	for (int i=delta; i&lt;n; i+=delta) &#123;		// 对子序列中第i个记录排序</span></span><br><span class="line"><span class="comment">		TempRecord=Array[i];</span></span><br><span class="line"><span class="comment">		int j = i-delta;</span></span><br><span class="line"><span class="comment">		//从i开始往前寻找记录i的正确位置</span></span><br><span class="line"><span class="comment">		while (j&gt;=0 &amp;&amp; TempRecord &lt; Array[j]) &#123;</span></span><br><span class="line"><span class="comment">			Array[j+delta] = Array[j];		//将那些大于等于记录i的记录后移</span></span><br><span class="line"><span class="comment">			j = j - delta;</span></span><br><span class="line"><span class="comment">	    &#125;</span></span><br><span class="line"><span class="comment">	    Array[j+delta] = TempRecord; 			//此时j后面就是记录i的正确位置，回填</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;            <span class="comment">// Shell排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> delta = n / <span class="number">2</span>; delta &gt; <span class="number">0</span>; delta /= <span class="number">2</span>)        <span class="comment">// 增量delta每次除以2递减</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++)            <span class="comment">// 分别对delta个子序列进行插入排序</span></span><br><span class="line">            ModInsSort(&amp;Array[i], n - i, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModInsSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> delta)</span> </span>&#123;    <span class="comment">// 修改的插入排序算法，参数delta表示当前的增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = delta; i &lt; n; i += delta)            <span class="comment">// 对子序列中第i个记录，寻找合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= delta; j -= delta) &#123;        <span class="comment">//  j以dealta为步长向前寻找逆置对进行调整</span></span><br><span class="line">            <span class="keyword">if</span> (Array[j] &lt; Array[j - delta])        <span class="comment">//  Array[j] &lt; Array[j-delta]，则二者为逆置对</span></span><br><span class="line">                swap(Array, j, j - delta);        <span class="comment">// 交换Array[j]和Array[j-delta]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ShellSort(Array, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;    <span class="comment">// 直接选择排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;            <span class="comment">// 依次选出第i小的记录，即剩余记录中最小的那个</span></span><br><span class="line">        <span class="keyword">int</span> Smallest = i;                <span class="comment">// 首先假设记录i就是最小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)            <span class="comment">// 开始向后扫描所有剩余记录</span></span><br><span class="line">            <span class="keyword">if</span> (Array[j] &lt; Array[Smallest])</span><br><span class="line">                Smallest = j;            <span class="comment">// 如果发现更小的记录，记录它的位置</span></span><br><span class="line">        swap(Array, i, Smallest);            <span class="comment">// 交换Array[i]和 Array[Smallest]，第i小的记录到位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    SelectSort(Array, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heapArray;                            <span class="comment">//存放堆数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> CurrentSize;                        <span class="comment">//当前堆中元素数目</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                            <span class="comment">//堆所能容纳的最大元素数目</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(T *<span class="built_in">array</span>, <span class="keyword">int</span> num, <span class="keyword">int</span> max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~MaxHeap() &#123;&#125;;                    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//如果是叶结点，返回TRUE</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回左孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rightchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回右孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//返回父结点位置</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> pos, T &amp;node)</span></span>;            <span class="comment">//删除给定下标的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftDown</span><span class="params">(<span class="keyword">int</span> left)</span></span>;                <span class="comment">//筛选法函数，参数left表示开始处理的数组下标</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftUp</span><span class="params">(<span class="keyword">int</span> position)</span></span>;                <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T &amp;newNode)</span></span>;            <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveMax</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶移动最大值到尾部</span></span><br><span class="line">    <span class="function">T &amp;<span class="title">RemoveMax</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶删除最大值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">MaxHeap&lt;T&gt;::MaxHeap(T *<span class="built_in">array</span>, <span class="keyword">int</span> num, <span class="keyword">int</span> max) &#123;</span><br><span class="line">    heapArray = <span class="built_in">array</span>;</span><br><span class="line">    CurrentSize = num;</span><br><span class="line">    MaxSize = max;</span><br><span class="line">    BuildHeap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::BuildHeap() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = CurrentSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        SiftDown(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::isLeaf(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &gt;= CurrentSize / <span class="number">2</span>) &amp;&amp; (pos &lt; CurrentSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::leftchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">1</span>;                        <span class="comment">//返回左孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::rightchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">2</span>;                        <span class="comment">//返回右孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::parent(<span class="keyword">int</span> pos) <span class="keyword">const</span>    <span class="comment">//返回父节点位置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (pos - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::SiftDown(<span class="keyword">int</span> left) &#123;</span><br><span class="line">    <span class="comment">//准备</span></span><br><span class="line">    <span class="keyword">int</span> i = left;                            <span class="comment">//标识父结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>;                        <span class="comment">//标识关键值较小的子结点		</span></span><br><span class="line">    T temp = heapArray[i];                <span class="comment">//保存父结点</span></span><br><span class="line">    <span class="comment">//过筛</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; CurrentSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((j &lt; CurrentSize) &amp;&amp; (heapArray[j] &lt; heapArray[j + <span class="number">1</span>]))</span><br><span class="line">            j++;                        <span class="comment">//j指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; heapArray[j]) &#123;</span><br><span class="line">            heapArray[i] = heapArray[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * j + <span class="number">1</span>;                    <span class="comment">//向下继续</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::SiftUp(<span class="keyword">int</span> position) &#123;<span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="keyword">int</span> temppos = position;</span><br><span class="line">    T temp = heapArray[temppos];</span><br><span class="line">    <span class="keyword">int</span> parentpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (temppos &gt; <span class="number">0</span>)</span><br><span class="line">        parentpos = parent(temppos);</span><br><span class="line">    <span class="keyword">while</span> ((temppos &gt; <span class="number">0</span>) &amp;&amp; (heapArray[parentpos] &lt; temp)) &#123;</span><br><span class="line">        heapArray[temppos] = heapArray[parentpos];</span><br><span class="line">        temppos = parentpos;</span><br><span class="line">        parentpos = parent(temppos);</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[temppos] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::Insert(<span class="keyword">const</span> T &amp;newNode) &#123;<span class="comment">//向堆中插入一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == MaxSize)                <span class="comment">//堆空间已经满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    heapArray[CurrentSize] = newNode;</span><br><span class="line">    SiftUp(CurrentSize);                    <span class="comment">//向上调整</span></span><br><span class="line">    CurrentSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T &amp;MaxHeap&lt;T&gt;::RemoveMax() &#123;</span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//AfxMessageBox(&quot;Can&#x27;t Delete&quot;);</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T temp = heapArray[<span class="number">0</span>];                    <span class="comment">//取堆顶元素</span></span><br><span class="line">        heapArray[<span class="number">0</span>] = heapArray[CurrentSize - <span class="number">1</span>];    <span class="comment">//堆末元素上升至堆顶</span></span><br><span class="line">        CurrentSize--;</span><br><span class="line">        SiftDown(<span class="number">0</span>);                            <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::MoveMax() &#123;</span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//堆为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T temp = heapArray[<span class="number">0</span>];                    <span class="comment">//取堆顶元素</span></span><br><span class="line">        heapArray[<span class="number">0</span>] = heapArray[CurrentSize - <span class="number">1</span>];    <span class="comment">//堆末元素上升至堆顶</span></span><br><span class="line">        CurrentSize--;</span><br><span class="line">        SiftDown(<span class="number">0</span>);                            <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        heapArray[CurrentSize] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::Remove(<span class="keyword">int</span> pos, T &amp;node) &#123;<span class="comment">// 删除给定下标的元素</span></span><br><span class="line">    <span class="keyword">if</span> ((pos &lt; <span class="number">0</span>) || (pos &gt; CurrentSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    heapArray[pos] = heapArray[--CurrentSize];    <span class="comment">//指定元素置于最后</span></span><br><span class="line">    SiftUp(pos);                                <span class="comment">//上升筛</span></span><br><span class="line">    SiftDown(pos);                                <span class="comment">//向下筛	</span></span><br><span class="line">    node = heapArray[CurrentSize];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../sort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MaxHeap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MaxHeap&lt;Record&gt; max_heap = MaxHeap&lt;Record&gt;(Array, n, n);    <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)         <span class="comment">// 依次找出剩余记录中的最大记录，即堆顶</span></span><br><span class="line">        max_heap.MoveMax();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span>  </span>&#123;	<span class="comment">// 优化的冒泡排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">	<span class="keyword">bool</span> NoSwap;			<span class="comment">// 是否发生了交换的标志</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)  &#123;</span><br><span class="line">	NoSwap = <span class="literal">true</span>;		<span class="comment">// 标志初始为真</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=i; j--)</span><br><span class="line">	  <span class="keyword">if</span> (Array[j] &lt; Array[j<span class="number">-1</span>])  &#123;	<span class="comment">// 判断（Array[j-1]，Array[j]）是否逆置</span></span><br><span class="line">		swap(Array, j, j<span class="number">-1</span>);	<span class="comment">// 交换逆置对Array[j]，Array[j-1]</span></span><br><span class="line">		NoSwap = <span class="literal">false</span>;		<span class="comment">// 发生了交换，标志变为假</span></span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">if</span> (NoSwap)  			<span class="comment">// 如果没发生过交换，表示已排好序，结束算法</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record* Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  BubbleSort(Array, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SortMain.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;                <span class="comment">// 选择轴值，参数left,right分别表示序列的左右端下标</span></span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2</span>;                        <span class="comment">// 选择中间记录作为轴值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// Array[]为待排序数组，left,right分别为数组两端</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;                    <span class="comment">// 如果子序列中只有0或1个记录，就不需排序</span></span><br><span class="line">    <span class="keyword">int</span> pivot = ::SelectPivot(left, right);            <span class="comment">// 选择轴值</span></span><br><span class="line">    swap(Array, pivot, right);                <span class="comment">// 分割前先将轴值放到数组末端</span></span><br><span class="line">    pivot = Partition(Array, left, right);            <span class="comment">// 分割后轴值已到达正确位置</span></span><br><span class="line">    QuickSort(Array, left, pivot - <span class="number">1</span>);                <span class="comment">// 对轴值左边的子序列进行递归快速排序</span></span><br><span class="line">    QuickSort(Array, pivot + <span class="number">1</span>, right);            <span class="comment">// 对轴值右边的子序列进行递归快速排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// 分割函数，分割后轴值已到达正确位置</span></span><br><span class="line">    <span class="keyword">int</span> l = left;                                <span class="comment">//  l为左指针，r为右指针</span></span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    Record TempRecord = Array[r];                <span class="comment">// 将轴值存放在临时变量中</span></span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;                            <span class="comment">// 开始分割，l,r不断向中间移动，直到相遇</span></span><br><span class="line">        <span class="comment">// l指针向右移动，直到找到一个大于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[l] &lt;= TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把&quot;&lt;=&quot;改写为&quot;&lt;&quot;，反正不稳定</span></span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到右边的空位</span></span><br><span class="line">            Array[r] = Array[l];</span><br><span class="line">            r--;                            <span class="comment">//  r指针向左移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r指针向左移动，直到找到一个小于等于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[r] &gt; TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把&quot;&gt;&quot;改写为&quot;&gt;=&quot;，减少记录移动</span></span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到左边的空位</span></span><br><span class="line">            Array[l] = Array[r];</span><br><span class="line">            l++;                            <span class="comment">// l指针向右移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">//end while</span></span><br><span class="line">    Array[l] = TempRecord;                    <span class="comment">// 把轴值回填到分界位置l上</span></span><br><span class="line">    <span class="keyword">return</span> l;                                <span class="comment">// 返回分界位置l</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    QuickSort(Array, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接插入排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    Record TempRecord;                        <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;                    <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        TempRecord = Array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从i开始往前寻找记录i的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; TempRecord &lt; Array[j]) &#123;</span><br><span class="line">            Array[j + <span class="number">1</span>] = Array[j];                <span class="comment">// 将那些大于等于记录i的记录后移</span></span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Array[j + <span class="number">1</span>] = TempRecord;                <span class="comment">// 此时j后面就是记录i的正确位置，回填</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;            <span class="comment">// 选择轴值，参数left,right分别表示序列的左右端下标</span></span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2</span>;                    <span class="comment">// 选择中间纪录作为轴值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModQuickSort</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;  <span class="comment">// 优化的快速排序，</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;            <span class="comment">// 如果序列中只有0或1个记录，就不用排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; THRESHOLD) &#123;        <span class="comment">// 对长度大于阈值(28最佳)的长子串处理</span></span><br><span class="line">        <span class="keyword">int</span> pivot = ::SelectPivot(left, right);        <span class="comment">// 选择轴值	</span></span><br><span class="line">        swap(Array, pivot, right);        <span class="comment">// 将轴值放在数组末端</span></span><br><span class="line">        pivot = Partition(Array, left, right);        <span class="comment">// 分割后轴值已到达正确位置</span></span><br><span class="line">        ModQuickSort(Array, left, pivot - <span class="number">1</span>);        <span class="comment">// 对轴值左边的子序列进行递归快速排序</span></span><br><span class="line">        ModQuickSort(Array, pivot + <span class="number">1</span>, right);        <span class="comment">// 对轴值右边的子序列进行递归快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// 分割函数，分割后轴值已到达正确位置</span></span><br><span class="line">    <span class="keyword">int</span> l = left;                                <span class="comment">//  l为左指针，r为右指针</span></span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    Record TempRecord = Array[r];                <span class="comment">// 将轴值存放在临时变量中</span></span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;                            <span class="comment">// 开始分割，l,r不断向中间移动，直到相遇</span></span><br><span class="line">        <span class="comment">// l指针向右移动，直到找到一个大于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[l] &lt;= TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把“&lt;=”改写为“&lt;”，反正不稳定</span></span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到右边的空位</span></span><br><span class="line">            Array[r] = Array[l];</span><br><span class="line">            r--;                            <span class="comment">//  r指针向左移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r指针向左移动，直到找到一个小于等于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[r] &gt; TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把“&gt;”改写为“&gt;=”，减少记录移动</span></span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到左边的空位</span></span><br><span class="line">            Array[l] = Array[r];</span><br><span class="line">            l++;                            <span class="comment">// l指针向右移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">//end while</span></span><br><span class="line">    Array[l] = TempRecord;                    <span class="comment">// 把轴值回填到分界位置l上</span></span><br><span class="line">    <span class="keyword">return</span> l;                                <span class="comment">// 返回分界位置l</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ModQuickSort(Array, <span class="number">0</span>, n - <span class="number">1</span>);            <span class="comment">// 调用优化的递归快排，不处理小子串</span></span><br><span class="line">    InsertSort(Array, n);                <span class="comment">// 最后这个序列进行扫尾插入排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两路归并排序，Array[]为待排序数组，left，right分别为数组两端</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;                            <span class="comment">// 如果序列中只有0或1个记录，就不用排序</span></span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;                    <span class="comment">//从中间划分为两个子序列</span></span><br><span class="line">        MergeSort(Array, TempArray, left, middle);        <span class="comment">//对左边一半进行递归</span></span><br><span class="line">        MergeSort(Array, TempArray, middle + <span class="number">1</span>, right);    <span class="comment">//对右边一半进行递归</span></span><br><span class="line">        Merge(Array, TempArray, left, right, middle);        <span class="comment">// 进行归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> middle)</span> </span>&#123;  <span class="comment">//归并过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; j++)                    <span class="comment">// 将数组暂存入临时数组</span></span><br><span class="line">        TempArray[j] = Array[j];</span><br><span class="line">    <span class="keyword">int</span> index1 = left;                                <span class="comment">// 左边子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> index2 = middle + <span class="number">1</span>;                            <span class="comment">// 右边子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> i = left;                                    <span class="comment">// 从左开始归并</span></span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= middle &amp;&amp; index2 &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//取较小者插入合并数组中</span></span><br><span class="line">        <span class="keyword">if</span> (TempArray[index1] &lt;= TempArray[index2])    <span class="comment">// 为保证稳定性，相等时左边优先</span></span><br><span class="line">            Array[i++] = TempArray[index1++];</span><br><span class="line">        <span class="keyword">else</span> Array[i++] = TempArray[index2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= middle)                        <span class="comment">// 只剩左序列，可以直接复制</span></span><br><span class="line">        Array[i++] = TempArray[index1++];</span><br><span class="line">    <span class="keyword">while</span> (index2 &lt;= right)                        <span class="comment">// 与上个循环互斥，直接复制剩余的右序列</span></span><br><span class="line">        Array[i++] = TempArray[index2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Record *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) temp = <span class="keyword">new</span> Record[n];            <span class="comment">// 申请辅助数组</span></span><br><span class="line">    MergeSort(<span class="built_in">array</span>, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接插入排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    Record TempRecord;                        <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;                    <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        TempRecord = Array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从i开始往前寻找记录i的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; TempRecord &lt; Array[j]) &#123;</span><br><span class="line">            Array[j + <span class="number">1</span>] = Array[j];                <span class="comment">// 将那些大于等于记录i的记录后移</span></span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Array[j + <span class="number">1</span>] = TempRecord;                <span class="comment">// 此时j后面就是记录i的正确位置，回填</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class Record&gt;</span></span><br><span class="line"><span class="comment">void MergeSort(Record Array[], Record TempArray[], int left, int right)  &#123;</span></span><br><span class="line"><span class="comment">	//两路归并排序，Array[]为待排序数组，left，right分别为数组两端</span></span><br><span class="line"><span class="comment">	if (left &lt; right)  &#123;							// 如果序列中只有0或1个记录，就不用排序</span></span><br><span class="line"><span class="comment">		int middle=(left+right)/2;					//从中间划分为两个子序列</span></span><br><span class="line"><span class="comment">		MergeSort(Array,TempArray,left,middle);		//对左边一半进行递归</span></span><br><span class="line"><span class="comment">		MergeSort(Array, TempArray,middle+1,right);	//对右边一半进行递归</span></span><br><span class="line"><span class="comment">		Merge(Array, TempArray,left,right,middle);		// 进行归并</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;class Record&gt;</span></span><br><span class="line"><span class="comment">void Merge(Record Array[], Record TempArray[], int left, int right, int middle)  &#123;  //归并过程</span></span><br><span class="line"><span class="comment">	for (int j=left; j&lt;=right; j++)   					// 将数组暂存入临时数组</span></span><br><span class="line"><span class="comment">		TempArray[j] = Array[j];</span></span><br><span class="line"><span class="comment">	int index1=left;								// 左边子序列的起始位置</span></span><br><span class="line"><span class="comment">	int index2=middle+1;							// 右边子序列的起始位置</span></span><br><span class="line"><span class="comment">	int i=left;									// 从左开始归并</span></span><br><span class="line"><span class="comment">	while (index1 &lt;= middle &amp;&amp; index2 &lt;= right)  &#123;</span></span><br><span class="line"><span class="comment">		//取较小者插入合并数组中</span></span><br><span class="line"><span class="comment">		if (TempArray[index1] &lt;= TempArray[index2])	// 为保证稳定性，相等时左边优先</span></span><br><span class="line"><span class="comment">			Array[i++] = TempArray[index1++];</span></span><br><span class="line"><span class="comment">		else  Array[i++] = TempArray[index2++];</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	while (index1 &lt;= middle)						// 只剩左序列，可以直接复制</span></span><br><span class="line"><span class="comment">		Array[i++] = TempArray[index1++];</span></span><br><span class="line"><span class="comment">	while (index2 &lt;= right) 						// 与上个循环互斥，直接复制剩余的右序列</span></span><br><span class="line"><span class="comment">		Array[i++] = TempArray[index2++];			</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModMergeSort</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	if (right &lt;= left)	return;						// 如果只含有一个元素，直接返回		  </span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; THRESHOLD) &#123;                <span class="comment">//如果序列长度大于阈值(16最佳)，跳出递归</span></span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;                    <span class="comment">// 从中间划分为两个子序列</span></span><br><span class="line">        ModMergeSort(Array, TempArray, left, middle);    <span class="comment">// 对左边一半进行递归</span></span><br><span class="line">        ModMergeSort(Array, TempArray, middle + <span class="number">1</span>, right);    <span class="comment">// 对右边一半进行递归</span></span><br><span class="line">        ModMerge(Array, TempArray, left, right, middle);    <span class="comment">// 进行归并</span></span><br><span class="line">    &#125; <span class="keyword">else</span> InsertSort(&amp;Array[left], right - left + <span class="number">1</span>);            <span class="comment">// 若长度小于等于阈值，采用直接插入排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModMerge</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> middle)</span> </span>&#123;    <span class="comment">//归并过程</span></span><br><span class="line">    <span class="keyword">int</span> index1, index2;                            <span class="comment">// 两个子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt;= middle; i++)                        <span class="comment">// 复制左边的子序列</span></span><br><span class="line">        TempArray[i] = Array[i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= right - middle; j++)                    <span class="comment">// 复制右边的子序列，但顺序颠倒过来</span></span><br><span class="line">        TempArray[right - j + <span class="number">1</span>] = Array[j + middle];</span><br><span class="line">    <span class="comment">// 开始归并，取较小者插入合并数组中</span></span><br><span class="line">    <span class="keyword">for</span> (index1 = left, index2 = right, k = left; k &lt;= right; k++)</span><br><span class="line">        <span class="keyword">if</span> (TempArray[index1] &lt;= TempArray[index2])    <span class="comment">// 为保证稳定性，相等时左边优先</span></span><br><span class="line">            Array[k] = TempArray[index1++];</span><br><span class="line">        <span class="keyword">else</span> Array[k] = TempArray[index2--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Record *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) temp = <span class="keyword">new</span> Record[n];                <span class="comment">// 申请辅助数组</span></span><br><span class="line">    ModMergeSort(<span class="built_in">array</span>, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 桶式排序，Array[]为待排序数组，数组长度为n，所有记录都位于区间[0,max)上</span></span><br><span class="line">    <span class="keyword">int</span> *TempArray = <span class="keyword">new</span> Record[n];        <span class="comment">// 临时数组</span></span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[max];            <span class="comment">// 小于或等于i的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)                    <span class="comment">// 把序列复制到临时数组</span></span><br><span class="line">        TempArray[i] = Array[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++)                <span class="comment">// 所有计数器初始都为0</span></span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)                    <span class="comment">// 统计每个取值出现的次数</span></span><br><span class="line">        count[Array[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; max; i++)                <span class="comment">// 统计小于等于i的元素个数</span></span><br><span class="line">        count[i] = count[i - <span class="number">1</span>] + count[i];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)                <span class="comment">// 从尾部开始按顺序输出有序序列，保证排序的稳定性</span></span><br><span class="line">        Array[--count[TempArray[i]]] = TempArray[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    BucketSort(Array, n, <span class="number">80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对16位的数据，&lt; 32003 的数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 二进制，16趟</span></span><br><span class="line"><span class="comment">#define radix 2</span></span><br><span class="line"><span class="comment">#define DStep 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 四进制，8趟</span></span><br><span class="line"><span class="comment">#define radix 4</span></span><br><span class="line"><span class="comment">#define DStep 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 八进制，6趟</span></span><br><span class="line"><span class="comment">#define radix 8</span></span><br><span class="line"><span class="comment">#define DStep 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制，4趟</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> radix 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DStep 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 三十二进制，4趟</span></span><br><span class="line"><span class="comment">#define radix 32</span></span><br><span class="line"><span class="comment">#define DStep 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> r)</span>  </span>&#123;</span><br><span class="line">	<span class="comment">//数组实现的基数排序，n为数组长度，d为排序码个数，r为基数</span></span><br><span class="line">	Record *TempArray =<span class="keyword">new</span> Record[n];		<span class="comment">// 辅助排序的临时数组</span></span><br><span class="line">	<span class="keyword">int</span>* count = <span class="keyword">new</span> <span class="keyword">int</span>[r];				<span class="comment">// 桶容量计数器，count[i] 存储了第i个桶中的记录数</span></span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	<span class="keyword">int</span> Radix = <span class="number">1</span>;							<span class="comment">// 模保持进位，用来取Array[j]的第i位排序码</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;d; i++)  &#123;					<span class="comment">// 分别对第i个排序码进行分配</span></span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;r; j++)					<span class="comment">// 初始计数器均为0</span></span><br><span class="line">			count[j] = <span class="number">0</span>;    </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)	 &#123;				<span class="comment">// 统计每个桶中的记录数</span></span><br><span class="line">			k = (Array[j] / Radix) % r;		<span class="comment">// 取Array[j]的第i位排序码</span></span><br><span class="line">			count[k]++;						<span class="comment">// 相应计数器加1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;r; j++)					<span class="comment">// 将TempArray中的位置依次分配给r个桶</span></span><br><span class="line">			count[j] = count[j<span class="number">-1</span>] + count[j];</span><br><span class="line">		<span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;			<span class="comment">// 从数字尾部，把记录收集到相应桶 </span></span><br><span class="line">			k = (Array[j] / Radix ) % r;	<span class="comment">// 取Array[j]的第i位排序码</span></span><br><span class="line">			count[k]--;						<span class="comment">// 使用了第k个桶的一个位置，桶剩余量的计数器减1</span></span><br><span class="line">			TempArray[count[k]] = Array[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)					<span class="comment">// 将临时数组中的内容复制到Array中</span></span><br><span class="line">			Array[j] = TempArray[j];         </span><br><span class="line">		Radix *= r;							<span class="comment">// 往左进一位，修改模Radix</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record* Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    RadixSort(Array, n, DStep, radix);    <span class="comment">// 16进制</span></span><br><span class="line">  <span class="comment">// RadixSort(Array, n, 6, 8);		// 8进制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//基于静态链的基数排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结点类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Elem int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Elem key;    <span class="comment">//结点的关键码值</span></span><br><span class="line">    <span class="keyword">int</span> next;    <span class="comment">//下一个结点在数组中的下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态队列类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链实现的基数排序，n为数组长度，d为排序码个数，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(Record *Array, <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;                        <span class="comment">// first指向静态链中第一个记录</span></span><br><span class="line">    StaticQueue *<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span> = <span class="keyword">new</span> StaticQueue[r];            <span class="comment">// 存放r个桶的静态队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)            <span class="comment">// 建链，初始为next域指向下一个记录</span></span><br><span class="line">        Array[i].next = i + <span class="number">1</span>;</span><br><span class="line">    Array[n - <span class="number">1</span>].next = <span class="number">-1</span>;                <span class="comment">// 链尾next为空</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; d; i++) &#123;            <span class="comment">// 对第i个排序码进行分配和收集，一共d趟</span></span><br><span class="line">        Distribute(Array, first, i, r, <span class="built_in">queue</span>);</span><br><span class="line">        Collect(Array, first, r, <span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">queue</span>;</span><br><span class="line"><span class="comment">//    PrintArray(Array, first);</span></span><br><span class="line">    AddrSort(Array, n, first);            <span class="comment">// 线性时间整理静态链表，使得数组按下标有序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配过程,A中存放待排序记录，first为静态链中的第一个记录,i为第i个排序码，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Distribute</span><span class="params">(Record *Array, <span class="keyword">int</span> first, <span class="keyword">int</span> i, <span class="keyword">int</span> r, StaticQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r; j++)                <span class="comment">// 初始化r个队列</span></span><br><span class="line">        <span class="built_in">queue</span>[j].head = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="number">-1</span>) &#123;                <span class="comment">// 对整个静态链进行分配	   </span></span><br><span class="line">        <span class="keyword">int</span> k = Array[first].key;        <span class="comment">// 取第i位排序码数字k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; i; a++)</span><br><span class="line">            k = k / r;</span><br><span class="line">        k = k % r;</span><br><span class="line">        <span class="comment">// 把Array[first]分配到第k个子序列中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[k].head == <span class="number">-1</span>)        <span class="comment">// 如果子序列为空，Array[first]就是第一个记录</span></span><br><span class="line">            <span class="built_in">queue</span>[k].head = first;</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">// 否则加到子序列的尾部</span></span><br><span class="line">            Array[<span class="built_in">queue</span>[k].tail].next = first;</span><br><span class="line">        <span class="built_in">queue</span>[k].tail = first;            <span class="comment">// first为子序列的尾部</span></span><br><span class="line">        first = Array[first].next;        <span class="comment">// 继续分配下一个记录 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集过程，Array中存放待排序记录，first为静态链中的第一个记录，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span><span class="params">(Record *Array, <span class="keyword">int</span> &amp;first, <span class="keyword">int</span> r, StaticQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last, k = <span class="number">0</span>;                        <span class="comment">// 已收集到的最后一个记录</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">queue</span>[k].head == <span class="number">-1</span>)        <span class="comment">// 找到第一个非空队列</span></span><br><span class="line">        k++;</span><br><span class="line">    first = <span class="built_in">queue</span>[k].head;</span><br><span class="line">    last = <span class="built_in">queue</span>[k].tail;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; r - <span class="number">1</span>) &#123;                    <span class="comment">// 继续收集下一个非空队列，若k==r-1则已是最后一个	</span></span><br><span class="line">        <span class="comment">// 找下一个非空队列</span></span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; r - <span class="number">1</span> &amp;&amp; <span class="built_in">queue</span>[k].head == <span class="number">-1</span>)    <span class="comment">// 当前队列k为空，而且k还不是最后的队列r-1</span></span><br><span class="line">            k++;                    <span class="comment">// 试探下一个队列</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[k].head != <span class="number">-1</span>) &#123;        <span class="comment">// 将这个非空序列与上一个非空序列连接起来		</span></span><br><span class="line">            Array[last].next = <span class="built_in">queue</span>[k].head;</span><br><span class="line">            last = <span class="built_in">queue</span>[k].tail;        <span class="comment">// 此时最后一个记录为这个序列的尾部记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Array[last].next = <span class="number">-1</span>;                <span class="comment">// 收集完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddrSort</span><span class="params">(Record *Array, <span class="keyword">int</span> n, <span class="keyword">int</span> first)</span> </span>&#123;    <span class="comment">// 线性时间整理静态链表，使得数组按下标有序</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    j = first;                    <span class="comment">// j待处理数据下标，第一次为first</span></span><br><span class="line">    Record TempRec;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;            <span class="comment">// 循环n-1次，每次处理第i大记录</span></span><br><span class="line">        TempRec = Array[j];        <span class="comment">// 暂存第i大的纪录</span></span><br><span class="line">        Array[j] = Array[i];            <span class="comment">// 当前下标i的数据存放到j位置</span></span><br><span class="line">        Array[i] = TempRec;        <span class="comment">// 第i大记录入位</span></span><br><span class="line">        Array[i].next = j;            <span class="comment">// 第i大的记录的next链要保留调换轨迹j</span></span><br><span class="line">        j = TempRec.next;            <span class="comment">//  j移动到下一位</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= i)            <span class="comment">// 若j比当前下标i小，则是轨迹，顺链找到数据</span></span><br><span class="line">            j = Array[j].next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class Record&gt;</span></span><br><span class="line"><span class="comment">void IndexSort(Record Array[], int n)</span></span><br><span class="line"><span class="comment">&#123;	//Array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="comment">    int *IndexArray = new int[n],  TempIndex;</span></span><br><span class="line"><span class="comment">	int i,j;</span></span><br><span class="line"><span class="comment">    for (i=0; i&lt;n; i++) IndexArray[i] = i;</span></span><br><span class="line"><span class="comment">	for (i=1; i&lt;n; i++)    // 依次插入第i个记录</span></span><br><span class="line"><span class="comment">		for (j=i;j&gt;0;j--) //依次比较，发现逆置就交换</span></span><br><span class="line"><span class="comment">			if (Array[IndexArray[j]] &lt; Array[IndexArray[j-1]])  &#123;</span></span><br><span class="line"><span class="comment">				TempIndex=IndexArray[j];</span></span><br><span class="line"><span class="comment">                IndexArray[j]=IndexArray[j-1];</span></span><br><span class="line"><span class="comment">			    IndexArray[j-1]=TempIndex;	</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			else break;	//此时i前面记录已排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 根据IndexArray整理Array</span></span><br><span class="line"><span class="comment">    for(i=0; i&lt;n; i++) &#123; </span></span><br><span class="line"><span class="comment">        j=IndexArray[i];</span></span><br><span class="line"><span class="comment">		while (j&lt;i)  </span></span><br><span class="line"><span class="comment">			j=IndexArray[j]; 	</span></span><br><span class="line"><span class="comment">	    swap(Array, i, j);</span></span><br><span class="line"><span class="comment">		IndexArray[i]=j;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array[]为待排序数组，IndexArray[]为索引数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexSort</span><span class="params">(Record Array[], <span class="keyword">int</span> IndexArray[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) IndexArray[i] = i;    <span class="comment">// 初始化索引下标</span></span><br><span class="line">    <span class="comment">// 简单插入排序的地址排序过程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)                <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--)                <span class="comment">// 依次比较，发现逆置就交换</span></span><br><span class="line">            <span class="keyword">if</span> (Array[IndexArray[j]] &lt; Array[IndexArray[j - <span class="number">1</span>]])</span><br><span class="line">                swap(IndexArray, j, j - <span class="number">1</span>);  <span class="comment">// 交换Array[IndexArray[j]]和Array[IndexArray[j-1]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;                <span class="comment">// 此时i前面记录已排序</span></span><br><span class="line">    AdjustRecord(Array, IndexArray, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据IndexArray整理Array，IndexArray[]为索引数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustRecord</span><span class="params">(Record Array[], <span class="keyword">int</span> IndexArray[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Record TempRec;                <span class="comment">// 只需要一个临时存储空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;            <span class="comment">// 循环n-1次，每次处理数组中第i个记录</span></span><br><span class="line">        <span class="keyword">int</span> j = i;                    <span class="comment">// j为临时变量，是循环链中的当前元素</span></span><br><span class="line">        TempRec = Array[i];            <span class="comment">// 暂存i下标中目前的纪录</span></span><br><span class="line">        <span class="keyword">while</span> (IndexArray[j] != i) &#123;    <span class="comment">// 如果循环链中索引下标还不是i，则顺链循环调整</span></span><br><span class="line">            <span class="keyword">int</span> k = IndexArray[j];        <span class="comment">// k为链接j指向的下标</span></span><br><span class="line">            Array[j] = Array[k];        <span class="comment">// 把k下标中的值复制到j位置，第j大元素正确归位</span></span><br><span class="line">            IndexArray[j] = j;        <span class="comment">// 因为是正确归位，索引j就是自身</span></span><br><span class="line">            j = k;                    <span class="comment">// j换到下一个，继续处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        Array[j] = TempRec;            <span class="comment">// 最后找到的j，它的索引下标值为i，因此第i大元素正确入位</span></span><br><span class="line">        IndexArray[j] = j;                <span class="comment">// 因为是正确归位，索引j就是自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Record *temp = <span class="keyword">new</span> Record[n];            <span class="comment">// 申请辅助数组</span></span><br><span class="line">    IndexSort(Array, temp, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SortMain.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="九-文件管理和外排序"><a href="#九-文件管理和外排序" class="headerlink" title="九    文件管理和外排序"></a>九    文件管理和外排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************  Buffer.h  *****************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE  100  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T *L;        <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> nLen;    <span class="comment">// 缓冲大小</span></span><br><span class="line">    <span class="keyword">int</span> nCurr;   <span class="comment">// 当前指针，初始化为0</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Buffer() &#123;</span><br><span class="line">        L = <span class="literal">NULL</span>;</span><br><span class="line">        nLen = <span class="number">0</span>;</span><br><span class="line">        nCurr = <span class="number">0</span>;</span><br><span class="line">    &#125;;  <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                             <span class="comment">//空否</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;                              <span class="comment">//满否</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T e)</span></span>;                            <span class="comment">//插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(FILE *fp)</span></span>;                       <span class="comment">//将缓冲区写回到文件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Buffer&lt;T&gt;::isEmpty() &#123;  <span class="comment">//空否</span></span><br><span class="line">    <span class="keyword">if</span> (nCurr == nLen)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Buffer&lt;T&gt;::isFull() &#123;   <span class="comment">//满否</span></span><br><span class="line">    <span class="keyword">if</span> (nLen == BUFFER_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::insert(T e) &#123;  <span class="comment">//插入数据</span></span><br><span class="line">    <span class="keyword">if</span> (nLen &lt; BUFFER_SIZE)</span><br><span class="line">        L[nLen++] = e;</span><br><span class="line"><span class="comment">// 	cout&lt;&lt;&quot;buffer insert!&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::read(T &amp;e) &#123;     <span class="comment">//读出数据</span></span><br><span class="line">    e = L[nCurr++];</span><br><span class="line"><span class="comment">//	cout&lt;&lt; &quot;Buffer read out.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::flush(FILE *fp) &#123;  <span class="comment">//将缓冲区写回到文件</span></span><br><span class="line">    fwrite(L, <span class="keyword">sizeof</span>(T), nLen, fp);</span><br><span class="line">    nLen = <span class="number">0</span>;</span><br><span class="line">    nCurr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillBuffer</span><span class="params">(FILE *fp, Buffer&lt;T&gt; b)</span> </span>&#123;    <span class="comment">//填充数据</span></span><br><span class="line">    b.nLen = fread(b.L, <span class="keyword">sizeof</span>(T), BUFFER_SIZE, fp);</span><br><span class="line">    b.nCurr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX   7  <span class="comment">// 堆大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************  file operation ****************//</span></span><br><span class="line"><span class="comment">// 函数功能：初始化文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initFiles</span><span class="params">(FILE *&amp;inputFile, FILE *&amp;outputFile, <span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">const</span> <span class="keyword">char</span> *out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((inputFile = fopen(in, <span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open file!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((outputFile = fopen(out, <span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open file!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化堆里的数据，从磁盘文件读n个数据置入数组A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMinHeapArry</span><span class="params">(FILE *inputFile, <span class="keyword">int</span> n, T *A)</span> </span>&#123;</span><br><span class="line">    fread(A, <span class="keyword">sizeof</span>(BYTE), n, inputFile);</span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;file read!!!&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化input buffer, 读入一部分数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;input, FILE *inputFile)</span> </span>&#123;</span><br><span class="line">    input.L = (BYTE *) <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(input.L, <span class="literal">NULL</span>, BUFFER_SIZE);</span><br><span class="line">    input.nLen = fread(input.L, <span class="keyword">sizeof</span>(BYTE), BUFFER_SIZE, inputFile);</span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;InputBuffer initialised!!&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initOutputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;output)</span> </span>&#123;</span><br><span class="line">    output.L = (BYTE *) <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：把mval输出到输出缓冲区，同时出来因缓冲区空或者满的情况</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendToOutputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;input, Buffer&lt;T&gt; &amp;output, FILE *inputFile, FILE *outputFile, T mval)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出缓冲区满，写文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output.isFull()) &#123;</span><br><span class="line">        output.flush(outputFile); <span class="comment">// 不满，写缓冲</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;out buffer is full.&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output.insert(mval);         <span class="comment">// 输入缓冲区空，读文件到缓冲</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;output.insert(mval)&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span> (input.isEmpty() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!feof(inputFile)) &#123;</span><br><span class="line">            <span class="comment">// 文件没有结束</span></span><br><span class="line">            fillBuffer(inputFile, input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：比较大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less</span><span class="params">(T r, T mval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; mval)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：算法结束，处理输入输出缓冲区</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endUp</span><span class="params">(Buffer&lt;T&gt; output, FILE *inputFile, FILE *outputFile)</span> </span>&#123;</span><br><span class="line">    fwrite(output.L, <span class="keyword">sizeof</span>(BYTE), output.nLen, outputFile);</span><br><span class="line">    fclose(inputFile);</span><br><span class="line">    fclose(outputFile);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;output file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replacementSelection</span><span class="params">(T *A, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">const</span> <span class="keyword">char</span> *out)</span> </span>&#123;</span><br><span class="line">    T mval;  <span class="comment">//存放最小值堆的最小值</span></span><br><span class="line">    T r;     <span class="comment">//存放从输入缓冲区中读入的元素	</span></span><br><span class="line">    FILE *inputFile;                   <span class="comment">//输入文件句柄</span></span><br><span class="line">    FILE *outputFile;                  <span class="comment">//输出文件句柄	</span></span><br><span class="line">    Buffer&lt;T&gt; input;                   <span class="comment">//输入buffer</span></span><br><span class="line">    Buffer&lt;T&gt; output;                  <span class="comment">//输出buffer	</span></span><br><span class="line"></span><br><span class="line">    initFiles(inputFile, outputFile, in, out);  <span class="comment">//初始化输入输出文件</span></span><br><span class="line">    <span class="comment">//初始化堆的数据，从磁盘文件读入n个数据置入数组A</span></span><br><span class="line">    initMinHeapArry(inputFile, n, A);  <span class="comment">//从磁盘文件读入n个数据到堆数组A</span></span><br><span class="line">    <span class="function">MinHeap&lt;T&gt; <span class="title">H</span><span class="params">(A, n)</span></span>;          <span class="comment">//建立最小值堆</span></span><br><span class="line">    initInputBuffer(input, inputFile);    <span class="comment">//初始化input buffer，读入一部分数据</span></span><br><span class="line">    initOutputBuffer(output);      <span class="comment">//初始化Output buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> last = (n - <span class="number">1</span>); last &gt;= <span class="number">0</span>;) &#123;   <span class="comment">//堆不为空，就做这个循环</span></span><br><span class="line">        mval = H.heapArray[<span class="number">0</span>];       <span class="comment">//堆的最小值</span></span><br><span class="line">        <span class="comment">//mval = H.RemoveMin();</span></span><br><span class="line">        <span class="comment">//把mval送到输出缓冲区，同时处理因缓冲区空或满造成的各种情形</span></span><br><span class="line"></span><br><span class="line">        sendToOutputBuffer(input, output, inputFile, outputFile, mval);</span><br><span class="line"></span><br><span class="line">        input.read(r);  <span class="comment">//从输入缓冲区读入一个记录</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!less(r, mval)) &#123;    <span class="comment">// r值大于等于刚输出值，r入堆根</span></span><br><span class="line">            H.heapArray[<span class="number">0</span>] = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// r不能入堆，暂存待处理</span></span><br><span class="line">            H.heapArray[<span class="number">0</span>] = H.heapArray[last];  <span class="comment">// 用last位置的记录代替根结点</span></span><br><span class="line">            H.heapArray[last] = r;                <span class="comment">// 把r放到last位置</span></span><br><span class="line">            H.setSize(last);                    <span class="comment">// 堆规模缩小1</span></span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="number">0</span>) &#123;       <span class="comment">//重新排列堆</span></span><br><span class="line">            H.SiftDown(<span class="number">0</span>);  <span class="comment">//把根结点记录下降到合适的位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//endfor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法结束工作：处理输出缓冲区，输入/输出文件</span></span><br><span class="line">    endUp(output, inputFile, outputFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> in[] = <span class="string">&quot;file_in.txt&quot;</span>;   <span class="comment">// 输入文件名称</span></span><br><span class="line">    <span class="keyword">char</span> out[] = <span class="string">&quot;file_out.txt&quot;</span>; <span class="comment">// 输出文件名称</span></span><br><span class="line">    <span class="keyword">int</span> n = MAX; <span class="comment">// 数组元素个数，即内存数目 </span></span><br><span class="line">    BYTE *A = <span class="keyword">new</span> BYTE[MAX];</span><br><span class="line">    replacementSelection(A, n, in, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//****************   WinnerTree.h   *****************//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 8        <span class="comment">//选手数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WinnerTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WinnerTree(<span class="keyword">int</span> TreeSize = MAX);</span><br><span class="line"></span><br><span class="line">    ~WinnerTree() &#123; <span class="keyword">delete</span>[] B; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;  <span class="comment">//初始化赢者树</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (n) ? B[<span class="number">1</span>] : <span class="number">0</span>; &#125;     <span class="comment">////返回最终胜者的索引，在赢者树中这个索引放在B[1]中</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (i &lt; n) ? B[i] : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RePlay</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>; <span class="comment">//位置i的外部选手改变后重构赢者树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Play</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> MaxSize;     <span class="comment">//允许的最大选手数</span></span><br><span class="line">    <span class="keyword">int</span> n;             <span class="comment">//当前选手数</span></span><br><span class="line">    <span class="keyword">int</span> LowExt;         <span class="comment">//最底层外部结点数</span></span><br><span class="line">    <span class="keyword">int</span> offset;         <span class="comment">//最底层外部结点之上的结点总数</span></span><br><span class="line">    <span class="keyword">int</span> *B;          <span class="comment">//赢者树数组，实际存放的是下标</span></span><br><span class="line">    T *L;            <span class="comment">//元素数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">WinnerTree&lt;T&gt;::WinnerTree(<span class="keyword">int</span> TreeSize) &#123;</span><br><span class="line">    MaxSize = TreeSize;</span><br><span class="line">    B = <span class="keyword">new</span> <span class="keyword">int</span>[MaxSize];</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化赢者树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Initialize(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MaxSize || size &lt; <span class="number">2</span>)   <span class="comment">//能否处理size个选手的数组A[]</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    n = size;                   <span class="comment">//初始化成员变量</span></span><br><span class="line">    L = A;</span><br><span class="line">    <span class="keyword">int</span> i, s;</span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">1</span>; <span class="number">2</span> * s &lt;= n - <span class="number">1</span>; s += s);  <span class="comment">//计算 s = 2^log(n-1)</span></span><br><span class="line">    LowExt = <span class="number">2</span> * (n - s);</span><br><span class="line">    offset = <span class="number">2</span> * s - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= LowExt; i += <span class="number">2</span>)     <span class="comment">//最底层外部结点的比赛</span></span><br><span class="line">        Play((offset + i) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner);</span><br><span class="line"><span class="comment">//处理其余外部结点</span></span><br><span class="line"><span class="comment">//若n为奇数，内部结点和外部结点比赛。这里用L[LowExt+1]和它的父结点比赛</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">        Play(n / <span class="number">2</span>, B[n - <span class="number">1</span>], LowExt + <span class="number">1</span>, winner);</span><br><span class="line">        i = LowExt + <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        i = LowExt + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="number">2</span>)        <span class="comment">//剩余外部结点的比赛</span></span><br><span class="line">        Play((i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从内部结点B[p]处开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Play(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    B[p] = winner(L, lc, rc);        <span class="comment">//胜者索引放在B[p]中</span></span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; p % <span class="number">2</span>) &#123;     <span class="comment">//右孩子，需要沿路径继续向上比赛</span></span><br><span class="line">        B[p / <span class="number">2</span>] = winner(L, B[p - <span class="number">1</span>], B[p]);</span><br><span class="line">        p /= <span class="number">2</span>;  <span class="comment">//父结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数RePlay负责选手i的值改变后重新开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::RePlay(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p, lc, rc;        <span class="comment">//比赛结点极其左右孩子的下标</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= LowExt) &#123;        <span class="comment">//从最底层开始</span></span><br><span class="line">        p = (offset + i) / <span class="number">2</span>;</span><br><span class="line">        lc = <span class="number">2</span> * p - offset; <span class="comment">// left child of p</span></span><br><span class="line">        rc = lc + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * p == n - <span class="number">1</span>) &#123;</span><br><span class="line">            lc = B[<span class="number">2</span> * p];</span><br><span class="line">            rc = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="number">2</span> * p - n + <span class="number">1</span> + LowExt;</span><br><span class="line">            rc = lc + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B[p] = winner(L, lc, rc);     <span class="comment">//B[p]中保存赢者的索引</span></span><br><span class="line">    <span class="comment">//完成剩下的比赛</span></span><br><span class="line">    p /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &gt;= <span class="number">1</span>; p /= <span class="number">2</span>)       <span class="comment">//沿路径向上比赛</span></span><br><span class="line">        B[p] = winner(L, B[<span class="number">2</span> * p], B[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Output() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前选手数(size) = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 最底层外部结点数(LowExt) = &quot;</span> &lt;&lt; LowExt</span><br><span class="line">         &lt;&lt; <span class="string">&quot; 最底层外部结点之上的结点总数(Offset) = &quot;</span> &lt;&lt; offset &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;赢者树B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回赢者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A[b] &lt;= A[c])</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************   LooserTree.h   ***************//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：返回赢者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[b] &lt;= A[c] ? b : c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：返回败者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loser</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[b] &gt; A[c] ? b : c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoserTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LoserTree(<span class="keyword">int</span> Treesize);</span><br><span class="line"></span><br><span class="line">    ~LoserTree() &#123; <span class="keyword">delete</span>[] B; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RePlay</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Play</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部结点从右分支向上比赛</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize; <span class="comment">// 最大选手数</span></span><br><span class="line">    <span class="keyword">int</span> n;   <span class="comment">// 当前选手数</span></span><br><span class="line">    <span class="keyword">int</span> LowExt;  <span class="comment">// 最底层外部结点数 lowest-level external nodes</span></span><br><span class="line">    <span class="keyword">int</span> offset;  <span class="comment">// 最底层外部结点之上的结点数 2^k - 1</span></span><br><span class="line">    <span class="keyword">int</span> *B;   <span class="comment">// 赢者数数组 array for winner tree</span></span><br><span class="line">    T *L;   <span class="comment">// 选手数组 element array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">LoserTree&lt;T&gt;::LoserTree(<span class="keyword">int</span> TreeSize) &#123;</span><br><span class="line">    MaxSize = TreeSize;</span><br><span class="line">    B = <span class="keyword">new</span> <span class="keyword">int</span>[MaxSize];</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Winner，返回最终胜者的索引，在败者树中这个索引存放在B[0]中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> LoserTree&lt;T&gt;::Winner() &#123;  <span class="comment">// 返回最终胜者的索引B[0]</span></span><br><span class="line">    <span class="keyword">return</span> (n) ? B[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Initilalize负责初始化败者树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Initialize(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                              <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;<span class="comment">// 初始化败者树</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MaxSize || size &lt; <span class="number">2</span>) &#123;        <span class="comment">//能否处理size个选手的数组a[]</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bad Input!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = size;                    <span class="comment">//初始化成员变量</span></span><br><span class="line">    L = A;</span><br><span class="line">    <span class="keyword">int</span> i, s;</span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">1</span>; <span class="number">2</span> * s &lt;= n - <span class="number">1</span>; s += s);    <span class="comment">//计算s = 2^log(n-1)</span></span><br><span class="line">    LowExt = <span class="number">2</span> * (n - s);</span><br><span class="line">    offset = <span class="number">2</span> * s - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最底层外部结点的比赛</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= LowExt; i += <span class="number">2</span>)     <span class="comment">// 最底层外部结点的比赛</span></span><br><span class="line">        Play((offset + i) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner, loser);</span><br><span class="line">    <span class="comment">//处理其余外部结点</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;           <span class="comment">// n为奇数，内部结点和外部结点比一次</span></span><br><span class="line">        Play(n / <span class="number">2</span>, B[(n - <span class="number">1</span>) / <span class="number">2</span>], LowExt + <span class="number">1</span>, winner, loser);<span class="comment">//暂存在父结点的左胜者与外部右子结点比</span></span><br><span class="line">        i = LowExt + <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        i = LowExt + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="number">2</span>)   <span class="comment">// 剩余外部结点的比赛</span></span><br><span class="line">        Play((i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner, loser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Play负责在内部结点B[p]处开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Play(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[],</span><br><span class="line">                                                            <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                        <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;  <span class="comment">// 在内部结点从右分支向上比赛</span></span><br><span class="line">    B[p] = loser(L, lc, rc);       <span class="comment">//败者索引放在B[p]中			</span></span><br><span class="line">    <span class="keyword">int</span> temp1, temp2;</span><br><span class="line">    temp1 = winner(L, lc, rc);    <span class="comment">//p处的胜者索引</span></span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; p % <span class="number">2</span>) &#123;       <span class="comment">// p为奇数右孩子，沿路径继续向上比赛</span></span><br><span class="line">        temp2 = winner(L, temp1, B[p / <span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//p的胜者和p的父结点比较，赢者暂存在temp2中</span></span><br><span class="line">        B[p / <span class="number">2</span>] = loser(L, temp1, B[p / <span class="number">2</span>]);                <span class="comment">//败者索引放入B[p/2]</span></span><br><span class="line">        temp1 = temp2;         <span class="comment">// 胜者放入temp1</span></span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    B[p / <span class="number">2</span>] = temp1;             <span class="comment">// B[p]是左孩子或者p=1，结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数RePlay负责选手i的值改变后重新开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::RePlay(<span class="keyword">int</span> i, <span class="keyword">int</span> (*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                          <span class="keyword">int</span> (*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;  <span class="comment">// 选手i的值改变后，重新开始比赛</span></span><br><span class="line">    <span class="keyword">int</span> p;               <span class="comment">// 用于计算父结点索引的临时变量</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Out of Bounds!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确定父结点的位置</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= LowExt)</span><br><span class="line">        p = (i + offset) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p = (i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    B[<span class="number">0</span>] = winner(L, i, B[p]);         <span class="comment">//B[0]中始终保存胜者的索引</span></span><br><span class="line">    B[p] = loser(L, i, B[p]);          <span class="comment">//B[p]中保存败者的索引</span></span><br><span class="line">    <span class="keyword">for</span> (; (p / <span class="number">2</span>) &gt;= <span class="number">1</span>; p /= <span class="number">2</span>) &#123;          <span class="comment">//沿路径向上比赛</span></span><br><span class="line">        <span class="keyword">int</span> temp;<span class="comment">//临时存放赢者的索引</span></span><br><span class="line">        temp = winner(L, B[p / <span class="number">2</span>], B[<span class="number">0</span>]);</span><br><span class="line">        B[p / <span class="number">2</span>] = loser(L, B[p / <span class="number">2</span>], B[<span class="number">0</span>]);</span><br><span class="line">        B[<span class="number">0</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Output() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前选手数(size) = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 最底层外部结点数(LowExt) = &quot;</span> &lt;&lt; LowExt</span><br><span class="line">         &lt;&lt; <span class="string">&quot; 最底层外部结点之上的结点总数(Offset) = &quot;</span> &lt;&lt; offset &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;败者树B（B0存放胜者下标）: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十-检索"><a href="#十-检索" class="headerlink" title="十    检索"></a>十    检索</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Item(Type value) : key(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;         <span class="comment">//获取关键码值;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(Type k)</span> </span>&#123;</span><br><span class="line">        key = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type key;                           <span class="comment">//关键码域</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//其它域;                              //其它域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = length;</span><br><span class="line">    datavector[<span class="number">0</span>]-&gt;setKey(k);        <span class="comment">//将第0个元素设为待检索值</span></span><br><span class="line">    <span class="keyword">while</span> (datavector[i]-&gt;getKey() != k)</span><br><span class="line">        i--;     <span class="comment">//从后往前逐个比较</span></span><br><span class="line">    <span class="keyword">return</span> i;           <span class="comment">//返回元素位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SimpleSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (datavector[i]-&gt;getKey() != k &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">        i--;     <span class="comment">//从后往前逐个比较</span></span><br><span class="line">    <span class="keyword">return</span> i;           <span class="comment">//返回元素位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = length, mid;   <span class="comment">//low, high分别记录数组首尾位置</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; datavector[mid]-&gt;getKey())</span><br><span class="line">            high = mid - <span class="number">1</span>;               <span class="comment">//右缩检索区间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; datavector[mid]-&gt;getKey())</span><br><span class="line">            low = mid + <span class="number">1</span>;           <span class="comment">//左缩检索区间</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;                            <span class="comment">//检索成功，返回元素位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                 <span class="comment">//检索失败，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间变量与时间函数</span></span><br><span class="line"><span class="keyword">clock_t</span> tstart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Settime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tstart = clock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Gettime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) ((<span class="keyword">double</span>) clock() - (<span class="keyword">double</span>) tstart) / (<span class="keyword">double</span>) CLOCKS_PER_SEC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt; Item&lt;<span class="keyword">int</span>&gt; * &gt; datavector(<span class="number">200001</span>);</span><br><span class="line"></span><br><span class="line">    Item&lt;<span class="keyword">int</span>&gt; *darray[<span class="number">200001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200001</span>; j++)</span><br><span class="line">        darray[j] = <span class="keyword">new</span> Item&lt;<span class="keyword">int</span>&gt;(j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Item&lt;<span class="keyword">int</span>&gt; *&gt;::iterator outputIterator = datavector.begin();</span><br><span class="line">    copy(darray, darray + <span class="number">200001</span>, outputIterator);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Settime();<span class="comment">//开始计时</span></span><br><span class="line">    k = SeqSearch(datavector, datavector.size() - <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&gt;监视哨顺序检索耗时 : &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Gettime() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Settime();<span class="comment">//开始计时</span></span><br><span class="line">    k = SimpleSearch(datavector, datavector.size() - <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&gt;一般顺序检索耗时 : &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Gettime() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySet</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ulong;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        NB = <span class="number">8</span> * <span class="keyword">sizeof</span>(ulong),            <span class="comment">//unsigned long数据类型的位的数目</span></span><br><span class="line">        LI = N == <span class="number">0</span> ? <span class="number">0</span> : (N - <span class="number">1</span>) / NB        <span class="comment">//数组最后一个元素的下标</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ulong A[LI + <span class="number">1</span>];                        <span class="comment">//存放位向量的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tidy</span><span class="params">(ulong X = <span class="number">0</span>)</span></span>;                    <span class="comment">//将数组中的每个元素设成X</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trim</span><span class="params">()</span></span>;                            <span class="comment">//将不使用的位设成0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mySet();                                <span class="comment">//构造函数</span></span><br><span class="line">    mySet(ulong X);</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">set</span><span class="params">()</span></span>;                        <span class="comment">//设置元素属性</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">set</span><span class="params">(<span class="keyword">size_t</span> P, <span class="keyword">bool</span> X = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">reset</span><span class="params">()</span></span>;                        <span class="comment">//把集合设为空</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">reset</span><span class="params">(<span class="keyword">size_t</span> P)</span></span>;                <span class="comment">//删除元素P</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">at</span><span class="params">(<span class="keyword">size_t</span> P)</span> <span class="keyword">const</span></span>;                <span class="comment">//属于运算</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> P) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">flip</span><span class="params">()</span></span>;                        <span class="comment">//求反</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">flip</span><span class="params">(<span class="keyword">size_t</span> P)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ulong <span class="title">to_ulong</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;                    <span class="comment">//计算集合内元素数目</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">size_t</span> P)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span> <span class="keyword">const</span></span>;                        <span class="comment">//判断集合是否包含元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">none</span><span class="params">()</span> <span class="keyword">const</span></span>;                        <span class="comment">//判断集合是否为空</span></span><br><span class="line"></span><br><span class="line">    mySet&lt;N&gt; <span class="keyword">operator</span>~() <span class="keyword">const</span>;                    <span class="comment">//非运算</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//交等于</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>|=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//并等于</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>^=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//异或等于</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//等于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//不等</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//包含于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//真包含于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//包含</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//真包含</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//交运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) &amp;= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>|(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//并运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) |= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//差运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) &amp; ~R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>^(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//异或运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) ^= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;O, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;        <span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> P = <span class="number">0</span>; P &lt; N; P++)</span><br><span class="line">            O &lt;&lt; (R.test(P) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (O);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> mySet&lt;N&gt;::Tidy(ulong X) &#123;   <span class="comment">//将数组中的每个元素设成X</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] = X;</span><br><span class="line">    <span class="keyword">if</span> (X != <span class="number">0</span>)</span><br><span class="line">        Trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> mySet&lt;N&gt;::Trim() &#123;            <span class="comment">//将不使用的位设成0</span></span><br><span class="line">    <span class="keyword">if</span> (N % NB != <span class="number">0</span>)</span><br><span class="line">        A[LI] &amp;= ((ulong) <span class="number">1</span> &lt;&lt; N % NB) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt;::mySet() &#123;                <span class="comment">//构造函数</span></span><br><span class="line">    Tidy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt;::mySet(ulong X) &#123;</span><br><span class="line">    Tidy();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> P = <span class="number">0</span>; X != <span class="number">0</span> &amp;&amp; P &lt; N; X &gt;&gt;= <span class="number">1</span>, ++P)</span><br><span class="line">        <span class="keyword">if</span> (X &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">set</span>(P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="built_in">set</span>() &#123;        <span class="comment">//设置元素属性</span></span><br><span class="line">    Tidy(~(ulong) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;size_t N&gt;	mySet&lt;N&gt;&amp; mySet&lt;N&gt;::set(size_t P)&#123;</span></span><br><span class="line"><span class="comment">	A[P / NB] |= (ulong)1 &lt;&lt; P % NB;</span></span><br><span class="line"><span class="comment">	return (*this); </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="built_in">set</span>(<span class="keyword">size_t</span> P, <span class="keyword">bool</span> X) &#123;</span><br><span class="line">    <span class="keyword">if</span> (X)                                    <span class="comment">// X为真，位向量中相应值设为1</span></span><br><span class="line">        A[P / NB] |= (ulong) <span class="number">1</span> &lt;&lt; (P % NB);        <span class="comment">// P对应的元素进行按位或运算</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A[P / NB] &amp;= ~((ulong) <span class="number">1</span> &lt;&lt; (P % NB));    <span class="comment">// X为假，位向量中相应值设为0</span></span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::reset() &#123;                <span class="comment">//把集合设置为空</span></span><br><span class="line">    Tidy();</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::reset(<span class="keyword">size_t</span> P) &#123;        <span class="comment">//把具体元素设置为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(P, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::at(<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;        <span class="comment">//属于运算</span></span><br><span class="line">    <span class="keyword">return</span> (test(P));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (test(P));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::flip() &#123;                <span class="comment">//求非运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] = ~A[I];</span><br><span class="line">    Trim();</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::flip(<span class="keyword">size_t</span> P) &#123;      <span class="comment">// 取反</span></span><br><span class="line">    A[P / NB] ^= (ulong) <span class="number">1</span> &lt;&lt; P % NB;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mySet&lt;N&gt;::to_ulong() <span class="keyword">const</span> &#123; <span class="comment">// 转换为ulong类型</span></span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mySet&lt;N&gt;::to_string() <span class="keyword">const</span> &#123;   <span class="comment">// 用0，1形式把集合内容输出到字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> S;</span><br><span class="line">    S.reserve(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> P = N; <span class="number">0</span> &lt; P;)</span><br><span class="line">        S += test(--P) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> (S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">size_t</span> mySet&lt;N&gt;::count() <span class="keyword">const</span> &#123;      <span class="comment">//计算集合元素数目</span></span><br><span class="line">    <span class="keyword">size_t</span> V = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">for</span> (ulong X = A[I]; X != <span class="number">0</span>; X &gt;&gt;= <span class="number">4</span>)</span><br><span class="line">            V += <span class="string">&quot;\0\1\1\2\1\2\2\3&quot;</span>                        <span class="comment">//&quot;\0\1\1\2\1\2\2\3\1\2\2\3\2\3\3\4&quot;代表十六进制数0-F所包含1的数目的数组</span></span><br><span class="line">                 <span class="string">&quot;\1\2\2\3\2\3\3\4&quot;</span>[X &amp; <span class="number">0xF</span>];</span><br><span class="line">    <span class="keyword">return</span> (V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">size_t</span> mySet&lt;N&gt;::size() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::test(<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((A[P / NB] &amp; ((ulong) <span class="number">1</span> &lt;&lt; P % NB)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::any() <span class="keyword">const</span> &#123;           <span class="comment">//判断集合是否包含元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">if</span> (A[I] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::none() <span class="keyword">const</span> &#123;          <span class="comment">//判断集合是否为空</span></span><br><span class="line">    <span class="keyword">return</span> (!any());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; mySet&lt;N&gt;::<span class="keyword">operator</span>~() <span class="keyword">const</span> &#123;    <span class="comment">//非运算</span></span><br><span class="line">    <span class="keyword">return</span> (mySet&lt;N&gt;(*<span class="keyword">this</span>).flip());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123; <span class="comment">//赋值交</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)            <span class="comment">// 从低位到高位</span></span><br><span class="line">        A[I] &amp;= R.A[I];                        <span class="comment">// 以ulong元素为单位按位交</span></span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>|=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123; <span class="comment">//并等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] |= R.A[I];</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>^=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//异或等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] ^= R.A[I];</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>==(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">if</span> (A[I] != R.A[I])</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>!=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//不等运算</span></span><br><span class="line">    <span class="keyword">return</span> (!(*<span class="keyword">this</span> == R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//包含于运算</span></span><br><span class="line">    <span class="keyword">return</span> ((mySet(*<span class="keyword">this</span>) |= R) == R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;   <span class="comment">//真包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((*<span class="keyword">this</span> &lt;= R) &amp;&amp; (*<span class="keyword">this</span> != R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((mySet(*<span class="keyword">this</span>) &amp;= R) == R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;   <span class="comment">//真包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((*<span class="keyword">this</span> &gt;= R) &amp;&amp; (*<span class="keyword">this</span> != R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  &amp;运算只是friend, LI属于未定义</span></span><br><span class="line"><span class="comment">template&lt;size_t N&gt;	 mySet&lt;N&gt; operator&amp;( const mySet&lt;N&gt;&amp; L,  const mySet&lt;N&gt;&amp; R) &#123;//交运算</span></span><br><span class="line"><span class="comment">	mySet&lt;N&gt; s = L;</span></span><br><span class="line"><span class="comment">	for (int I = LI; I &gt;= 0; I--)</span></span><br><span class="line"><span class="comment">		s.A[I] &amp;= R.A[I];</span></span><br><span class="line"><span class="comment">	return s; 	</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashdict</span> </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Elem* HT;     <span class="comment">// 散列表</span></span><br><span class="line">  <span class="keyword">int</span> M;       <span class="comment">// 散列表大小</span></span><br><span class="line">   Elem TOMB;    <span class="comment">//墓碑</span></span><br><span class="line">  <span class="keyword">int</span> currcnt;  <span class="comment">// 现有元素数目</span></span><br><span class="line">  Elem EMPTY;  <span class="comment">// 空槽</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(Key K, <span class="keyword">int</span> i)</span> <span class="keyword">const</span> <span class="comment">// 探查函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> linear(i); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x % M; &#125; <span class="comment">// 散列函数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">char</span>* x)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 字符串散列函数</span></span><br><span class="line">    <span class="keyword">int</span> i, sum;</span><br><span class="line">    <span class="keyword">for</span> (sum=<span class="number">0</span>, i=<span class="number">0</span>; x[i] != <span class="string">&#x27;\0&#x27;</span>; i++) sum += (<span class="keyword">int</span>) x[i];</span><br><span class="line">    <span class="keyword">return</span>(sum % M);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">linear</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> i;&#125;        <span class="comment">//线性探查</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;                  <span class="comment">//二次探查</span></span><br><span class="line">	  <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> -(i*i/<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">else</span>       <span class="keyword">return</span> (i+<span class="number">1</span>)*(i+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">rehash</span> <span class="params">(Key K, <span class="keyword">int</span> i)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> x )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  x % M; &#125;  <span class="comment">//除余法</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ELFhash</span> <span class="params">( <span class="keyword">char</span>*  key )</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">			  <span class="keyword">while</span>(*key) &#123; </span><br><span class="line">                      h = ( h &lt;&lt; <span class="number">4</span> ) + *key++;</span><br><span class="line">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> g = h&amp;<span class="number">0xF0000000</span>L;</span><br><span class="line">                      <span class="keyword">if</span> (g) h^= g &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                      h  = ~g;</span><br><span class="line">                        &#125;</span><br><span class="line">                  <span class="keyword">return</span> h % M;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   hashdict(<span class="keyword">int</span> sz, Elem e, Elem t)&#123;<span class="comment">// 构造函数, e用来定义空槽</span></span><br><span class="line">          M=sz; EMPTY= e; TOMB=t;</span><br><span class="line">          currcnt=<span class="number">0</span>; HT=<span class="keyword">new</span> Elem[sz];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++) HT[i]= EMPTY; </span><br><span class="line">&#125;</span><br><span class="line">  ~hashdict() &#123; <span class="keyword">delete</span> HT; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hashInsert</span><span class="params">(<span class="keyword">const</span> Elem&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hashSearch</span><span class="params">(<span class="keyword">const</span> Key&amp;, Elem&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Elem <span class="title">hashDelete</span><span class="params">(<span class="keyword">const</span> Key&amp; K)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> currcnt; &#125; <span class="comment">// 散列表中现有元素数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Int.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../COMPARE.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HASHDICT.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> hashdict&lt;Key, Elem, KEComp, EEComp&gt;::</span><br><span class="line">hashSearch(<span class="keyword">const</span> Key &amp;K, Elem &amp;e) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(K);            <span class="comment">// home 保存K的基地址</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;           <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KEComp::eq(K, HT[pos])) &#123;  <span class="comment">// 发现目标</span></span><br><span class="line">            e = HT[pos];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(K, i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据元素e插入到散列表 HT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> hashdict&lt;Key, Elem, KEComp, EEComp&gt;::hashInsert(<span class="keyword">const</span> Elem &amp;e) &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(getkey(e));        <span class="comment">// home记录基位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, insplace;</span><br><span class="line">    <span class="keyword">bool</span> tomb_pos = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;                <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (EEComp::eq(e, HT[pos]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不允许重复关键码</span></span><br><span class="line">        <span class="keyword">if</span> (EEComp::eq(TOMB, HT[pos]) &amp;&amp; !tomb_pos) &#123;</span><br><span class="line">            insplace = pos;                 <span class="comment">//记录第一个墓碑的位置   </span></span><br><span class="line">            tomb_pos = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(getkey(e), i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!tomb_pos)</span><br><span class="line">        insplace = pos;      <span class="comment">//如果没有墓碑，插入空位置</span></span><br><span class="line">    HT[insplace] = e;                  <span class="comment">//插入e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除算法：在检索函数的基础上进行了修改。</span></span><br><span class="line"><span class="comment">// 若检索失败，则无值可删；检索成功则将其设为墓碑。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line">Elem hashdict&lt;Key, Elem, KEComp, EEComp&gt;::hashDelete(<span class="keyword">const</span> Key &amp;K) &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(K);<span class="comment">// home记录基位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;        <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    Elem temp;</span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KEComp::eq(K, HT[pos])) &#123;</span><br><span class="line">            temp = HT[pos];</span><br><span class="line">            HT[pos] = TOMB; <span class="comment">//设置墓碑</span></span><br><span class="line">            <span class="keyword">return</span> temp;    <span class="comment">//返回目标</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(K, i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EMPTY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getkey</span><span class="params">(Int *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;key();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getkey</span><span class="params">(<span class="keyword">char</span> *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Intkey</span><span class="params">(Int &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e.key();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">charkey</span><span class="params">(<span class="keyword">char</span> *&amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    hashdict&lt;int, Int *, intIntsCompare, IntsIntsCompare&gt; dict(100, new Int(-1), new Int(-2));</span><br><span class="line">    Int *val;</span><br><span class="line"></span><br><span class="line">    dict.hashInsert(<span class="keyword">new</span> Int(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">if</span> (dict.hashSearch(<span class="number">10</span>, val))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;发现值 &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; 匹配关键码10\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有发现匹配关键码10的元素\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="十一-索引技术"><a href="#十一-索引技术" class="headerlink" title="十一    索引技术"></a>十一    索引技术</h2><h2 id="十二-高级数据结构"><a href="#十二-高级数据结构" class="headerlink" title="十二    高级数据结构"></a>十二    高级数据结构</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用十字链表实现稀疏矩阵</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxtempl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> //(行、列、元素)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先定义节点类.T是节点存储的数据类型</span></span><br><span class="line"><span class="comment">//如果是头结点则不存储任何数值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;<span class="comment">//矩阵的行和列</span></span><br><span class="line">    T element;<span class="comment">//矩阵中存储的数据</span></span><br><span class="line">    OLNode&lt;T&gt; *right, *down;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OLNode() &#123;</span><br><span class="line">        right = <span class="literal">NULL</span>;</span><br><span class="line">        down = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏矩阵</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rownum, colnum;<span class="comment">//行列数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateMatrix</span><span class="params">(CArray &lt;Element, Element&gt; &amp;Data)</span></span>;<span class="comment">//only for local use</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OLNode&lt;T&gt; **rowhead, **colhead;<span class="comment">//矩阵的第一个非零元素</span></span><br><span class="line">    SMatrix();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MallocMem</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>; <span class="comment">//为矩阵收集内存</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetRownum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetColnum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateMatrix</span><span class="params">()</span></span>;<span class="comment">//建立矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FreeMem</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SMatrix&lt;<span class="keyword">int</span>&gt; *<span class="title">MatrixMutil</span><span class="params">(SMatrix&lt;<span class="keyword">int</span>&gt; *left, SMatrix&lt;<span class="keyword">int</span>&gt; *right)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SMatrix&lt;T&gt;::SMatrix() &#123;</span><br><span class="line">    rowhead = colhead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SMatrix&lt;T&gt;::GetRownum() &#123;</span><br><span class="line">    <span class="keyword">return</span> rownum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SMatrix&lt;T&gt;::GetColnum() &#123;</span><br><span class="line">    <span class="keyword">return</span> colnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::MallocMem(<span class="keyword">int</span> row, <span class="keyword">int</span> col) &#123;</span><br><span class="line">    rownum = row;</span><br><span class="line">    colnum = col;</span><br><span class="line">    rowhead = <span class="keyword">new</span> OLNode&lt;T&gt; *[row + <span class="number">1</span>];</span><br><span class="line">    colhead = <span class="keyword">new</span> OLNode&lt;T&gt; *[col + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt;= row; count++) &#123;<span class="comment">//初始化为头结点</span></span><br><span class="line">        rowhead[count] = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        rowhead[count]-&gt;row = <span class="number">-1</span>;</span><br><span class="line">        rowhead[count]-&gt;col = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt;= col; count++) &#123;</span><br><span class="line">        colhead[count] = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        colhead[count]-&gt;row = <span class="number">-1</span>;</span><br><span class="line">        colhead[count]-&gt;col = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::CreateMatrix() &#123;</span><br><span class="line">    <span class="comment">//首先</span></span><br><span class="line">    <span class="keyword">if</span> ((rowhead != <span class="literal">NULL</span>) || (colnum != <span class="literal">NULL</span>))</span><br><span class="line">        FreeMem();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入矩阵的行数:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; rownum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入矩阵的列数:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; colnum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//为行列指针收集空间</span></span><br><span class="line">    MallocMem(rownum, colnum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入矩阵的元素，格式&lt;行，列，数据&gt;+回车,结束输入请输入-1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    T ele;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ele;</span><br><span class="line">        <span class="keyword">if</span> ((i &gt; rownum) || (j &gt; colnum) || (i &lt; <span class="number">1</span>) || (j &lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不正确的行，列号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OLNode&lt;T&gt; *temp = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        temp-&gt;row = i;</span><br><span class="line">        temp-&gt;col = j;</span><br><span class="line">        temp-&gt;element = ele;</span><br><span class="line">        <span class="comment">//处理行指针</span></span><br><span class="line">        <span class="comment">//查找位置</span></span><br><span class="line">        OLNode&lt;T&gt; *t2 = rowhead[i];</span><br><span class="line">        OLNode&lt;T&gt; *t1 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (j &gt; t2-&gt;col)) &#123;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = t2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (t2-&gt;col == j)) &#123;<span class="comment">//修改值</span></span><br><span class="line">            t2-&gt;element = temp-&gt;element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入新的指针</span></span><br><span class="line">            t1-&gt;right = temp;</span><br><span class="line">            temp-&gt;right = t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理列指针</span></span><br><span class="line">        <span class="comment">//查找位置</span></span><br><span class="line">        t2 = colhead[j];</span><br><span class="line">        t1 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (i &gt; t2-&gt;row)) &#123;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = t2-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (t2-&gt;row == i)) &#123;<span class="comment">//修改值</span></span><br><span class="line">            t2-&gt;element = temp-&gt;element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;     <span class="comment">//插入新的指针</span></span><br><span class="line">            t1-&gt;down = temp;</span><br><span class="line">            temp-&gt;down = t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//end of while</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::PrintAll() &#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= rownum; i++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *temp = rowhead[i]-&gt;right;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= colnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;col == j)) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; temp-&gt;element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                temp = temp-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 0 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::FreeMem() &#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= rownum; i++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *temp = rowhead[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= colnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;col == j)) &#123;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> rowhead;</span><br><span class="line">    <span class="keyword">delete</span> colhead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SMatrix&lt;<span class="keyword">int</span>&gt; *SMatrix&lt;T&gt;::MatrixMutil(SMatrix&lt;<span class="keyword">int</span>&gt; *left, SMatrix&lt;<span class="keyword">int</span>&gt; *right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left-&gt;GetColnum() != right-&gt;GetRownum())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//行列不匹配不能相乘</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> I = <span class="number">0</span>; <span class="comment">//第一个矩阵的行数</span></span><br><span class="line">    <span class="keyword">int</span> J = <span class="number">0</span>; <span class="comment">//第二个矩阵的列数</span></span><br><span class="line">    SMatrix&lt;T&gt; *ResultMatrix = <span class="keyword">new</span> SMatrix&lt;T&gt;();</span><br><span class="line">    ResultMatrix-&gt;MallocMem(left-&gt;GetRownum(), right-&gt;GetColnum());</span><br><span class="line">    <span class="keyword">for</span> (I = <span class="number">1</span>; I &lt;= left-&gt;GetRownum(); I++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *RowNext = ResultMatrix-&gt;rowhead[I];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (J = <span class="number">1</span>; J &lt;= right-&gt;GetColnum(); J++) &#123;</span><br><span class="line">            OLNode&lt;T&gt; *ColNext = ResultMatrix-&gt;colhead[J];</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            OLNode&lt;<span class="keyword">int</span>&gt; *rows = left-&gt;rowhead[I]-&gt;right;</span><br><span class="line">            OLNode&lt;<span class="keyword">int</span>&gt; *cols = right-&gt;colhead[J]-&gt;down;</span><br><span class="line">            <span class="keyword">if</span> ((rows == <span class="literal">NULL</span>) || (cols == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//新行没有非零元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((rows != <span class="literal">NULL</span>) &amp;&amp; (cols != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows-&gt;col &lt; cols-&gt;row) &#123;</span><br><span class="line">                    rows = rows-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rows-&gt;col &gt; cols-&gt;row) &#123;</span><br><span class="line">                    cols = cols-&gt;down;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//都有元素可以相乘</span></span><br><span class="line">                    result = result + cols-&gt;element * rows-&gt;element;</span><br><span class="line">                    cols = cols-&gt;down;</span><br><span class="line">                    rows = rows-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//插入到结果矩阵中</span></span><br><span class="line">            OLNode&lt;T&gt; *temp = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">            temp-&gt;row = I;</span><br><span class="line">            temp-&gt;col = J;</span><br><span class="line">            temp-&gt;element = result;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入一个新的元素到下一个位置</span></span><br><span class="line">            RowNext-&gt;right = temp;</span><br><span class="line">            RowNext = RowNext-&gt;right;</span><br><span class="line">            <span class="comment">//调转到合适的位置</span></span><br><span class="line">            <span class="keyword">while</span> (ColNext-&gt;down != <span class="literal">NULL</span>)</span><br><span class="line">                ColNext = ColNext-&gt;down;</span><br><span class="line">            ColNext-&gt;down = temp;</span><br><span class="line">            ColNext = ColNext-&gt;down;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//计算出一个元素，放入ResultMatrix</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/////////////////乘法做完，生成新的矩阵</span></span><br><span class="line">    <span class="keyword">return</span> ResultMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广义表的链表实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM 0  <span class="comment">//表中存储的是原子元素</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST 1  <span class="comment">//表中存储的是子表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD -1  <span class="comment">//是否是表头结点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1  <span class="comment">//已经访问过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0  <span class="comment">//未访问过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKTRACE 1  <span class="comment">//需要回溯</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTBACKTRACE 0  <span class="comment">//不需要回溯</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxName 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广义表的结点类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> type;   <span class="comment">//表示该结点是ATOM or LIST</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> ref;   <span class="comment">//如果是表头结点则，存储该结点被几个结点所指向</span></span><br><span class="line">            <span class="keyword">char</span> *Name;  <span class="comment">// 表头名称</span></span><br><span class="line">            <span class="keyword">int</span> mark;   <span class="comment">// 本子表是否被访问过</span></span><br><span class="line">        &#125; headNode;</span><br><span class="line">        GenListNode&lt;T&gt; *child;<span class="comment">//如果是LIST ,则指向它的元素的首结点</span></span><br><span class="line">        T element; <span class="comment">//如果是ATOM，则存储它的值</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    GenListNode&lt;T&gt; *next;<span class="comment">//指向下一个结点</span></span><br><span class="line">    GenListNode(T element);<span class="comment">//构造函数</span></span><br><span class="line">    GenListNode();</span><br><span class="line"></span><br><span class="line">    GenListNode(GenListNode&lt;T&gt; *<span class="built_in">list</span>);<span class="comment">//</span></span><br><span class="line">    ~GenListNode();<span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destory</span><span class="params">(GenListNode&lt;T&gt; *node)</span></span>;<span class="comment">//释放所有内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ViewAll</span><span class="params">()</span></span>;<span class="comment">//遍历该结点的子孙和兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenListTraversal</span><span class="params">()</span></span>;<span class="comment">//遍历该结点的子孙和兄弟，张铭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(GenListNode&lt;T&gt; *node, GenListNode&lt;T&gt; *prenode, <span class="keyword">int</span> &amp;flag)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenListTraversalHelp</span><span class="params">(GenListNode&lt;T&gt; *node)</span></span>;  <span class="comment">// 张铭</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//GenList是一个原子元素类型为T的广义表</span></span><br><span class="line"><span class="comment">//如果要实现能够存储多种数据类型的广义</span></span><br><span class="line"><span class="comment">//表，只需要嵌套的使用它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GenListNode&lt;T&gt; *head;<span class="comment">//整个广义表的头结点,不存储任何信息</span></span><br><span class="line">    GenListNode&lt;T&gt; *current;<span class="comment">//当前指针的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    GenList(<span class="keyword">char</span> *Name);</span><br><span class="line"></span><br><span class="line">    ~GenList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T element)</span></span>;<span class="comment">//在尾部加入一个元素结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(GenList&lt;T&gt; *gl)</span></span>;<span class="comment">//在尾部插入一个子表</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetHead</span><span class="params">()</span></span>;<span class="comment">//得到头结点的指针</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetNext</span><span class="params">()</span></span>;<span class="comment">//得到当前结点的下一个结点</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetPrev</span><span class="params">()</span></span>;<span class="comment">//得到当前结点的前一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveToFirst</span><span class="params">()</span></span>;<span class="comment">//当前指针指向head</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Remove</span><span class="params">()</span></span>;<span class="comment">//删除当前结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">View</span><span class="params">()</span></span>;<span class="comment">//遍历广义表，伍赛</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ViewList</span><span class="params">()</span></span>;<span class="comment">//遍历广义表, 张铭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广义表的类实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GenList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//GenListNode的构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">GenListNode&lt;T&gt;::GenListNode(GenListNode&lt;T&gt; *list)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	//</span></span><br><span class="line"><span class="comment">	type=LIST;</span></span><br><span class="line"><span class="comment">    child=list;</span></span><br><span class="line"><span class="comment">	next=NULL;</span></span><br><span class="line"><span class="comment">	mark=0;</span></span><br><span class="line"><span class="comment">	ref=0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">GenListNode&lt;T&gt;::GenListNode(T element)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	    type=ATOM;</span></span><br><span class="line"><span class="comment">		child=NULL;</span></span><br><span class="line"><span class="comment">		this-&gt;element=element;</span></span><br><span class="line"><span class="comment">		next=NULL;</span></span><br><span class="line"><span class="comment">		mark=0;</span></span><br><span class="line"><span class="comment">		ref=0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt;::GenListNode() &#123;</span><br><span class="line">    type = LIST;</span><br><span class="line">    child = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GenListNode的析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt;::~GenListNode() &#123;</span><br><span class="line">    <span class="comment">//free all the memery </span></span><br><span class="line">    Destroy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::Destory(GenListNode&lt;T&gt; *node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        Destroy(node-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;child != <span class="literal">NULL</span>)</span><br><span class="line">        Destroy(node-&gt;child);</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">void GenListNode&lt;T&gt;::Search(GenListNode&lt;T&gt; *node,GenListNode&lt;T&gt; *prenode,int &amp;flag) </span></span><br><span class="line"><span class="comment">&#123;   //flag 为回溯标志</span></span><br><span class="line"><span class="comment">	if (node-&gt;type==HEAD)	&#123;//进入一个表头结点，准备访问它的子表</span></span><br><span class="line"><span class="comment">		node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		Search(node-&gt;next,node,flag);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	else	&#123;//非表头结点，访问每一个element结点</span></span><br><span class="line"><span class="comment">      if (node-&gt;type==ATOM) &#123;</span></span><br><span class="line"><span class="comment">		cout&lt;&lt;node-&gt;element;</span></span><br><span class="line"><span class="comment">		node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">	    &#125; </span></span><br><span class="line"><span class="comment">      else if(node-&gt;type==LIST) &#123;</span></span><br><span class="line"><span class="comment">			node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">			cout&lt;&lt;&quot;(&quot;;</span></span><br><span class="line"><span class="comment">			Search(node-&gt;child,node,flag);</span></span><br><span class="line"><span class="comment">			cout&lt;&lt;&quot;)&quot;;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">      if((node-&gt;next!=NULL)&amp;&amp;(node-&gt;next-&gt;mark!=VISITED)) &#123;//没有访问过，则继续访问</span></span><br><span class="line"><span class="comment">		  cout&lt;&lt;&quot;,&quot;;</span></span><br><span class="line"><span class="comment">		  node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		  Search(node-&gt;next,node,flag);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	  else if((node-&gt;next!=NULL)&amp;&amp;(node-&gt;type==ATOM))  //否则访问过，回溯</span></span><br><span class="line"><span class="comment">		      flag=BACKTRACE; //mark==VISITED，需要进行回溯</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	  if(flag==BACKTRACE)	&#123;//回溯操作</span></span><br><span class="line"><span class="comment">		  node-&gt;mark=UNVISITED;</span></span><br><span class="line"><span class="comment">		  if(prenode==NULL) 	&#123;//回溯到第一个结点，结束</span></span><br><span class="line"><span class="comment">			 flag=NOTBACKTRACE;</span></span><br><span class="line"><span class="comment">			 return;</span></span><br><span class="line"><span class="comment">		  &#125;</span></span><br><span class="line"><span class="comment">		  if((prenode-&gt;child=node)&amp;&amp;(prenode-&gt;next!=NULL)&amp;&amp;(prenode-&gt;next-&gt;mark==0)) &#123;//回溯到可以进入其他子链的地方</span></span><br><span class="line"><span class="comment">			 flag=NOTBACKTRACE;</span></span><br><span class="line"><span class="comment">			 return;</span></span><br><span class="line"><span class="comment">		  &#125;</span></span><br><span class="line"><span class="comment">	   &#125;	</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	//将刚才进入子链的mark值重新置为UNVISITED</span></span><br><span class="line"><span class="comment">	GenListNode&lt;T&gt;*temp=node;</span></span><br><span class="line"><span class="comment">	while(temp!=NULL)	&#123;</span></span><br><span class="line"><span class="comment">		temp-&gt;mark=UNVISITED;</span></span><br><span class="line"><span class="comment">		temp=temp-&gt;next;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::GenListTraversalHelp(GenListNode&lt;T&gt; *node) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *p;</span><br><span class="line">    node-&gt;headNode.mark = VISITED;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = node-&gt;next; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//p-&gt;mark=VISITED;</span></span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;type == LIST) &amp;&amp; (p-&gt;child != <span class="literal">NULL</span>)) &#123;    <span class="comment">//进入一个表头结点，准备访问它的子表</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;child-&gt;headNode.Name;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;child-&gt;headNode.mark == UNVISITED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;child-&gt;headNode.Name[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">                GenListTraversalHelp(p-&gt;child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;type == ATOM)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;element;</span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;next-&gt;type != HEAD))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">void GenListNode&lt;T&gt;::GenListTraversalHelp(GenListNode&lt;T&gt; *node) </span></span><br><span class="line"><span class="comment">&#123;   //flag 为回溯标志</span></span><br><span class="line"><span class="comment">	GenListNode&lt;T&gt; *p;</span></span><br><span class="line"><span class="comment">	node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;(&quot;;</span></span><br><span class="line"><span class="comment">	for (p = node-&gt;next; (p!=NULL)&amp;&amp;(p-&gt;type!=HEAD); p=p-&gt;next) &#123;</span></span><br><span class="line"><span class="comment">		p-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		if ((p-&gt;type==LIST)&amp;&amp;(p-&gt;child!=NULL)) &#123;	//进入一个表头结点，准备访问它的子表</span></span><br><span class="line"><span class="comment">			   cout &lt;&lt; p-&gt;child-&gt;headNode.Name;</span></span><br><span class="line"><span class="comment">			   if (p-&gt;child-&gt;mark == UNVISITED)  &#123;</span></span><br><span class="line"><span class="comment">				  if (p-&gt;child-&gt;headNode.Name[0]!=&#x27;\0&#x27;)</span></span><br><span class="line"><span class="comment">				  cout &lt;&lt;&quot;:&quot;;	</span></span><br><span class="line"><span class="comment">			      GenListTraversalHelp(p-&gt;child);</span></span><br><span class="line"><span class="comment">			   &#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else if (p-&gt;type==ATOM) </span></span><br><span class="line"><span class="comment">		    cout&lt;&lt;p-&gt;element;</span></span><br><span class="line"><span class="comment">		if ((p-&gt;next!=NULL)&amp;&amp;(p-&gt;next-&gt;type!=HEAD))</span></span><br><span class="line"><span class="comment">		    cout &lt;&lt; &quot;, &quot;;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;)&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::ViewAll() &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = NOTBACKTRACE;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    GenListTraversal(<span class="keyword">this</span>, <span class="literal">NULL</span>, flag);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广义表的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenList&lt;T&gt;::GenList(<span class="keyword">char</span> *Name) &#123;</span><br><span class="line">    head = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;type = HEAD;</span><br><span class="line">    head-&gt;headNode.ref = <span class="number">0</span>;</span><br><span class="line">    head-&gt;headNode.Name = Name;</span><br><span class="line">    current = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//广义表的插入函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::Insert(T element) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    current = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    current-&gt;type = ATOM;</span><br><span class="line">    current-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;element = element;</span><br><span class="line">    temp-&gt;next = current;</span><br><span class="line">    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::Insert(GenList&lt;T&gt; *genlist) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    GenListNode&lt;T&gt; *n = genlist-&gt;GetHead();</span><br><span class="line">    n-&gt;headNode.mark = UNVISITED;</span><br><span class="line">    n-&gt;headNode.ref++;</span><br><span class="line">    current = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    current-&gt;child = n;</span><br><span class="line">    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;type = LIST;</span><br><span class="line">    temp-&gt;next = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到头指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetHead() &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到下一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetNext() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到当前结点的前一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetPrev() &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == current)</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除当前结点,当前结点指针指向下一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> GenList&lt;T&gt;::Remove() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (current == head)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    GenListNode&lt;T&gt; *prev = GetPrev();</span><br><span class="line">    GenListNode&lt;T&gt; *next = GetNext();</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>)</span><br><span class="line">        current = prev;</span><br><span class="line">    <span class="keyword">else</span> current = next;</span><br><span class="line">    temp-&gt;Destory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move current point to head point</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::MoveToFirst() &#123;</span><br><span class="line">    current = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenList&lt;T&gt;::~GenList() &#123;</span><br><span class="line">    current = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (current != head)</span><br><span class="line">        Remove();</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::View() &#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;(&quot;;</span></span><br><span class="line">    MoveToFirst();</span><br><span class="line"><span class="comment">//	GenListNode&lt;T&gt; *temp=GetNext();</span></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    current-&gt;ViewAll();</span><br><span class="line">    <span class="comment">//temp=GetNext();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;)&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::ViewList() &#123;</span><br><span class="line">    MoveToFirst();</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    current-&gt;GenListTraversal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::GenListTraversal() &#123;</span><br><span class="line">    GenListTraversalHelp(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
