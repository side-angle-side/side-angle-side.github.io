<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++程序设计笔记</title>
    <url>/2020/12/28/fundamentals-of-Cpp-programming-and-algorithms/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/12/28/fundamentals-of-Cpp-programming-and-algorithms/IMG_20201223_235334.jpg">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">为了做这句话，我还学了一点HTML。</div>
</center>


<a id="more"></a>



<h2 id="一-从C到C"><a href="#一-从C到C" class="headerlink" title="一    从C到C++"></a>一    从C到C++</h2><h3 id="1-1-C-语言的历史"><a href="#1-1-C-语言的历史" class="headerlink" title="1.1    C++语言的历史"></a>1.1    C++语言的历史</h3><p>1983年诞生的C++对C语言的改进包括面向对象、虚函数、函数和运算符重载、引用等。1989年推出的C++2.0实现了多重继承、抽象类、静态成员、常量成员函数等功能。1990年加入了模板、异常处理、命名空间等机制。1998年诞生的C++98加入了标准模板库（STL），C++从此实现了泛型程序设计。2011年发布的C++11标准支持正则表达式、哈希表以及其他一系列重要的功能。当前最新的C++标准是C++20。</p>
<h3 id="1-2-输入输出"><a href="#1-2-输入输出" class="headerlink" title="1.2    输入输出"></a>1.2    输入输出</h3><p>C++使用<code>cin</code>和<code>cout</code>实现输入输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-头文件"><a href="#1-3-头文件" class="headerlink" title="1.3    头文件"></a>1.3    头文件</h3><p>C++头文件不再以”.h”结尾，常用的C++头文件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;		//标准输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;		//STL 通用算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;		//参数化输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;			//定义数学函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;		//字符串处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;			//定义关于时间的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;		//STL 动态数组容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;			//STL 队列容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;			//STL 堆栈容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;		//字符串类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;		//文件输入／输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;			//STL 集合容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;			//STL 映射容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;		//定义杂项函数及内存分配函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;		//STL 通用模板类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;		//基于字符串的流</span></span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-强制类型转换"><a href="#1-4-强制类型转换" class="headerlink" title="1.4    强制类型转换"></a>1.4    强制类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="number">3.5</span>);	<span class="comment">//C++通常写成类似函数调用的格式</span></span><br><span class="line"><span class="keyword">double</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span>(a);</span><br><span class="line">(<span class="keyword">int</span>)<span class="number">3.5</span>;	<span class="comment">//传统的C格式</span></span><br><span class="line">(<span class="keyword">double</span>)<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-函数参数的默认值"><a href="#1-5-函数参数的默认值" class="headerlink" title="1.5    函数参数的默认值"></a>1.5    函数参数的默认值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">(<span class="keyword">int</span> x=<span class="number">20</span>)</span></span>;	<span class="comment">//函数声明，x默认为20</span></span><br><span class="line">Function1();				<span class="comment">//函数调用，等效于Function(20);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用表达式作为函数的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y=Max(a,b),<span class="keyword">int</span> z=a*b)</span><span class="comment">//函数定义处也可以写参数的默认值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Function2(<span class="number">4</span>);		<span class="comment">//Function2(4,Max(a,b),a*b)</span></span><br><span class="line">Function2(<span class="number">4</span>,<span class="number">9</span>);		<span class="comment">//Function2(4,9,a*b);</span></span><br><span class="line">Function2(<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Function2(<span class="number">4</span>,,<span class="number">3</span>);	<span class="comment">//报错，省略的参数一定是最右边连续的几个</span></span><br></pre></td></tr></table></figure>
<h3 id="1-6-引用和函数参数的传递"><a href="#1-6-引用和函数参数的传递" class="headerlink" title="1.6    引用和函数参数的传递"></a>1.6    引用和函数参数的传递</h3><h4 id="1-6-1-引用"><a href="#1-6-1-引用" class="headerlink" title="1.6.1    引用"></a>1.6.1    引用</h4><p>引用某个变量相当于某个变量的别名。<strong>定义引用时必须初始化，通常用某个变量初始化引用。</strong>引用初始化后会一直引用该变量，不会引用别的变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>&amp; r=n;</span><br></pre></td></tr></table></figure>
<p>修改变量的值，引用的值也会修改。修改引用的值，变量的值也会修改。多个不同的引用可以引用同一变量。</p>
<h4 id="1-6-2-引用作为函数返回值"><a href="#1-6-2-引用作为函数返回值" class="headerlink" title="1.6.2    引用作为函数返回值"></a>1.6.2    引用作为函数返回值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">SetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetValue()=<span class="number">40</span>;		<span class="comment">//返回引用的函数表达式可作为左值使用，等效于n=40;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; r=SetValue();	<span class="comment">//r为n的引用，r=40；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-3-值传递和引用传递"><a href="#1-6-3-值传递和引用传递" class="headerlink" title="1.6.3    值传递和引用传递"></a>1.6.3    值传递和引用传递</h4><p>函数传参的形式有两种，一是值传递，二是引用传递。值传递形参是实参的拷贝，形参改变不影响实参。在函数调用过程中，实参的值会被复制到栈中，函数执行过程中对形参的改变只是修改了实参的拷贝，不修改实参。如果函数的形参是引用，那么形参的改变会影响实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//错误</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span><span class="comment">//正确</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-4-常引用"><a href="#1-6-4-常引用" class="headerlink" title="1.6.4    常引用"></a>1.6.4    常引用</h4><p>加上<code>const</code>关键字的引用称为常引用。<strong>不能通过常引用修改其引用的内容。</strong>常引用的类型为<code>const T&amp;</code>。引用和变量可以初始化常引用，但常变量和常引用不能初始化引用，除非进行强制类型转换。</p>
<h3 id="1-7-内联函数"><a href="#1-7-内联函数" class="headerlink" title="1.7    内联函数"></a>1.7    内联函数</h3><p>进行函数调用时，首先要在栈中开辟形参和局部变量的存储空间，接着把实参的值复制给形参，然后把函数返回地址放入栈中，最后跳转至函数内部执行。函数调用结束时，需要从栈中回收形参和局部变量的空间，取出返回地址才能跳转到该地址继续执行。如果一个函数语句很简单，执行时间很短，又经常被调用，函数调用带来的时间开销就非常大。因此在返回值前加上<code>inline</code>关键字，成为内联函数，编译器编译时就不会将该语句编译成调用指令，而是直接插入代码。这样既可以实现代码复用，又不会造成函数调用的额外开销。调用内联函数前必须出现内联函数的定义而不仅是其声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-函数重载"><a href="#1-8-函数重载" class="headerlink" title="1.8    函数重载"></a>1.8    函数重载</h3><p>多个函数名字相同但参数表不同称为函数重载。编译器可以通过函数调用语句中实参的个数和类型确定应该调用哪个函数。常见的一种重载编译出错是二义性错误。仅返回值不同的函数是重复定义，不是重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Max 1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Max 2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sum 1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sum 2&quot;</span>&lt;&lt;end</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Max(<span class="number">3</span>,<span class="number">1.5</span>);		<span class="comment">//二义性错误</span></span><br><span class="line">    Sum(<span class="number">1</span>,<span class="number">2</span>);		<span class="comment">//二义性错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-9-指针和动态内存分配"><a href="#1-9-指针和动态内存分配" class="headerlink" title="1.9    指针和动态内存分配"></a>1.9    指针和动态内存分配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[n];	<span class="comment">//编译出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>;	<span class="comment">//动态分配4byte的内存空间</span></span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>* pn=<span class="keyword">new</span> <span class="keyword">int</span>[i*<span class="number">20</span>];	<span class="comment">//动态分配i*20*sizeof(int)byte的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> p;	<span class="comment">//动态分配的内存空间使用完后应当释放，但不能重复delete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> []p;		<span class="comment">//释放动态分配的数组内存</span></span><br></pre></td></tr></table></figure>
<h3 id="1-10-string对象"><a href="#1-10-string对象" class="headerlink" title="1.10    string对象"></a>1.10    string对象</h3><p><code>string</code>是标准模板库中的一个类，需要包含头文件<code>string</code>。处理字符串优先考虑使用<code>string</code>类。<code>string</code>对象只存放字符串地址而不直接存放字符串。</p>
<h4 id="1-10-1-string对象的定义、输入输出和赋值"><a href="#1-10-1-string对象的定义、输入输出和赋值" class="headerlink" title="1.10.1    string对象的定义、输入输出和赋值"></a>1.10.1    string对象的定义、输入输出和赋值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> str1;			<span class="comment">//没有初始化的值为空串&quot;&quot;</span></span><br><span class="line"><span class="built_in">string</span> city=<span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> as[]=&#123;<span class="string">&quot;Beijing&quot;</span>,<span class="string">&quot;Shanghai&quot;</span>,<span class="string">&quot;Chengdu&quot;</span>&#125;;	<span class="comment">//string数组</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;as[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><code>string</code>可以互相赋值，也可以用<code>char[]</code>赋值。</p>
<h4 id="1-10-2-string的运算"><a href="#1-10-2-string的运算" class="headerlink" title="1.10.2    string的运算"></a>1.10.2    string的运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;abc&quot;</span>,s3;	<span class="comment">//s3==&quot;&quot;</span></span><br><span class="line">s3=s1+s2;						<span class="comment">//s3==&quot;123abc&quot;</span></span><br><span class="line">s3+=<span class="string">&quot;de&quot;</span>;						<span class="comment">//s3==&quot;123abcde&quot;</span></span><br><span class="line"><span class="keyword">bool</span> b=s1&lt;s3;					<span class="comment">//b==true</span></span><br><span class="line"><span class="keyword">char</span> c=s1[<span class="number">2</span>];					<span class="comment">//c==&#x27;3&#x27;</span></span><br><span class="line">s1[<span class="number">2</span>]=<span class="string">&#x27;5&#x27;</span>;						<span class="comment">//s1=&quot;125&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-10-3-string类的使用"><a href="#1-10-3-string类的使用" class="headerlink" title="1.10.3    string类的使用"></a>1.10.3    string类的使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;abcdef&quot;</span>,s3;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1.size()&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2.substr(<span class="number">1</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//bcd</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">s3=s1+s2;</span><br><span class="line"><span class="built_in">strcpy</span>(str,s3.c_str());			<span class="comment">//123abcdef</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="二-类和对象初步"><a href="#二-类和对象初步" class="headerlink" title="二    类和对象初步"></a>二    类和对象初步</h2><h3 id="2-1-结构化程序设计的不足"><a href="#2-1-结构化程序设计的不足" class="headerlink" title="2.1    结构化程序设计的不足"></a>2.1    结构化程序设计的不足</h3><p>结构化程序设计也称为面向过程的程序设计，过程用函数实现，因此设计时就要考虑如何把功能分割成一个个函数，不同函数互相调用，每个函数实现各自的功能。结构化程序设计难免会使用一些全局变量，这些变量往往被很多函数访问或修改，这样的程序在规模庞大的情况下就难以进行理解和维护。随着软件规模不断扩大，结构化程序设计已经难以适应开发大型软件的需要，面向对象的程序设计便应运而生。</p>
<h3 id="2-2-面向对象程序设计的概念和特点"><a href="#2-2-面向对象程序设计的概念和特点" class="headerlink" title="2.2    面向对象程序设计的概念和特点"></a>2.2    面向对象程序设计的概念和特点</h3><p><strong>面向对象的程序设计的基本特点是抽象、封装、继承、多态。</strong></p>
<p>抽象指把同一类事物的共同特点概括出来。对象的特点包括属性和方法。属性指对象的静态特征，可以用变量表示。方法指对象的行为，可以用函数表示。方法可以对属性进行操作。完成抽象后将数据和操作数据的算法组合在一起，形成形式上的整体，叫做“类”，这个过程称为封装。封装可以把对象的一部分属性和方法隐藏起来，对外界不可见，这样可以减少程序不同部分的耦合度，提高代码扩充修改和复用的效率。继承机制就是在编写一个类时以现有的类作为基础，利用派生达到代码复用的目的 。多态则指的是不同种类的对象具有相同名称的行为，但实现方式有所不同。</p>
<h3 id="2-3-类的定义和使用"><a href="#2-3-类的定义和使用" class="headerlink" title="2.3    类的定义和使用"></a>2.3    类的定义和使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>							//类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:								<span class="comment">//访问范围说明符</span></span><br><span class="line">    <span class="keyword">int</span> a;								<span class="comment">//成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func1</span><span class="params">()</span>							<span class="comment">//成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;								<span class="comment">//成员变量和成员函数的先后次序没有规定</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> b)</span>						<span class="comment">//成员函数可以互相调用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b=Func1();</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>;			<span class="comment">//成员函数可以重载，也可以设定参数默认值</span></span><br><span class="line">&#125;;										<span class="comment">//以“；”结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Myclass::Func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>;	<span class="comment">//成员函数实现可位于类定义以外</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">Myclass m;									<span class="comment">//定义某个类的对象</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-类的示例"><a href="#2-4-类的示例" class="headerlink" title="2.4    类的示例"></a>2.4    类的示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">perimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRectangle::init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w=w_;</span><br><span class="line">    h=h_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRectangle::area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Crectangle::perimeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    return2*(w+h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    CRectangle r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;w&gt;&gt;h;</span><br><span class="line">    r.init(w,h);									<span class="comment">//访问成员函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;It&#x27;s area is &quot;</span>&lt;&lt;r.area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;It&#x27;s perimeter is &quot;</span>&lt;&lt;r.perimeter()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(CRectangle)&lt;&lt;<span class="built_in">endl</span>;						<span class="comment">//对象占用内存空间大小等于各成员变量占用内存空间大小之和，输出8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-访问对象的成员"><a href="#2-5-访问对象的成员" class="headerlink" title="2.5    访问对象的成员"></a>2.5    访问对象的成员</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r1.r2;</span><br><span class="line">CRectangle* p1=&amp;r1;</span><br><span class="line">CRectangle* p2=&amp;r2;</span><br><span class="line">p1-&gt;w=<span class="number">5</span>;</span><br><span class="line">p2-&gt;init(<span class="number">5</span>,<span class="number">4</span>);			<span class="comment">//使用指针-&gt;成员名访问成员</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRectangle&amp; rr=r2;</span><br><span class="line">rr.w=<span class="number">5</span>;</span><br><span class="line">rr.init(<span class="number">5</span>,<span class="number">4</span>);			<span class="comment">//使用引用名.成员名访问对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CRectangle</span>		//用<span class="keyword">struct</span>表示类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没有成员函数的<code>struct</code>还是称为结构。对象可以使用”=“赋值，但不能进行比较运算。</p>
<h3 id="2-6-类成员的可访问范围"><a href="#2-6-类成员的可访问范围" class="headerlink" title="2.6    类成员的可访问范围"></a>2.6    类成员的可访问范围</h3><h4 id="2-6-1-private和public访问范围说明符"><a href="#2-6-1-private和public访问范围说明符" class="headerlink" title="2.6.1    private和public访问范围说明符"></a>2.6.1    private和public访问范围说明符</h4><p>private用来指定私有成员，私有成员只有在该类的成员函数内部才能访问。public用来指定公有成员，公有成员可以在任何地方访问。protected用来指定保护成员。三种关键字次数和顺序没有限制。若成员没有访问范围说明符，对于class类默认为私有成员，对于struct类默认为公有成员。</p>
<h4 id="2-6-2-“隐藏”的作用"><a href="#2-6-2-“隐藏”的作用" class="headerlink" title="2.6.2    “隐藏”的作用"></a>2.6.2    “隐藏”的作用</h4><p>隐藏强制对成员变量的访问通过成员函数进行，如果未来修改了成员变量类型等属性，只需修改成员函数即可。隐藏还可以避免对对象的不正确操作。</p>
<h2 id="三-类和对象进阶"><a href="#三-类和对象进阶" class="headerlink" title="三    类和对象进阶"></a>三    类和对象进阶</h2><h3 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1    构造函数"></a>3.1    构造函数</h3><h4 id="3-1-1-构造函数的概念和作用"><a href="#3-1-1-构造函数的概念和作用" class="headerlink" title="3.1.1    构造函数的概念和作用"></a>3.1.1    构造函数的概念和作用</h4><p>面向对象的程序设计语言倾向于对象一定要经过初始化后使用起来才比较安全。因此引入构造函数的概念，用于对对象进行初始化。一个类可以有多个构造函数，如果没有写构造函数，编译器会自动生成一个默认的无参构造函数，该函数什么都不做。如果编写了构造函数，就不会再生成默认构造函数。对象生成时一定会调用某个构造函数进行初始化，一旦生成就再也不会执行构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c;						<span class="comment">//无参构造函数</span></span><br><span class="line">Complex* p=<span class="keyword">new</span> Complex;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i=<span class="number">0</span>);			<span class="comment">//构造函数是特殊的成员函数，名字和类名一样，不写返回值，可以重载</span></span><br><span class="line">&#125;;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)				<span class="comment">//构造函数1</span></span><br><span class="line">&#123;</span><br><span class="line">    real=r;</span><br><span class="line">    imag=i;</span><br><span class="line">&#125;</span><br><span class="line">Complex::Complex(Complex c1,Complex c2)			<span class="comment">//构造函数2</span></span><br><span class="line">&#123;</span><br><span class="line">    real=c1.real+c2.real;</span><br><span class="line">    imag=c1.imag+c2.imag;</span><br><span class="line">&#125;</span><br><span class="line">Complex c1;									<span class="comment">//错误，没有无参构造函数</span></span><br><span class="line">Complex* pc=<span class="keyword">new</span> Complex;					<span class="comment">//错误</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2</span>)</span></span>;								<span class="comment">//正确，相当于Complex c2(2,0);</span></span><br><span class="line">Complex c3(2,4),c4(3,5);					//正确</span><br><span class="line">Complex* pc2=<span class="keyword">new</span> Complex(<span class="number">3</span>,<span class="number">4</span>);					<span class="comment">//正确</span></span><br><span class="line"><span class="function">Complex <span class="title">c5</span><span class="params">(c3,c4)</span></span>;							<span class="comment">//正确，使用构造函数2</span></span><br><span class="line">Complex c6=<span class="number">5</span>;								<span class="comment">//正确，使用构造函数1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-构造函数在数组中的使用"><a href="#3-1-2-构造函数在数组中的使用" class="headerlink" title="3.1.2    构造函数在数组中的使用"></a>3.1.2    构造函数在数组中的使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest(<span class="keyword">int</span> n)&#123;&#125;			<span class="comment">//构造函数1</span></span><br><span class="line">    CTest(<span class="keyword">int</span> n,<span class="keyword">int</span> m)&#123;&#125;	<span class="comment">//构造函数2</span></span><br><span class="line">    CTest()&#123;&#125;				<span class="comment">//构造函数3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest array1[<span class="number">3</span>]=&#123;<span class="number">1</span>,CTest(<span class="number">1</span>,<span class="number">2</span>)&#125;;					<span class="comment">//1，2，3</span></span><br><span class="line">    CTest array2[<span class="number">3</span>]=&#123;CTest(<span class="number">2</span>,<span class="number">3</span>),CTest(<span class="number">1</span>,<span class="number">2</span>),<span class="number">1</span>&#125;;		<span class="comment">//2，2，1</span></span><br><span class="line">    CTest* pArray[<span class="number">3</span>]=&#123;<span class="keyword">new</span> CTest(<span class="number">4</span>),<span class="keyword">new</span> CTest(<span class="number">1</span>,<span class="number">2</span>)&#125;;		<span class="comment">//1，2，只生成了两个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-复制构造函数"><a href="#3-1-3-复制构造函数" class="headerlink" title="3.1.3    复制构造函数"></a>3.1.3    复制构造函数</h4><h5 id="1-复制构造函数的概念"><a href="#1-复制构造函数的概念" class="headerlink" title="1.复制构造函数的概念"></a>1.复制构造函数的概念</h5><p>复制构造函数是构造函数的一种，它只有一个该类的引用作为参数。引用可以是const引用，也可以是非const引用，一般使用前者。默认构造函数不一定存在，但复制构造函数总是存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;		<span class="comment">//用复制构造函数初始化c2</span></span><br></pre></td></tr></table></figure>
<p>构造函数不能以本类的对象作为唯一参数。</p>
<h5 id="2-复制构造函数被调用的三种情况"><a href="#2-复制构造函数被调用的三种情况" class="headerlink" title="2.复制构造函数被调用的三种情况"></a>2.复制构造函数被调用的三种情况</h5><ul>
<li>用一个对象初始化同类的另一个对象</li>
<li>作为形参的对象用复制构造函数初始化，复制构造函数的参数就是调用函数时的实参。</li>
<li>作为函数返回值的对象用复制构造函数初始化，复制构造函数的参数就是return语句返回的对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2=c1;		<span class="comment">//只有初始化语句才能调用复制构造函数</span></span><br><span class="line">c2=c1;				<span class="comment">//赋值语句不能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(A&amp; a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">(A a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function">A <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    Func1(a);		<span class="comment">//调用复制构造函数</span></span><br><span class="line">    Func2();		<span class="comment">//调用复制构造函数</span></span><br><span class="line">    Func3(a);		<span class="comment">//通过引用避免了复制构造函数，同时保证实参的值不会改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-4-类型转换构造函数"><a href="#3-1-4-类型转换构造函数" class="headerlink" title="3.1.4    类型转换构造函数"></a>3.1.4    类型转换构造函数</h4><p>除复制构造函数外，只有一个参数的构造函数称为类型转换构造函数，这样的构造函数能起到自动类型转换的作用。类型转换构造函数可以在初始化语句和赋值语句被调用。处理赋值语句时，编译器往往会把在等号右侧生成一个临时对象，再赋值给等号左侧。</p>
<h3 id="3-2-析构函数"><a href="#3-2-析构函数" class="headerlink" title="3.2    析构函数"></a>3.2    析构函数</h3><p>析构函数用于对象消亡前的善后工作，在对象消亡时自动调用。例如在析构函数中调用delete语句即可确保对象运行时动态分配的内存空间被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~Cdemo()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDemo <span class="built_in">array</span>[<span class="number">2</span>];			<span class="comment">//构造函数调用2次</span></span><br><span class="line">    CDemo* pTest=<span class="keyword">new</span> CDemo;	<span class="comment">//构造函数调用</span></span><br><span class="line">    <span class="keyword">delete</span> pTest;			<span class="comment">//析构函数调用</span></span><br><span class="line">    pTest=<span class="keyword">new</span> CDemo[<span class="number">2</span>];		<span class="comment">//构造函数调用2次</span></span><br><span class="line">    <span class="keyword">delete</span> []pTest;			<span class="comment">//析构函数调用2次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;				<span class="comment">//析构函数调用2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数对象和作为函数返回值的对象消亡时也会引发析构函数调用。</p>
<h3 id="3-3-构造函数、析构函数和变量的生存期"><a href="#3-3-构造函数、析构函数和变量的生存期" class="headerlink" title="3.3    构造函数、析构函数和变量的生存期"></a>3.3    构造函数、析构函数和变量的生存期</h3><p>全局对象在进入main函数前形成，直到程序结束消亡。临时对象在语句执行完毕后消亡，局部对象在初始化时生成，在最近的大括号处消亡。含static关键字的静态局部对象相当于全局对象。</p>
<h3 id="3-4-静态成员变量和静态成员函数"><a href="#3-4-静态成员变量和静态成员函数" class="headerlink" title="3.4    静态成员变量和静态成员函数"></a>3.4    静态成员变量和静态成员函数</h3><p>静态成员变量和静态成员函数加了<code>static</code>关键字，静态成员变量被所有同类对象共享，静态成员函数并不具体作用在某个对象上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> w, h;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> totalArea;			<span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> totalNumber;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span>		<span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;								<span class="comment">//静态成员函数不能访问非静态成员变量，也不能调用非静态成员函数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; totalNumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; totalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CRectangle(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span><br><span class="line">	&#123;</span><br><span class="line">		w = w_;</span><br><span class="line">		h = h_;</span><br><span class="line">		totalNumber++;</span><br><span class="line">		totalArea += w * h;</span><br><span class="line">	&#125;</span><br><span class="line">	CRectangle(CRectangle&amp; r)		<span class="comment">//有些对象用复制构造函数初始化，需要编写专门的复制构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		totalNumber++;</span><br><span class="line">		totalArea += r.w * r.h;</span><br><span class="line">		w = r.w;</span><br><span class="line">		h = r.h;</span><br><span class="line">	&#125;</span><br><span class="line">	~CRectangle()</span><br><span class="line">	&#123;</span><br><span class="line">		totalNumber--;</span><br><span class="line">		totalArea -= w * h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> CRectangle::totalArea = <span class="number">0</span>;			<span class="comment">//必须对静态成员变量做声明或初始化</span></span><br><span class="line"><span class="keyword">int</span> CRectangle::totalNumber = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRectangle r1(3, 3), r2(2, 2);</span><br><span class="line">	CRectangle::PrintTotal();</span><br><span class="line">	r1.PrintTotal();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-常量对象和常量成员函数"><a href="#3-5-常量对象和常量成员函数" class="headerlink" title="3.5    常量对象和常量成员函数"></a>3.5    常量对象和常量成员函数</h3><p>定义时加<code>const</code> 的对象和成员函数称为常量对象和常量成员函数，常量对象初始化后就再也不被改变，常量对象不能调用普通成员函数，但可以调用常量成员函数，常量成员函数不会修改任何非静态成员变量的值，也不允许调用其他非常量成员函数，但静态成员函数除外。两个名字和参数表不同的一个带const一个不带的函数算重载。如果一个成员函数没有调用非常量成员函数也没有修改成员变量，那么应写成常量成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest()&#123;n=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> n;&#125;			<span class="comment">//常量成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*n;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CTest o1;							<span class="comment">//常量对象</span></span><br><span class="line">    CTest o2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;o1.GetValue()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;o2.GetValue();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-成员对象和封闭类"><a href="#3-6-成员对象和封闭类" class="headerlink" title="3.6    成员对象和封闭类"></a>3.6    成员对象和封闭类</h3><h4 id="3-6-1-封闭类构造函数的初始化列表"><a href="#3-6-1-封闭类构造函数的初始化列表" class="headerlink" title="3.6.1    封闭类构造函数的初始化列表"></a>3.6.1    封闭类构造函数的初始化列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTyre(<span class="keyword">int</span> r,<span class="keyword">int</span> w):radius(r),width(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>			//包含成员对象的类称为封闭类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    Ctyre tyre;		<span class="comment">//成员对象</span></span><br><span class="line">    CEngine engine;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar(<span class="keyword">int</span> p,<span class="keyword">int</span> tr,<span class="keyword">int</span> tw):price(p),tyre(tr,tw)&#123;&#125;	<span class="comment">//使用初始化列表编写构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封闭类对象生成时先执行所有成员对象的构造函数，在执行封闭类构造函数。封闭类对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数。</p>
<h4 id="3-6-2-封闭类的复制构造函数"><a href="#3-6-2-封闭类的复制构造函数" class="headerlink" title="3.6.2    封闭类的复制构造函数"></a>3.6.2    封闭类的复制构造函数</h4><p>封闭类对象如果使用默认复制构造函数初始化，其成员对象也会用复制构造函数初始化。</p>
<h3 id="3-7-const成员和引用成员"><a href="#3-7-const成员和引用成员" class="headerlink" title="3.7    const成员和引用成员"></a>3.7    const成员和引用成员</h3><p>常量成员变量和引用成员变量必须在构造函数初始化列表进行初始化，常量成员变量的值一旦初始化就不能改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> num; <span class="comment">//常量型成员变量</span></span><br><span class="line">		<span class="keyword">int</span> &amp; ref;     <span class="comment">//引用型成员变量</span></span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		CDemo( <span class="keyword">int</span> n):num(n),ref(f),value(<span class="number">4</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(CDemo) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-友元"><a href="#3-8-友元" class="headerlink" title="3.8    友元"></a>3.8    友元</h3><h4 id="3-8-1-友元函数"><a href="#3-8-1-友元函数" class="headerlink" title="3.8.1    友元函数"></a>3.8.1    友元函数</h4><p>定义类时可以把一些函数（包括全局函数和其他类的成员函数）声明为友元，友元函数可以访问该类的私有成员。不能把其他类的私有成员函数声明为友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span>							<span class="comment">//提前声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[],<span class="keyword">int</span> total)</span></span>;		<span class="comment">//全局函数为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;				<span class="comment">//其他类成员函数为友元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[],<span class="keyword">int</span> total)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-2-友元类"><a href="#3-8-2-友元类" class="headerlink" title="3.8.2    友元类"></a>3.8.2    友元类</h4><p>定义类时将某个其他类声明为自己的友元，该类的所有成员函数就能访问自己对象的私有成员。友元关系不能传递。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	nt price;</span><br><span class="line">	riend <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span> <span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	CCar myCar;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span>  <span class="comment">//改装汽车</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		myCar.price += <span class="number">1000</span>;<span class="comment">//因CDriver是CCar的友元类，故此处可以访问其私有成员</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-this指针"><a href="#3-9-this指针" class="headerlink" title="3.9    this指针"></a>3.9    this指针</h3><h4 id="3-9-1-C-程序到C程序的翻译"><a href="#3-9-1-C-程序到C程序的翻译" class="headerlink" title="3.9.1    C++程序到C程序的翻译"></a>3.9.1    C++程序到C程序的翻译</h4><p>类被翻译成结构体，对象被翻译成结构变量，成员函数被翻译成全局函数，全局函数比成员函数多一个参数，即指向结构变量的this指针。</p>
<h4 id="3-9-2-this指针的作用"><a href="#3-9-2-this指针的作用" class="headerlink" title="3.9.2    this指针的作用"></a>3.9.2    this指针的作用</h4><p>静态成员函数内部不能使用this指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line">	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) :real(r), imag(i) &#123; &#125;</span><br><span class="line">	<span class="function">Complex <span class="title">AddOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;real++;	<span class="comment">//相当于real++;</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-在多个文件中使用类"><a href="#3-10-在多个文件中使用类" class="headerlink" title="3.10    在多个文件中使用类"></a>3.10    在多个文件中使用类</h3><p>类的定义可以写在一个头文件中。非内联成员函数函数体只能出现在某一.cpp文件中，不能放在头文件。内联成员函数应当写在头文件中。</p>
<h2 id="四-运算符重载"><a href="#四-运算符重载" class="headerlink" title="四    运算符重载"></a>四    运算符重载</h2><h3 id="4-1-运算符重载的概念和原理"><a href="#4-1-运算符重载的概念和原理" class="headerlink" title="4.1    运算符重载的概念和原理"></a>4.1    运算符重载的概念和原理</h3><p>运算符重载即对已有运算符赋予多重含义，使其用于不同类型的数据时产生不同行为。这样运算符可以操作各种类的对象。运算符重载的实质是编写以运算符为名称的函数，包含运算符的表达式会被编译成对运算符函数的调用，操作数成为函数调用的实参，运算的结果是函数的返回值。运算符可以多次重载，可以重载为全局函数，也可以重载为成员函数。一般重载为成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; a,comst Complex&amp; b)</span><br><span class="line">&#123;<span class="comment">//全局函数</span></span><br><span class="line">    <span class="keyword">return</span> Complex(a.real+b.real,a.imag+b.imag);	<span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(comst Complex&amp; c)</span><br><span class="line">&#123;<span class="comment">//成员函数</span></span><br><span class="line">    <span class="keyword">return</span> Complex(real-c.real,imag-c.imag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex a(4,4),b(1,1),c;</span><br><span class="line">    c=a+b;						<span class="comment">//c=operator+(a,b);</span></span><br><span class="line">    c=a-b;						<span class="comment">//c=a.operator-(b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-重载赋值运算符“-”"><a href="#4-2-重载赋值运算符“-”" class="headerlink" title="4.2    重载赋值运算符“=”"></a>4.2    重载赋值运算符“=”</h3><p>赋值运算符只能重载为成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	String() :str(<span class="literal">NULL</span>) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> str; &#125;;<span class="comment">//返回值为const的常量成员函数，成员变量不会在函数内部修改，也不允许调用函数后修改指针指向的内容</span></span><br><span class="line">	String&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line">	~String();</span><br><span class="line">&#125;;</span><br><span class="line">String&amp; String::<span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br><span class="line"><span class="comment">//重载&quot;=&quot;以使得 obj = &quot;hello&quot;能够成立</span></span><br><span class="line">&#123;<span class="comment">//返回值类型为T&amp;能够保留赋值运算符原本的特性</span></span><br><span class="line">	<span class="keyword">if</span> (str)</span><br><span class="line">		<span class="keyword">delete</span>[] str;</span><br><span class="line">	<span class="keyword">if</span> (s) &#123;  <span class="comment">//s不为NULL才会执行拷贝</span></span><br><span class="line">		str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];<span class="comment">//&#x27;\0&#x27;</span></span><br><span class="line">		<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		str = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (str)<span class="comment">//防止错误delete</span></span><br><span class="line">		<span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String s;</span><br><span class="line">	s = <span class="string">&quot;Good Luck,&quot;</span>; <span class="comment">//等价于 s.operator=(&quot;Good Luck,&quot;);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// String s2 = &quot;hello!&quot;;   //这条语句要是不注释掉就会出错，此语句是初始化语句</span></span><br><span class="line">	s = <span class="string">&quot;Shenzhou 8!&quot;</span>; <span class="comment">//等价于 s.operator=(&quot;Shenzhou 8!&quot;);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-浅拷贝和深拷贝"><a href="#4-3-浅拷贝和深拷贝" class="headerlink" title="4.3    浅拷贝和深拷贝"></a>4.3    浅拷贝和深拷贝</h3><p>执行逐个字节的拷贝称为浅拷贝，将一个对象中指针成员变量指向的内容复制到另一个对象中指针成员变量指向的地方的拷贝称为深拷贝。浅拷贝会导致存储空间不被释放或重复释放，引发严重的内存错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==s.str)<span class="comment">//防止自己复制自己时开辟存储空间</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(str)</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">    <span class="keyword">if</span>(s.str)</span><br><span class="line">    &#123;</span><br><span class="line">        str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">String::String(String&amp; s)</span><br><span class="line">&#123;<span class="comment">//复制构造函数同样需要深拷贝</span></span><br><span class="line">   <span class="keyword">if</span>(s.str)</span><br><span class="line">    &#123;</span><br><span class="line">        str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-运算符重载为友元函数"><a href="#4-4-运算符重载为友元函数" class="headerlink" title="4.4    运算符重载为友元函数"></a>4.4    运算符重载为友元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r);<span class="comment">//复数加实数</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r,<span class="keyword">const</span> Complex&amp; c);<span class="comment">//实数加复数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-长度可变的整型数组类"><a href="#4-5-长度可变的整型数组类" class="headerlink" title="4.5    长度可变的整型数组类"></a>4.5    长度可变的整型数组类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span>* pit;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CArray(<span class="keyword">int</span> s=<span class="number">0</span>);					<span class="comment">//s为0时指向NULL，否则动态分配</span></span><br><span class="line">    CArray(CArray&amp; s);					<span class="comment">//使用memcpy()</span></span><br><span class="line">    ~CArray();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> v)</span></span>;				<span class="comment">//重新分配空间并复制原数组内容和加入新元素</span></span><br><span class="line">    CArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CArray&amp; a);		<span class="comment">//考虑a=a，a数组为空，原有空间够大等情况</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)				<span class="comment">//重载[]运算符，能作为左值使用的函数应返回引用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-重载流插入运算符和流提取运算符"><a href="#4-6-重载流插入运算符和流提取运算符" class="headerlink" title="4.6    重载流插入运算符和流提取运算符"></a>4.6    重载流插入运算符和流提取运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) :real(r), imag(i) &#123; &#125;;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Complex&amp; c);</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Complex&amp; c)<span class="comment">//ostream类复制构造函数是私有的，因此os只能是引用</span></span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; c.real &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i&quot;</span>; <span class="comment">//以&quot;a+bi&quot;的形式输出</span></span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	is &gt;&gt; s;  <span class="comment">//将&quot;a+bi&quot;作为字符串读入, &quot;a+bi&quot; 中间不能有空格</span></span><br><span class="line">	<span class="keyword">int</span> pos = s.find(<span class="string">&quot;+&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">string</span> sTmp = s.substr(<span class="number">0</span>, pos); <span class="comment">//分离出代表实部的字符串</span></span><br><span class="line">	c.real = atof(sTmp.c_str());<span class="comment">//atof库函数能将const char*指针指向的内容转换成 float</span></span><br><span class="line">	sTmp = s.substr(pos + <span class="number">1</span>, s.length() - pos - <span class="number">2</span>);   <span class="comment">//分离出代表虚部的字符串</span></span><br><span class="line">	c.imag = atof(sTmp.c_str());</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Complex c;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; c &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; n;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-重载强制类型转换运算符"><a href="#4-7-重载强制类型转换运算符" class="headerlink" title="4.7    重载强制类型转换运算符"></a>4.7    重载强制类型转换运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r=<span class="number">0</span>;<span class="keyword">double</span> i=<span class="number">0</span>):real(r),imag(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> real;&#125;					<span class="comment">//强制类型转换运算符只能重载为成员函数，且无需指定返回值类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-重载自增自减运算符"><a href="#4-8-重载自增自减运算符" class="headerlink" title="4.8    重载自增自减运算符"></a>4.8    重载自增自减运算符</h3><p>自增自减运算符有前置后置之分，为了区分两种表达式，重载前置时使用正常的重载函数，重载后置时使用增加一个无用int类型形参的重载函数。前置运算符返回值是操作数的引用，后置运算符的返回值是操作数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CDemo(<span class="keyword">int</span> i = <span class="number">0</span>) :n(i) &#123; &#125;</span><br><span class="line">	CDemo&amp; <span class="keyword">operator</span>++();      <span class="comment">//用于前置形式</span></span><br><span class="line">	CDemo <span class="keyword">operator</span>++(<span class="keyword">int</span>);   <span class="comment">//用于后置形式</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">	<span class="keyword">friend</span> CDemo&amp; <span class="keyword">operator</span>--(CDemo&amp;);</span><br><span class="line">	<span class="keyword">friend</span> CDemo <span class="keyword">operator</span>--(CDemo&amp;, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CDemo&amp; CDemo::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;<span class="comment">//前置 ++</span></span><br><span class="line">	n++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span>++(<span class="keyword">int</span> k)</span><br><span class="line">&#123; <span class="comment">//后置 ++</span></span><br><span class="line">	<span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//记录修改前的对象</span></span><br><span class="line">	n++;</span><br><span class="line">	<span class="keyword">return</span> tmp; <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br><span class="line">CDemo&amp; <span class="keyword">operator</span>--(CDemo&amp; d)</span><br><span class="line">&#123;<span class="comment">//前置--</span></span><br><span class="line">	d.n--;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">CDemo <span class="keyword">operator</span>--(CDemo&amp; d, <span class="keyword">int</span>)</span><br><span class="line">&#123;<span class="comment">//后置--</span></span><br><span class="line">	<span class="function">CDemo <span class="title">tmp</span><span class="params">(d)</span></span>;</span><br><span class="line">	d.n--;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CDemo <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (d++) &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="comment">//等价于 d.operator++(0);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (++d) &lt;&lt; <span class="string">&quot;,&quot;</span>;   <span class="comment">//等价于 d.operator++();</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (d--) &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="comment">//等价于 operator-(d,0);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (--d) &lt;&lt; <span class="string">&quot;,&quot;</span>;   <span class="comment">//等价于 operator-(d);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-9-运算符重载的注意事项"><a href="#4-9-运算符重载的注意事项" class="headerlink" title="4.9    运算符重载的注意事项"></a>4.9    运算符重载的注意事项</h3><ul>
<li>重载后运算符的含义要符合原有习惯。</li>
<li>重载不改变运算符优先级。</li>
<li><code>.</code>、<code>*</code>、<code>::</code>、<code>?:</code>、<code>sizeof</code>不能被重载。</li>
<li><code>()</code>、<code>[]</code>、<code>-&gt;</code>、<code>=</code>只能重载为成员函数。</li>
</ul>
<h2 id="五-继承和派生"><a href="#五-继承和派生" class="headerlink" title="五    继承和派生"></a>五    继承和派生</h2><h3 id="5-1-继承和派生的概念"><a href="#5-1-继承和派生的概念" class="headerlink" title="5.1    继承和派生的概念"></a>5.1    继承和派生的概念</h3><h4 id="5-1-1-基本概念"><a href="#5-1-1-基本概念" class="headerlink" title="5.1.1    基本概念"></a>5.1.1    基本概念</h4><p>当定义某个新类时，如果这个类和拥有某个已有类的全部特点，此外还有这个类没有的特点，那么可以把原有类作为基类，新类作为原有类的派生类。即基类派生了派生类，派生类继承了基类。基类的所有成员自动成为派生类的成员。派生类的成员函数不能访问基类的私有成员。继承方式可以是公有继承、私有继承和保护继承。一般使用公有继承。派生类对象占用内存大小等于基类对象占用内存空间大小加上派生类全体成员变量占用内存大小之和。派生类对象包含基类对象，而且基类对象存储位置在派生类对象新增的成员变量之前。</p>
<h4 id="5-1-2-程序实例"><a href="#5-1-2-程序实例" class="headerlink" title="5.1.2    程序实例"></a>5.1.2    程序实例</h4><p>在基类和派生类有同名成员的情况下，在派生类的函数中或通过派生类对象访问同名成员，默认访问派生类成员。如需访问基类同名成员则使用<code>基类名::函数名()</code>。一般不在派生类中定义和基类同名的成员变量。</p>
<h3 id="5-2-正确处理类的复合关系和继承关系"><a href="#5-2-正确处理类的复合关系和继承关系" class="headerlink" title="5.2    正确处理类的复合关系和继承关系"></a>5.2    正确处理类的复合关系和继承关系</h3><p>复合关系表现为封闭类，数学上可以称为属于。继承关系表现为派生类，数学上可以称为包含。一个类中有另一个类的指针的情况可以称为知道关系。</p>
<h3 id="5-3-protected访问范围说明符"><a href="#5-3-protected访问范围说明符" class="headerlink" title="5.3    protected访问范围说明符"></a>5.3    protected访问范围说明符</h3><p>基类的保护成员可以在派生类的成员函数中被访问。派生类的成员函数只能访问所作用的那个对象的基类保护成员，不能访问其他对象的基类保护成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nPrivate;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> nPublic;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> nProtected;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span><span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AccessBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nPublic=<span class="number">1</span>;</span><br><span class="line">        nPrivate=<span class="number">1</span>;			<span class="comment">//不能访问私有成员</span></span><br><span class="line">        nProtected=<span class="number">1</span>;</span><br><span class="line">        CBase f;</span><br><span class="line">        f.nProtected=<span class="number">1</span>;		<span class="comment">//不能访问其他对象的保护成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-派生类的构造函数和析构函数"><a href="#5-4-派生类的构造函数和析构函数" class="headerlink" title="5.4    派生类的构造函数和析构函数"></a>5.4    派生类的构造函数和析构函数</h3><p>任何生成派生类对象的语句都要说明其包含的基类对象是如何初始化的，默认使用无参构造函数初始化，如果基类没有无参构造函数，则编译错误。派生类对象生成时总是先执行基类的构造函数再执行派生类的构造函数，派生类对象消亡时总是先执行派生类的析构函数再执行基类的析构函数。如果一个派生类对象使用默认复制构造函数初始化，那么它的基类对象也要使用基类的复制构造函数初始化。</p>
<h3 id="5-5-多层次的派生"><a href="#5-5-多层次的派生" class="headerlink" title="5.5    多层次的派生"></a>5.5    多层次的派生</h3><p>对于派生的派生，有直接基类和间接基类之分。定义派生类时只写直接基类，派生类自动继承所有间接基类。派生类的成员包括自己定义的成员、直接基类定义的成员以及所有间接基类的全部成员。</p>
<h3 id="5-6-包含成员对象的派生类"><a href="#5-6-包含成员对象的派生类" class="headerlink" title="5.6    包含成员对象的派生类"></a>5.6    包含成员对象的派生类</h3><p>在派生类也是封闭类的情况下，构造函数调用顺序为自上至下所有基类、成员对象、自身，析构函数调用顺序为自身、成员对象、自下至上所有基类。</p>
<h3 id="5-7-公有派生的赋值兼容规则"><a href="#5-7-公有派生的赋值兼容规则" class="headerlink" title="5.7    公有派生的赋值兼容规则"></a>5.7    公有派生的赋值兼容规则</h3><ul>
<li>派生类对象可以赋值给基类对象</li>
<li>派生类对象可以初始化基类引用</li>
<li>派生类指针可以赋值给基类指针</li>
</ul>
<p>此规则只有public派生才成立，private和protected派生不成立。</p>
<h3 id="5-8-基类和派生类指针的互相转换"><a href="#5-8-基类和派生类指针的互相转换" class="headerlink" title="5.8    基类和派生类指针的互相转换"></a>5.8    基类和派生类指针的互相转换</h3><p>即使基类指针指向派生类对象，也不能通过基类指针访问基类没有而派生类有的成员。基类指针指向派生类对象时仍然调用基类同名成员函数。基类指针不能赋值给派生类指针，除非经过强制类型转换。基类引用也可以强制转换为派生类引用。强制类型转换会导致不可预测的安全隐患。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CBase(<span class="keyword">int</span> i) :n(i) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CBase:n=&quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span><span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	CDerived(<span class="keyword">int</span> i) :CBase(i), v(<span class="number">2</span> * i) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CDerived:n=&quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CDerived:v=&quot;</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CDerived <span class="title">objDerived</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="function">CBase <span class="title">objBase</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	CBase* pBase = &amp;objDerived; <span class="comment">// 使得基类指针指向派生类对象</span></span><br><span class="line">	<span class="comment">//pBase-&gt;Func(); //错, CBase类没有Func()成员函数</span></span><br><span class="line">	<span class="comment">//pBase-&gt;v = 5;  //错 CBase类没有v成员变量</span></span><br><span class="line">	pBase-&gt;Print();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//CDerived * pDerived = &amp; objBase; //错，不能将基类指针赋值给派生类指针</span></span><br><span class="line">	CDerived* pDerived = (CDerived*)(&amp;objBase);</span><br><span class="line">	pDerived-&gt;Print();  <span class="comment">//慎用，可能出现不可预期的错误</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	objDerived.Print();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	pDerived-&gt;v = <span class="number">128</span>;  <span class="comment">//往别人的空间里写入数据，会有问题</span></span><br><span class="line">	objDerived.Print();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-9-私有派生和保护派生"><a href="#5-9-私有派生和保护派生" class="headerlink" title="5.9    私有派生和保护派生"></a>5.9    私有派生和保护派生</h3><table>
<thead>
<tr>
<th></th>
<th>公有派生</th>
<th>私有派生</th>
<th>保护派生</th>
</tr>
</thead>
<tbody><tr>
<td>私有成员</td>
<td>不可访问</td>
<td>不可访问</td>
<td>不可访问</td>
</tr>
<tr>
<td>保护成员</td>
<td>保护</td>
<td>私有</td>
<td>保护</td>
</tr>
<tr>
<td>公有成员</td>
<td>公有</td>
<td>私有</td>
<td>保护</td>
</tr>
</tbody></table>
<p>一般情况下都应使用公有派生。</p>
<h3 id="5-10-派生类和赋值运算符"><a href="#5-10-派生类和赋值运算符" class="headerlink" title="5.10    派生类和赋值运算符"></a>5.10    派生类和赋值运算符</h3><p>如果基类重载了赋值运算符而派生类没有，那么派生类互相赋值或是给基类对象赋值时基类部分调用被基类重载的赋值运算符。</p>
<h2 id="六-多态与虚函数"><a href="#六-多态与虚函数" class="headerlink" title="六    多态与虚函数"></a>六    多态与虚函数</h2><h3 id="6-1-多态的基本概念"><a href="#6-1-多态的基本概念" class="headerlink" title="6.1    多态的基本概念"></a>6.1    多态的基本概念</h3><h4 id="6-1-1-通过基类指针实现多态"><a href="#6-1-1-通过基类指针实现多态" class="headerlink" title="6.1.1    通过基类指针实现多态"></a>6.1.1    通过基类指针实现多态</h4><p>多态指的是同一名字的事物可以完成不同的功能，包括编译时的多态和运行时的多态。编译时的多态指函数的重载，运行时的多态则和虚函数有关。虚函数在通过基类指针调用时并不确定执行基类或派生类的同名函数，而是以运行时所指向的对象来判断。虚函数在声明时添加<code>virtual</code>关键字，且只能在声明时使用。静态成员函数不能是虚函数。包含虚函数的类称为多态类。</p>
<h4 id="6-1-2-通过基类引用实现多态"><a href="#6-1-2-通过基类引用实现多态" class="headerlink" title="6.1.2    通过基类引用实现多态"></a>6.1.2    通过基类引用实现多态</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;D&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">(A&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r.Print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;B b;C c;D d;</span><br><span class="line">    A* pa=&amp;a;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;b;			<span class="comment">//指针的多态</span></span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;c;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;d;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    PrintInfo(a);		<span class="comment">//引用的多态</span></span><br><span class="line">    PrintInfo(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-多态的作用"><a href="#6-2-多态的作用" class="headerlink" title="6.2    多态的作用"></a>6.2    多态的作用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShape</span>  //基类：形体类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span> </span>&#123; &#125;;  <span class="comment">//求面积</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span> </span>&#123; &#125;; <span class="comment">//显示信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span> :</span><span class="keyword">public</span> CShape  <span class="comment">//派生类：矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> w, h;     <span class="comment">//宽和高</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCircle</span> :</span><span class="keyword">public</span> CShape  <span class="comment">//派生类：圆类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> r;      <span class="comment">//半径</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTriangle</span> :</span><span class="keyword">public</span> CShape <span class="comment">//派生类：三角形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a, b, c;      <span class="comment">//三边长</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CRectangle::Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRectangle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CCircle::Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CCircle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CTriangle::Area</span><span class="params">()</span> </span>&#123;   <span class="comment">//根据海伦公式计算三角形面积</span></span><br><span class="line">	<span class="keyword">double</span> p = (a + b + c) / <span class="number">2.0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(p * (p - a) * (p - b) * (p - c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTriangle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Triangle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">CShape* pShapes[<span class="number">100</span>]; <span class="comment">//用来存放各种几何形体，假设不超过100个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* s1, <span class="keyword">const</span> <span class="keyword">void</span>* s2)</span>  <span class="comment">//定义排序规则的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CShape** p1 = (CShape**)s1; <span class="comment">//s1是指向指针的指针,其指向的指针为CShape* 类型</span></span><br><span class="line">	CShape** p2 = (CShape**)s2;</span><br><span class="line">	<span class="keyword">double</span> a1 = (*p1)-&gt;Area(); <span class="comment">//p1指向几何形体对象的指针, *p1才指向几何形体对象</span></span><br><span class="line">	<span class="keyword">double</span> a2 = (*p2)-&gt;Area();</span><br><span class="line">	<span class="keyword">if</span> (a1 &lt; a2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//面积小的排前面</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a2 &lt; a1)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i; <span class="keyword">int</span> n;</span><br><span class="line">	CRectangle* pr; CCircle* pc; CTriangle* pt;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">		<span class="keyword">switch</span> (c) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="comment">//矩形</span></span><br><span class="line">			pr = <span class="keyword">new</span> CRectangle();</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; pr-&gt;w &gt;&gt; pr-&gt;h;</span><br><span class="line">			pShapes[i] = pr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">//圆</span></span><br><span class="line">			pc = <span class="keyword">new</span> CCircle();</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; pc-&gt;r;</span><br><span class="line">			pShapes[i] = pc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">//三角形</span></span><br><span class="line">			pt = <span class="keyword">new</span> CTriangle();</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; pt-&gt;a &gt;&gt; pt-&gt;b &gt;&gt; pt-&gt;c;</span><br><span class="line">			pShapes[i] = pt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	qsort(pShapes, n, <span class="keyword">sizeof</span>(Cshape*), MyCompare);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		pShapes[i]-&gt;PrintInfo();</span><br><span class="line">		<span class="keyword">delete</span> pShapes[i]; <span class="comment">//释放空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-多态的实现原理"><a href="#6-3-多态的实现原理" class="headerlink" title="6.3    多态的实现原理"></a>6.3    多态的实现原理</h3><p>有虚函数的类占用的存储空间比没有虚函数的多8个字节，位于存储空间的最前端，存放了虚函数表的地址。编译时不会确定要调用哪个函数，运行时先取出指针所指位置的虚函数表的地址，再通过虚函数表的地址找到虚函数表，在虚函数表中查找对应的虚函数的地址，最后根据找到的虚函数的地址调用虚函数。多态能够提高程序的开发效率，但也增加了程序运行时的开销。</p>
<h3 id="6-4-关于多态的注意事项"><a href="#6-4-关于多态的注意事项" class="headerlink" title="6.4    关于多态的注意事项"></a>6.4    关于多态的注意事项</h3><h4 id="6-4-1-在成员函数中调用虚函数"><a href="#6-4-1-在成员函数中调用虚函数" class="headerlink" title="6.4.1    在成员函数中调用虚函数"></a>6.4.1    在成员函数中调用虚函数</h4><p>在成员函数（静态成员函数、构造函数和析构函数除外）中调用其它成员虚函数的语句是多态的。</p>
<h4 id="6-4-2-在构造函数和析构函数中调用虚函数"><a href="#6-4-2-在构造函数和析构函数中调用虚函数" class="headerlink" title="6.4.2    在构造函数和析构函数中调用虚函数"></a>6.4.2    在构造函数和析构函数中调用虚函数</h4><p>在构造函数和析构函数中调用虚函数不是多态，如果本类有该函数则调用本类函数，否则依次看直接基类和间接基类的函数。</p>
<h4 id="6-4-3-注意区分多态和非多态的情况"><a href="#6-4-3-注意区分多态和非多态的情况" class="headerlink" title="6.4.3    注意区分多态和非多态的情况"></a>6.4.3    注意区分多态和非多态的情况</h4><p>只有成员函数是虚函数时才是多态。只要基类中某个函数被声明为虚函数，则派生类中同名同参数表的成员函数也自动成为虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;  <span class="comment">//func2自动成为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B  <span class="comment">// C以A为间接基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;; <span class="comment">//func1自动成为虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;; <span class="comment">//func2自动成为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C obj;</span><br><span class="line">	A* pa = &amp;obj;</span><br><span class="line">	B* pb = &amp;obj;</span><br><span class="line">	pa-&gt;func2();  <span class="comment">//多态</span></span><br><span class="line">	pa-&gt;func1();  <span class="comment">//不是多态</span></span><br><span class="line">	pb-&gt;func1();  <span class="comment">//多态</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-虚析构函数"><a href="#6-5-虚析构函数" class="headerlink" title="6.5    虚析构函数"></a>6.5    虚析构函数</h3><p>为了让动态分配的内存释放时能够根据指针指向的对象调用对应的析构函数，需要将基类的析构函数声明为虚函数。一个类如果定义了虚函数，则最好将析构函数也定义成虚函数。基类析构函数是虚函数，派生类析构函数自动成为虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShape</span>  //基类：形体类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~CShape()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-纯虚函数和抽象类"><a href="#6-6-纯虚函数和抽象类" class="headerlink" title="6.6    纯虚函数和抽象类"></a>6.6    纯虚函数和抽象类</h3><p>纯虚函数是没有函数体的函数，包含纯虚函数的类称为抽象类。抽象类不能生成独立的对象，但可以定义抽象类的指针和引用。抽象类的派生类当且仅当实现了所有纯虚函数才成为非抽象类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>=<span class="number">0</span>;		<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七-输入输出流"><a href="#七-输入输出流" class="headerlink" title="七    输入输出流"></a>七    输入输出流</h2><h3 id="7-1-流类"><a href="#7-1-流类" class="headerlink" title="7.1    流类"></a>7.1    流类</h3><p>流是数据从一个地方传送到另一个地方的抽象。C++把用于数据输入输出的类称为流类。<code>ios</code>是抽象的基类，派生出<code>istream</code>和<code>ostream</code>，这两个类又共同派生出<code>iostream</code>。为避免多继承的二义性，从<code>ios</code>派生出<code>istream</code>和<code>ostream</code>时使用了虚继承。</p>
<h3 id="7-2-标准流对象"><a href="#7-2-标准流对象" class="headerlink" title="7.2    标准流对象"></a>7.2    标准流对象</h3><p><code>cin</code>对应标准输入流，用于从键盘读取数据，可重定向为从文件读取数据。</p>
<p><code>cout</code>对应标准输出流，用于向屏幕输出数据，可重定向为从文件写入数据。</p>
<p><code>cerr</code>对应标准错误输出流，不使用缓冲区，不能被重定向。 </p>
<p><code>clog</code>对应标准错误输出流，使用缓冲区，不能被重定向。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	freopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);  <span class="comment">//将标准输出重定向到 test.txt文件</span></span><br><span class="line">	<span class="keyword">if</span> (y == <span class="number">0</span>)  <span class="comment">//除数为0则输出错误信息</span></span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x / y;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-使用流操纵算子控制输出格式"><a href="#7-3-使用流操纵算子控制输出格式" class="headerlink" title="7.3    使用流操纵算子控制输出格式"></a>7.3    使用流操纵算子控制输出格式</h3><p>使用流操纵算子（又叫格式控制符）需要包含<code>iomanip</code>头文件。 </p>
<table>
<thead>
<tr>
<th>流操纵算子</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>hex</code></td>
<td>十六进制输出整数</td>
</tr>
<tr>
<td><code>oct</code></td>
<td>八进制输出整数</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>普通小数形式输出浮点数</td>
</tr>
<tr>
<td><code>scientific</code></td>
<td>科学计数法输出浮点数</td>
</tr>
<tr>
<td><code>left</code></td>
<td>左对齐，宽度不足时填充字符添加到左边</td>
</tr>
<tr>
<td><code>setbase(b)</code></td>
<td>设置输出整数时的进制，为8、10或16</td>
</tr>
<tr>
<td><code>setw(w)</code></td>
<td>输出宽度或读入w个字符</td>
</tr>
<tr>
<td><code>setfill(c)</code></td>
<td>输出宽度不足时用c填充</td>
</tr>
<tr>
<td><code>setprecision(n)</code></td>
<td>设置浮点数输出精度为n</td>
</tr>
<tr>
<td><code>setiosflags(格式)</code></td>
<td>将某个格式标志置为1</td>
</tr>
<tr>
<td><code>reseriosflags(格式)</code></td>
<td>将某个格式标志置为0</td>
</tr>
<tr>
<td><code>boolapha</code></td>
<td>true和false输出为字符串</td>
</tr>
<tr>
<td><code>showbase</code></td>
<td>输出进制前缀</td>
</tr>
<tr>
<td><code>showpoint</code></td>
<td>总是输出小数点</td>
</tr>
<tr>
<td><code>showpos</code></td>
<td>非负数显示+</td>
</tr>
<tr>
<td><code>noskipws</code></td>
<td>输入时不跳过空白字符</td>
</tr>
<tr>
<td><code>uppercase</code></td>
<td>使用大写字母输出十六进制、前缀和科学计数法</td>
</tr>
<tr>
<td><code>internal</code></td>
<td>符号左对齐，数值右对齐</td>
</tr>
</tbody></table>
<p>流操纵算子影响整个语句，但setw算子只影响下一次输出或输入。</p>
<h3 id="7-4-调用cout的成员函数"><a href="#7-4-调用cout的成员函数" class="headerlink" title="7.4    调用cout的成员函数"></a>7.4    调用cout的成员函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::scientific);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">12.23</span>&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//cout&lt;&lt;setiosflags(ios::scientific)&lt;&lt;setprecision(8)&lt;&lt;12.23&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.put(<span class="number">98</span>).put(<span class="string">&#x27;c&#x27;</span>).put(<span class="string">&#x27;z&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="7-5-cin的高级用法"><a href="#7-5-cin的高级用法" class="headerlink" title="7.5    cin的高级用法"></a>7.5    cin的高级用法</h3><h4 id="7-5-1-判断输入结束"><a href="#7-5-1-判断输入结束" class="headerlink" title="7.5.1    判断输入结束"></a>7.5.1    判断输入结束</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxN=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;<span class="comment">//istream类重载了bool运算符，读取到输入结尾或输入错误返回false</span></span><br><span class="line">        <span class="keyword">if</span>(maxN&lt;n)</span><br><span class="line">            maxN=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-istream类的成员函数"><a href="#7-5-2-istream类的成员函数" class="headerlink" title="7.5.2    istream类的成员函数"></a>7.5.2    istream类的成员函数</h4><h5 id="1-get"><a href="#1-get" class="headerlink" title="1.get"></a>1.get</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;							<span class="comment">//注意c的类型为int，若为char则读入ASCII码为0xFF的字符会导致输入终止</span></span><br><span class="line">    freopen(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(c=<span class="built_in">cin</span>.get()!=EOF)				<span class="comment">//get函数可以正常读入所有字符，EOF是iostream类定义的整型常量，值为-1，表示输入终止</span></span><br><span class="line">        <span class="built_in">cout</span>.put(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-getline"><a href="#2-getline" class="headerlink" title="2.getline"></a>2.getline</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">120</span>;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">cin</span>.getline(szBuf, <span class="number">6</span>))  <span class="comment">//如果输入流中一行字符超过5个，就会出错</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">	<span class="built_in">cin</span>.clear(); <span class="comment">//clear能够清除cin内部的错误标记，使之恢复正常</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-eof"><a href="#3-eof" class="headerlink" title="3.eof"></a>3.eof</h5><p><code>bool eof()</code>判断输入流是否结束，若结束返回<code>true</code>。</p>
<h5 id="4-ignore"><a href="#4-ignore" class="headerlink" title="4.ignore"></a>4.ignore</h5><p><code>istream&amp; ignore(int n=1,int delim=EOF)</code>用于跳过n个字符或delim前所有字符。</p>
<h5 id="5-peek"><a href="#5-peek" class="headerlink" title="5.peek"></a>5.peek</h5><p>此函数返回下一个字符，但不会将该字符从输入流中取走。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> Months[<span class="number">12</span>] = &#123; <span class="string">&quot;Jan&quot;</span>,<span class="string">&quot;Feb&quot;</span>,<span class="string">&quot;Mar&quot;</span>,<span class="string">&quot;Apr&quot;</span>,<span class="string">&quot;May&quot;</span>,<span class="string">&quot;Jun&quot;</span>,<span class="string">&quot;Jul&quot;</span>,<span class="string">&quot;Aug&quot;</span>,</span><br><span class="line">					  <span class="string">&quot;Sep&quot;</span>,<span class="string">&quot;Oct&quot;</span>,<span class="string">&quot;Nov&quot;</span>,<span class="string">&quot;Dec&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = <span class="built_in">cin</span>.peek()) != EOF) &#123; <span class="comment">//取输入流中的第一个字符进行查看</span></span><br><span class="line">		<span class="keyword">int</span> year, month, day;</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123; <span class="comment">//美国日期格式</span></span><br><span class="line">			<span class="built_in">string</span> sMonth;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; sMonth &gt;&gt; day &gt;&gt; year;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)  <span class="comment">//查找月份</span></span><br><span class="line">				<span class="keyword">if</span> (sMonth == Months[i]) &#123;</span><br><span class="line">					month = i + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//中国日期格式</span></span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; year;</span><br><span class="line">			<span class="built_in">cin</span>.ignore() &gt;&gt; month; <span class="comment">//用ignore跳过 &quot;2011.12.3&quot;中的&#x27;.&#x27;</span></span><br><span class="line">			<span class="built_in">cin</span>.ignore() &gt;&gt; day;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cin</span>.ignore();   <span class="comment">//跳过行末 &#x27;\n&#x27;</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; month;<span class="comment">//设置填充字符&#x27;\0&#x27;，输出宽度2</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; day &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用get和putback配合达到同样的效果。</p>
<h2 id="八-文件操作"><a href="#八-文件操作" class="headerlink" title="八 文件操作"></a>八 文件操作</h2><h3 id="8-1-文件的概念"><a href="#8-1-文件的概念" class="headerlink" title="8.1    文件的概念"></a>8.1    文件的概念</h3><p>所有的文件本质上都是0和1的比特串，这些比特串代表什么内容取决于用怎样的格式读取它们。</p>
<h3 id="8-2-C-文件流类"><a href="#8-2-C-文件流类" class="headerlink" title="8.2    C++文件流类"></a>8.2    C++文件流类</h3><p>C++标准类库中，ifstream、ofstream和fstream类可用于文件操作，称为文件流类。使用这三个类需要包含fstream头文件。ifstream和fstream由istream派生来，拥有istream的全部成员函数，同样ofstream和fstream拥有ostream的全部成员函数。要使用一个文件要先打开才能读写，读写完后要关闭。</p>
<h3 id="8-3-文件的打开和关闭"><a href="#8-3-文件的打开和关闭" class="headerlink" title="8.3    文件的打开和关闭"></a>8.3    文件的打开和关闭</h3><table>
<thead>
<tr>
<th>模式标记</th>
<th>适用对象</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>ios::in</code></td>
<td>ifstream fstream</td>
<td>打开文件用于读取数据。如果文件不存在。则打开出错</td>
</tr>
<tr>
<td><code>ios::out</code></td>
<td>ofstream fstream</td>
<td>打开文件用于写入数据。如果文件不存在，则新建该文件果文件原来就存在，则打开时清除原来的内容</td>
</tr>
<tr>
<td><code>ios::app</code></td>
<td>ofstream fstream</td>
<td>打开文件，用于在其尾部添加数据。如果文件不存在，则新建该文件</td>
</tr>
<tr>
<td><code>ios::ate</code></td>
<td>ifstream</td>
<td>打开一个已有的文件，并将文件读指针指向文件末尾（读写指针的概念后面解释)。如果文件不存在，则打开出错</td>
</tr>
<tr>
<td><code>ios::trunc</code></td>
<td>ofstream</td>
<td>单独使用时与ios::out相同</td>
</tr>
<tr>
<td><code>ios::binary</code></td>
<td>ifstream ofstream fstream</td>
<td>以二进制方式打开文件。若不指定此模式，则以文本模式打开</td>
</tr>
<tr>
<td><code>ios::in|ios::out</code></td>
<td>fstream</td>
<td>打开已存在的文件，既可读取其内容，也可向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错</td>
</tr>
<tr>
<td><code>ios::in|ios::out</code></td>
<td>ofstream</td>
<td>打开已存在的文件，可以向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错</td>
</tr>
<tr>
<td><code>ios::in|ios::out|ios::trunc</code></td>
<td>fstream</td>
<td>打开文件，既可读取其内容，也可向其写入数据。如果文件本来就存在，则打开时清除原来的内容；如果文件不存在，则新建该文件</td>
</tr>
</tbody></table>
<p><code>void open(const char* szFileName,int mode)</code>调用该成员函数时，给出的文件名可以是全路径的，也可以给出相对路径。</p>
<p><code>ifstream(const char* szFileName,int mode=ios::in,int)</code>构造函数也可以打开文件。</p>
<h3 id="8-4-文件的读写"><a href="#8-4-文件的读写" class="headerlink" title="8.4    文件的读写"></a>8.4    文件的读写</h3><h4 id="8-4-1-文本文件的读写"><a href="#8-4-1-文本文件的读写" class="headerlink" title="8.4.1    文本文件的读写"></a>8.4.1    文本文件的读写</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //qsort在此头文件中声明</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX_NUM]; <span class="comment">//存放文件中读入的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* e1, <span class="keyword">const</span> <span class="keyword">void</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//用于qsort的比较函数</span></span><br><span class="line">	<span class="keyword">return</span> *((<span class="keyword">int</span>*)e1) - *((<span class="keyword">int</span>*)e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> total = <span class="number">0</span>;<span class="comment">//读入的整数个数</span></span><br><span class="line">	<span class="function">ifstream <span class="title">srcFile</span><span class="params">(<span class="string">&quot;in.txt&quot;</span>, ios::in)</span></span>; <span class="comment">//以文本模式打开in.txt备读</span></span><br><span class="line">	<span class="keyword">if</span> (!srcFile) &#123; <span class="comment">//打开失败</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error opening source file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ofstream <span class="title">destFile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>, ios::out)</span></span>; <span class="comment">//以文本模式打开out.txt备写</span></span><br><span class="line">	<span class="keyword">if</span> (!destFile) &#123;</span><br><span class="line">		srcFile.close(); <span class="comment">//程序结束前不能忘记关闭以前打开过的文件</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error opening destination file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">while</span> (srcFile &gt;&gt; x) <span class="comment">//可以像用cin那样用ifstream对象</span></span><br><span class="line">		a[total++] = x;</span><br><span class="line">	qsort(a, total, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), MyCompare); <span class="comment">//排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span><br><span class="line">		destFile &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//可以像用cout那样用ofstream对象</span></span><br><span class="line">	destFile.close();</span><br><span class="line">	srcFile.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-2-二进制文件的读写"><a href="#8-4-2-二进制文件的读写" class="headerlink" title="8.4.2    二进制文件的读写"></a>8.4.2    二进制文件的读写</h4><p>使用二进制文件可以节约空间，提升文件查找效率。读写二进制文件不能使用流读写，需要使用read和write成员函数。写函数从写指针指向的位置开始写入，读函数从读指针指向的位置开始读取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CStudent s;</span><br><span class="line">	<span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;students.dat&quot;</span>, ios::in | ios::binary)</span></span>; <span class="comment">//二进制读方式打开</span></span><br><span class="line">	<span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (inFile.read((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s))) &#123; <span class="comment">//一直读到文件结束</span></span><br><span class="line">		<span class="keyword">int</span> readedBytes = inFile.gcount(); <span class="comment">//看刚才读了多少字节</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s.szName &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inFile.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用put和get成员函数读写文件。</p>
<h4 id="8-4-3-操作文件读写指针"><a href="#8-4-3-操作文件读写指针" class="headerlink" title="8.4.3    操作文件读写指针"></a>8.4.3    操作文件读写指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">seekp</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> mode)</span></span>;<span class="comment">//ios::beg		ios::cur	ios::end</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">seekg</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> mode)</span></span>;<span class="comment">//文件开始向后	当前位置	文件结尾向前</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tellg</span><span class="params">()</span></span>;<span class="comment">//返回读指针的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tellp</span><span class="params">()</span></span>;<span class="comment">//返回写指针的位置</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CStudent s;</span><br><span class="line">	<span class="function">fstream <span class="title">ioFile</span><span class="params">(<span class="string">&quot;students.dat&quot;</span>, ios::in | ios::out)</span></span>;<span class="comment">//用既读又写的方式打开</span></span><br><span class="line">	<span class="keyword">if</span> (!ioFile) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ioFile.seekg(<span class="number">0</span>, ios::end); <span class="comment">//定位读指针到文件尾部，</span></span><br><span class="line">							  <span class="comment">//以便用以后tellg 获取文件长度</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>, R; <span class="comment">// L是折半查找范围内第一个记录的序号</span></span><br><span class="line">				  <span class="comment">// R是折半查找范围内最后一个记录的序号</span></span><br><span class="line">	R = ioFile.tellg() / <span class="keyword">sizeof</span>(CStudent) - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//首次查找范围的最后一个记录的序号就是: 记录总数- 1</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>; <span class="comment">//要用查找范围正中的记录和待查找的名字比对</span></span><br><span class="line">		ioFile.seekg(mid * <span class="keyword">sizeof</span>(CStudent), ios::beg); <span class="comment">//定位到正中的记录</span></span><br><span class="line">		ioFile.read((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">strcmp</span>(s.szName, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123; <span class="comment">//找到了</span></span><br><span class="line">			s.age = <span class="number">20</span>;</span><br><span class="line">			ioFile.seekp(mid * <span class="keyword">sizeof</span>(CStudent), ios::beg);</span><br><span class="line">			ioFile.write((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) <span class="comment">//继续到前一半查找</span></span><br><span class="line">			R = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>  <span class="comment">//继续到后一半查找</span></span><br><span class="line">			L = mid + <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (L &lt;= R);</span><br><span class="line">	ioFile.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-文本方式打开文件与二进制方式打开文件的区别"><a href="#8-5-文本方式打开文件与二进制方式打开文件的区别" class="headerlink" title="8.5    文本方式打开文件与二进制方式打开文件的区别"></a>8.5    文本方式打开文件与二进制方式打开文件的区别</h3><p>UNIX/Linux中文本方式和二进制方式打开文件没有任何区别。Windows中用文本方式打开二进制文件读写的内容可能与文件内容有出入。</p>
<h2 id="九-泛型程序设计与模板"><a href="#九-泛型程序设计与模板" class="headerlink" title="九    泛型程序设计与模板"></a>九    泛型程序设计与模板</h2><h3 id="9-1-函数模板"><a href="#9-1-函数模板" class="headerlink" title="9.1    函数模板"></a>9.1    函数模板</h3><h4 id="9-1-1-函数模板的作用"><a href="#9-1-1-函数模板的作用" class="headerlink" title="9.1.1    函数模板的作用"></a>9.1.1    函数模板的作用</h4><p>泛型程序设计指的是算法在实现时不指定具体操作的数据类型的程序设计方法。有了函数模板，编译器就能在需要时根据模板自动生成程序代码。</p>
<h4 id="9-1-2-函数模板的原理"><a href="#9-1-2-函数模板的原理" class="headerlink" title="9.1.2    函数模板的原理"></a>9.1.2    函数模板的原理</h4><p>编译器由模板自动生成函数时会用具体的类型名对模板中所有的类型参数进行替换， 其他部分则原封不动地保留。编译器由模板自动生成函数的过程叫做模板的实例化。模板调用语句可以显式地指明要把类型参数实例化为那种类型。</p>
<h4 id="9-1-3-一个求数组中最大元素的函数模板"><a href="#9-1-3-一个求数组中最大元素的函数模板" class="headerlink" title="9.1.3    一个求数组中最大元素的函数模板"></a>9.1.3    一个求数组中最大元素的函数模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">MaxElement</span><span class="params">(T a[], <span class="keyword">int</span> size)</span> <span class="comment">//size是数组元素个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T tmpMax = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i)</span><br><span class="line">		<span class="keyword">if</span> (tmpMax &lt; a[i])</span><br><span class="line">			tmpMax = a[i];</span><br><span class="line">	<span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFraction</span> //分数类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> numerator;   <span class="comment">//分子</span></span><br><span class="line">	<span class="keyword">int</span> denominator; <span class="comment">//分母</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CFraction(<span class="keyword">int</span> n, <span class="keyword">int</span> d) :numerator(n), denominator(d) &#123; &#125;;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> CFraction&amp; f) <span class="keyword">const</span></span><br><span class="line">	&#123;<span class="comment">//为避免除法产生的浮点误差，用乘法判断两个分数的大小关系</span></span><br><span class="line">		<span class="keyword">if</span> (denominator * f.denominator &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> numerator * f.denominator &lt; denominator* f.numerator;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> numerator * f.denominator &gt; denominator * f.numerator;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> CFraction&amp; f) <span class="keyword">const</span></span><br><span class="line">	&#123;<span class="comment">//为避免除法产生的浮点误差，用乘法判断两个分数是否相等</span></span><br><span class="line">		<span class="keyword">return</span> numerator * f.denominator == denominator * f.numerator;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; o, <span class="keyword">const</span> CFraction&amp; f);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; o, <span class="keyword">const</span> CFraction&amp; f)</span><br><span class="line">&#123;<span class="comment">//重载 &lt;&lt; 使得分数对象可以通过cout输出</span></span><br><span class="line">	o &lt;&lt; f.numerator &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; f.denominator; <span class="comment">//输出&quot;分子/分母&quot; 形式</span></span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	CFraction f[<span class="number">4</span>] = &#123; CFraction(<span class="number">8</span>,<span class="number">6</span>),CFraction(<span class="number">-8</span>,<span class="number">4</span>),</span><br><span class="line">					   CFraction(<span class="number">3</span>,<span class="number">2</span>), CFraction(<span class="number">5</span>,<span class="number">6</span>) &#125;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; MaxElement(a, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; MaxElement(f, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-1-4-函数或函数模板调用语句的匹配顺序"><a href="#9-1-4-函数或函数模板调用语句的匹配顺序" class="headerlink" title="9.1.4    函数或函数模板调用语句的匹配顺序"></a>9.1.4    函数或函数模板调用语句的匹配顺序</h4><p>C++编译器按照如下顺序匹配同名函数：先找参数完全匹配的普通函数，再找参数完全匹配的模板函数，再找实参经过自动类型转换后能够匹配的普通函数，如果都找不到则报错。</p>
<h3 id="9-2-类模板"><a href="#9-2-类模板" class="headerlink" title="9.2    类模板"></a>9.2    类模板</h3><h4 id="9-2-1-类模板的原理"><a href="#9-2-1-类模板的原理" class="headerlink" title="9.2.1    类模板的原理"></a>9.2.1    类模板的原理</h4><p>编译器由类模板生成类的过程叫做类模板的实例化，由类模板实例化的类叫模板类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 key;  <span class="comment">//关键字</span></span><br><span class="line">	T2 value;  <span class="comment">//值</span></span><br><span class="line">	Pair(T1 k, T2 v) :key(k), value(v) &#123; &#125;;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pair&lt;T1, T2&gt;&amp; p) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Pair&lt;T1, T2&gt;::<span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pair&lt;T1, T2&gt;&amp; p) <span class="keyword">const</span></span><br><span class="line">	<span class="comment">//Pair的成员函数 operator &lt;</span></span><br><span class="line">&#123; <span class="comment">//&quot;小&quot;的意思就是关键字小</span></span><br><span class="line">	<span class="keyword">return</span> key &lt; p.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pair&lt;string, int&gt; student(&quot;Tom&quot;, 19); //实例化出一个类 Pair&lt;string,int&gt;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; student.key &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; student.value;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-2-函数模板作为类模板成员"><a href="#9-2-2-函数模板作为类模板成员" class="headerlink" title="9.2.2    函数模板作为类模板成员"></a>9.2.2    函数模板作为类模板成员</h3><p>类模板的成员函数可以是一个函数模板，成员函数模板在被调用时才会被实例化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(T2 t)</span></span>&#123;&#125;	<span class="comment">//成员函数模板</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-3-类模板实例：可变长数组类模板"><a href="#9-2-3-类模板实例：可变长数组类模板" class="headerlink" title="9.2.3    类模板实例：可变长数组类模板"></a>9.2.3    类模板实例：可变长数组类模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size; <span class="comment">//数组元素的个数</span></span><br><span class="line">	T* ptr; <span class="comment">//指向动态分配的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CArray(<span class="keyword">int</span> s = <span class="number">0</span>);  <span class="comment">//s代表数组元素的个数</span></span><br><span class="line">	CArray(CArray&amp; a);</span><br><span class="line">	~CArray();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span></span>; <span class="comment">//用于在数组尾部添加一个元素v</span></span><br><span class="line">	CArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CArray&amp; a); <span class="comment">//用于数组对象间的赋值</span></span><br><span class="line">	<span class="function">T <span class="title">length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)</span><br><span class="line">	&#123;<span class="comment">//用以支持根据下标访问数组元素，如a[i] = 4;和n = a[i]这样的语句</span></span><br><span class="line">		<span class="keyword">return</span> ptr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">CArray&lt;T&gt;::CArray(<span class="keyword">int</span> s) :size(s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">		ptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ptr = <span class="keyword">new</span> T[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">CArray&lt;T&gt;::CArray(CArray&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a.ptr) &#123;</span><br><span class="line">		ptr = <span class="literal">NULL</span>;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ptr = <span class="keyword">new</span> T[a.size];</span><br><span class="line">	<span class="built_in">memcpy</span>(ptr, a.ptr, <span class="keyword">sizeof</span>(T) * a.size);</span><br><span class="line">	size = a.size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">CArray&lt;T&gt;::~CArray()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptr) <span class="keyword">delete</span>[] ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">CArray&lt;T&gt;&amp; CArray&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> CArray&amp; a)</span><br><span class="line">&#123; <span class="comment">//赋值号的作用是使&quot;=&quot;左边对象里存放的数组，大小和内容都和右边的对象一样</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="comment">//防止a=a这样的赋值导致出错</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">if</span> (a.ptr == <span class="literal">NULL</span>) &#123;  <span class="comment">//如果a里面的数组是空的</span></span><br><span class="line">		<span class="keyword">if</span> (ptr)</span><br><span class="line">			<span class="keyword">delete</span>[] ptr;</span><br><span class="line">		ptr = <span class="literal">NULL</span>;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (size &lt; a.size) &#123; <span class="comment">//如果原有空间够大，就不用分配新的空间</span></span><br><span class="line">		<span class="keyword">if</span> (ptr)</span><br><span class="line">			<span class="keyword">delete</span>[] ptr;</span><br><span class="line">		ptr = <span class="keyword">new</span> T[a.size];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(ptr, a.ptr, <span class="keyword">sizeof</span>(T) * a.size);</span><br><span class="line">	size = a.size;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> CArray&lt;T&gt;::push_back(<span class="keyword">const</span> T&amp; v)</span><br><span class="line">&#123;  <span class="comment">//在数组尾部添加一个元素</span></span><br><span class="line">	<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		T* tmpPtr = <span class="keyword">new</span> T[size + <span class="number">1</span>]; <span class="comment">//重新分配空间</span></span><br><span class="line">		<span class="built_in">memcpy</span>(tmpPtr, ptr, <span class="keyword">sizeof</span>(T) * size); <span class="comment">//拷贝原数组内容</span></span><br><span class="line">		<span class="keyword">delete</span>[]ptr;</span><br><span class="line">		ptr = tmpPtr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">//数组本来是空的</span></span><br><span class="line">		ptr = <span class="keyword">new</span> T[<span class="number">1</span>];</span><br><span class="line">	ptr[size++] = v; <span class="comment">//加入新的数组元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CArray&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		a.push_back(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-类模板中的非类型参数"><a href="#9-3-类模板中的非类型参数" class="headerlink" title="9.3    类模板中的非类型参数"></a>9.3    类模板中的非类型参数</h3><p>类模板的类型参数表中可以出现非类型参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T <span class="built_in">array</span>[size];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CArray&lt;<span class="keyword">int</span>,<span class="number">40</span>&gt; a;</span><br><span class="line">CArray&lt;<span class="keyword">int</span>,<span class="number">50</span>&gt; b;	<span class="comment">//a和b是两个不同类</span></span><br></pre></td></tr></table></figure>
<h3 id="9-4-类模板与继承"><a href="#9-4-类模板与继承" class="headerlink" title="9.4    类模板与继承"></a>9.4    类模板与继承</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>				<span class="comment">//类模板从类模板派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&lt;T&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>				<span class="comment">//类模板从模板类派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;						<span class="comment">//类模板从普通类派生</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>				<span class="comment">//普通类从模板类派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9-5-类模板和友元"><a href="#9-5-类模板和友元" class="headerlink" title="9.5    类模板和友元"></a>9.5    类模板和友元</h3><h4 id="9-5-1-函数、类、类的成员函数作为类模板的友元"><a href="#9-5-1-函数、类、类的成员函数作为类模板的友元" class="headerlink" title="9.5.1    函数、类、类的成员函数作为类模板的友元"></a>9.5.1    函数、类、类的成员函数作为类模板的友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">B::Func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tmpl&lt;<span class="keyword">int</span>&gt; i;</span><br><span class="line">	Tmpl&lt;<span class="keyword">double</span>&gt; f;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-5-2-函数模板作为类模板的友元"><a href="#9-5-2-函数模板作为类模板的友元" class="headerlink" title="9.5.2    函数模板作为类模板的友元"></a>9.5.2    函数模板作为类模板的友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T1 key;</span><br><span class="line">    T2 value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>,<span class="keyword">class</span> <span class="title">T4</span>&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Pair&lt;T3,T4&gt;&amp; p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Pair&lt;T1,T2&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-5-3-函数模板作为类的友元"><a href="#9-5-3-函数模板作为类的友元" class="headerlink" title="9.5.3    函数模板作为类的友元"></a>9.5.3    函数模板作为类的友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> n) :v(n) &#123; &#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> T&amp; p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> T&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	Print(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-5-4-类模板作为类模板的友元"><a href="#9-5-4-类模板作为类模板的友元" class="headerlink" title="9.5.4    类模板作为类模板的友元"></a>9.5.4    类模板作为类模板的友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    A&lt;B&lt;<span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-类模板中的静态成员"><a href="#9-6-类模板中的静态成员" class="headerlink" title="9.6    类模板中的静态成员"></a>9.6    类模板中的静态成员</h3><p>类模板中可以定义静态成员，从该类模板实例化得到的所有类都包含同样的静态成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A() &#123; count++; &#125;</span><br><span class="line">	~A() &#123; count--; &#125;;</span><br><span class="line">	A(A&amp;) &#123; count++; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintCount</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> A&lt;<span class="keyword">int</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> A&lt;<span class="keyword">double</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A&lt;<span class="keyword">int</span>&gt; ia;</span><br><span class="line">	A&lt;<span class="keyword">double</span>&gt; da;</span><br><span class="line">	ia.PrintCount();</span><br><span class="line">	da.PrintCount();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-7-在多个文件中使用模板"><a href="#9-7-在多个文件中使用模板" class="headerlink" title="9.7    在多个文件中使用模板"></a>9.7    在多个文件中使用模板</h3><p>如果多个.cpp文件要用到同一个模板，则可将该模板全部内容（包括成员函数体）写在一个头文件中，不会发生重复定义的错误。</p>
<h2 id="附录-魔兽世界大作业"><a href="#附录-魔兽世界大作业" class="headerlink" title="附录    魔兽世界大作业"></a>附录    魔兽世界大作业</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>魔兽世界的西面是红魔军的司令部，东面是蓝魔军的司令部。两个司令部之间是依次排列的若干城市，城市从西向东依次编号为1,2,3 …. N ( N &lt;= 20 )。红魔军的司令部算作编号为0的城市，蓝魔军的司令部算作编号为N+1的城市。司令部有生命元，用于制造武士。</p>
<p>两军的司令部都会制造武士。武士一共有 dragon 、ninja、iceman、lion、wolf 五种。每种武士都有编号、生命值、攻击力这三种属性。</p>
<p>双方的武士编号都是从1开始计算。红方制造出来的第 n 个武士，编号就是n。同样，蓝方制造出来的第 n 个武士，编号也是n。</p>
<p>武士在刚降生的时候有一个初始的生命值，生命值在战斗中会发生变化，如果生命值减少到0（生命值变为负数时应当做变为0处理），则武士死亡（消失）。</p>
<p>有的武士可以拥有武器。武器有三种，sword, bomb,和arrow，编号分别为0,1,2。</p>
<p>武士降生后就朝对方司令部走，在经过的城市如果遇到敌人（同一时刻每个城市最多只可能有1个蓝武士和一个红武士），就会发生战斗。每次战斗只有一方发起主动进攻一次。被攻击者生命值会减去进攻者的攻击力值和进攻者手中sword的攻击力值。被进攻者若没死，就会发起反击，被反击者的生命值要减去反击者攻击力值的一半(去尾取整)和反击者手中sword的攻击力值。反击可能致敌人于死地。</p>
<p>如果武士在战斗中杀死敌人（不论是主动进攻杀死还是反击杀死），则其司令部会立即向其发送8个生命元作为奖励，使其生命值增加8。当然前提是司令部得有8个生命元。如果司令部的生命元不足以奖励所有的武士，则优先奖励距离敌方司令部近的武士。</p>
<p>如果某武士在某城市的战斗中杀死了敌人，则该武士的司令部立即取得该城市中所有的生命元。注意，司令部总是先完成全部奖励工作，然后才开始从各个打了胜仗的城市回收生命元。对于因司令部生命元不足而领不到奖励的武士，司令部也不会在取得战利品生命元后为其补发奖励。</p>
<p>如果一次战斗的结果是双方都幸存(平局)，则双方都不能拿走发生战斗的城市的生命元。</p>
<p>城市可以插旗子，一开始所有城市都没有旗子。在插红旗的城市，以及编号为奇数的无旗城市，由红武士主动发起进攻。在插蓝旗的城市，以及编号为偶数的无旗城市，由蓝武士主动发起进攻。</p>
<p>当某个城市有连续两场战斗都是同一方的武士杀死敌人(两场战斗之间如果有若干个战斗时刻并没有发生战斗，则这两场战斗仍然算是连续的；但如果中间有平局的战斗，就不算连续了) ，那么该城市就会插上胜方的旗帜，若原来插着败方的旗帜，则败方旗帜落下。旗帜一旦插上，就一直插着，直到被敌人更换。一个城市最多只能插一面旗帜，旗帜没被敌人更换前，也不会再次插同颜色的旗。</p>
<p>各种武器有其特点：</p>
<p>sword武器的初始攻击力为拥有它的武士的攻击力的20%（去尾取整）。但是sword每经过一次战斗(不论是主动攻击还是反击)，就会变钝，攻击力变为本次战斗前的80% (去尾取整)。sword攻击力变为0时，视为武士失去了sword。如果武士降生时得到了一个初始攻击力为0的sword，则视为武士没有sword.</p>
<p>arrow有一个攻击力值R。如果下一步要走到的城市有敌人，那么拥有arrow的武士就会放箭攻击下一个城市的敌人（不能攻击对方司令部里的敌人）而不被还击。arrow使敌人的生命值减少R，若减至小于等于0，则敌人被杀死。arrow使用3次后即被耗尽，武士失去arrow。两个相邻的武士可能同时放箭把对方射死。</p>
<p>拥有bomb的武士，在战斗开始前如果判断自己将被杀死（不论主动攻击敌人，或者被敌人主动攻击都可能导致自己被杀死，而且假设武士可以知道敌人的攻击力和生命值），那么就会使用bomb和敌人同归于尽。武士不预测对方是否会使用bomb。</p>
<p>武士使用bomb和敌人同归于尽的情况下，不算是一场战斗，双方都不能拿走城市的生命元，也不影响城市的旗帜。</p>
<p>不同的武士有不同的特点。</p>
<p>dragon可以拥有一件武器。编号为n的dragon降生时即获得编号为 n%3 的武器。dragon还有“士气”这个属性，是个浮点数，其值为它降生后其司令部剩余生命元的数量除以造dragon所需的生命元数量。dragon 在一次在它主动进攻的战斗结束后，如果还没有战死，而且士气值大于0.8，就会欢呼。dragon每取得一次战斗的胜利(敌人被杀死)，士气就会增加0.2，每经历一次未能获胜的战斗，士气值就会减少0.2。士气增减发生在欢呼之前。</p>
<p>ninja可以拥有两件武器。编号为n的ninja降生时即获得编号为 n%3 和 (n+1)%3的武器。ninja 挨打了也从不反击敌人。</p>
<p>iceman有一件武器。编号为n的iceman降生时即获得编号为 n%3 的武器。iceman 每前进两步，在第2步完成的时候，生命值会减少9，攻击力会增加20。但是若生命值减9后会小于等于0，则生命值不减9,而是变为1。即iceman不会因走多了而死。</p>
<p>lion 有“忠诚度”这个属性，其初始值等于它降生之后其司令部剩余生命元的数目。每经过一场未能杀死敌人的战斗，忠诚度就降低K。忠诚度降至0或0以下，则该lion逃离战场,永远消失。但是已经到达敌人司令部的lion不会逃跑。Lion在己方司令部可能逃跑。lion 若是战死，则其战斗前的生命值就会转移到对手身上。所谓“战斗前”，就是每个小时的40分前的一瞬间。</p>
<p>wolf降生时没有武器，但是在战斗中如果获胜（杀死敌人），就会缴获敌人的武器，但自己已有的武器就不缴获了。被缴获的武器当然不能算新的，已经被用到什么样了，就是什么样的。</p>
<p>以下是不同时间会发生的不同事件：</p>
<p>在每个整点，即每个小时的第0分， 双方的司令部中各有一个武士降生。</p>
<p>红方司令部按照 iceman、lion、wolf、ninja、dragon 的顺序制造武士。</p>
<p>蓝方司令部按照 lion、dragon、ninja、iceman、wolf 的顺序制造武士。</p>
<p>制造武士需要生命元。</p>
<p>制造一个初始生命值为 m 的武士，司令部中的生命元就要减少 m 个。</p>
<p>如果司令部中的生命元不足以制造某武士，那么司令部就等待，直到获得足够生命元后的第一个整点，才制造该武士。例如，在2:00，红方司令部本该制造一个 wolf ，如果此时生命元不足，那么就会等待，直到生命元足够后的下一个整点，才制造一个 wolf。</p>
<p>在每个小时的第5分，该逃跑的lion就在这一时刻逃跑了。</p>
<p>在每个小时的第10分：所有的武士朝敌人司令部方向前进一步。即从己方司令部走到相邻城市，或从一个城市走到下一个城市。或从和敌军司令部相邻的城市到达敌军司令部。</p>
<p>在每个小时的第20分：每个城市产出10个生命元。生命元留在城市，直到被武士取走。</p>
<p>在每个小时的第30分：如果某个城市中只有一个武士，那么该武士取走该城市中的所有生命元，并立即将这些生命元传送到其所属的司令部。</p>
<p>在每个小时的第35分，拥有arrow的武士放箭，对敌人造成伤害。放箭事件应算发生在箭发出的城市。注意，放箭不算是战斗，因此放箭的武士不会得到任何好处。武士在没有敌人的城市被箭射死也不影响其所在城市的旗帜更换情况。</p>
<p>在每个小时的第38分，拥有bomb的武士评估是否应该使用bomb。如果是，就用bomb和敌人同归于尽。</p>
<p>在每个小时的第40分：在有两个武士的城市，会发生战斗。 如果敌人在5分钟前已经被飞来的arrow射死，那么仍然视为发生了一场战斗，而且存活者视为获得了战斗的胜利。此情况下不会有“武士主动攻击”，“武士反击”，“武士战死”的事件发生，但战斗胜利后应该发生的事情都会发生。如Wolf一样能缴获武器，旗帜也可能更换，等等。在此情况下,Dragon同样会通过判断是否应该轮到自己主动攻击来决定是否欢呼。</p>
<p>在每个小时的第50分，司令部报告它拥有的生命元数量。</p>
<p>在每个小时的第55分，每个武士报告其拥有的武器情况。</p>
<p>武士到达对方司令部后就算完成任务了，从此就呆在那里无所事事。</p>
<p>任何一方的司令部里若是出现了2个敌人，则认为该司令部已被敌人占领。</p>
<p>任何一方的司令部被敌人占领，则战争结束。战争结束之后就不会发生任何事情了。</p>
<p>给定一个时间，要求你将从0点0分开始到此时间为止的所有事件按顺序输出。事件及其对应的输出样例如下：</p>
<ul>
<li><ol>
<li>武士降生</li>
</ol>
<p>输出样例： 000:00 blue lion 1 born表示在 0点0分，编号为1的蓝魔lion武士降生 如果造出的是dragon，那么还要多输出一行，例：000:00 blue dragon 1 born Its morale is 23.34  表示该该dragon降生时士气是23. 34(四舍五入到小数点后两位)如果造出的是lion，那么还要多输出一行，例: 000:00 blue lion 1 born Its loyalty is 24  表示该lion降生时的忠诚度是24</p>
</li>
<li><ol start="2">
<li>lion逃跑</li>
</ol>
<p>输出样例： 000:05 blue lion 1 ran away 表示在 0点5分，编号为1的蓝魔lion武士逃走</p>
</li>
<li><ol start="3">
<li>武士前进到某一城市</li>
</ol>
<p>输出样例： 000:10 red iceman 1 marched to city 1 with 20 elements and force 30 表示在 0点10分，红魔1号武士iceman前进到1号城市，此时他生命值为20,攻击力为30 对于iceman,输出的生命值和攻击力应该是变化后的数值</p>
</li>
<li><p>4)武士放箭</p>
<p>输出样例： 000:35 blue dragon 1 shot 表示在 0点35分，编号为1的蓝魔dragon武士射出一支箭。如果射出的箭杀死了敌人，则应如下输出： 000:35 blue dragon 1 shot and killed red lion 4 表示在 0点35分，编号为1的蓝魔dragon武士射出一支箭，杀死了编号为4的红魔lion。</p>
</li>
<li><p>5)武士使用bomb</p>
<p>输出样例： 000:38 blue dragon 1 used a bomb and killed red lion 7 表示在 0点38分，编号为1的蓝魔dragon武士用炸弹和编号为7的红魔lion同归于尽。</p>
</li>
<li><ol start="6">
<li>武士主动进攻</li>
</ol>
<p>输出样例：000:40 red iceman 1 attacked blue lion 1 in city 1 with 20 elements and force 30 表示在0点40分，1号城市中，红魔1号武士iceman 进攻蓝魔1号武士lion,在发起进攻前，红魔1号武士iceman生命值为20，攻击力为 30</p>
</li>
<li><ol start="7">
<li>武士反击</li>
</ol>
<p>输出样例：001:40 blue dragon 2 fought back against red lion 2 in city 1 表示在1点40分，1号城市中，蓝魔2号武士dragon反击红魔2号武士lion</p>
</li>
<li><ol start="8">
<li>武士战死</li>
</ol>
<p>输出样例：001:40 red lion 2 was killed in city 1 被箭射死的武士就不会有这一条输出。</p>
</li>
<li><ol start="9">
<li>武士欢呼</li>
</ol>
<p>输出样例：003:40 blue dragon 2 yelled in city 4</p>
</li>
<li><ol start="10">
<li>武士获取生命元( elements )</li>
</ol>
<p>输出样例：001:40 blue dragon 2 earned 10 elements for his headquarter</p>
<p>输出不包括在30分不是通过战斗获取的elements</p>
</li>
<li><ol start="11">
<li>旗帜升起</li>
</ol>
<p>输出样例：004:40 blue flag raised in city 4</p>
</li>
<li><ol start="12">
<li>武士抵达敌军司令部</li>
</ol>
<p>输出样例：001:10 red iceman 1 reached blue headquarter with 20 elements and force 30 (此时他生命值为20,攻击力为30）对于iceman,输出的生命值和攻击力应该是变化后的数值</p>
</li>
<li><ol start="13">
<li>司令部被占领</li>
</ol>
<p>输出样例：003:10 blue headquarter was taken</p>
</li>
<li><p>14)司令部报告生命元数量</p>
<p>000:50 100 elements in red headquarter 000:50 120 elements in blue headquarter 表示在0点50分，红方司令部有100个生命元，蓝方有120个</p>
</li>
<li><p>15)武士报告武器情况</p>
<p>000:55 blue wolf 2 has arrow(2),bomb,sword(23) 000:55 blue wolf 4 has no weapon 000:55 blue wolf 5 has sword(20) 表示在0点55分，蓝魔2号武士wolf有一支arrow（这支arrow还可以用2次），一个bomb，还有一支攻击力为23的sword。 蓝魔4号武士wolf没武器。 蓝魔5号武士wolf有一支攻击力为20的sword。 交代武器情况时，次序依次是：arrow,bomb,sword。如果没有某种武器，某种武器就不用提。报告时，先按从西向东的顺序所有的红武士报告，然后再从西向东所有的蓝武士报告。</p>
</li>
</ul>
<p>输出事件时：</p>
<p>首先按时间顺序输出；</p>
<p>同一时间发生的事件，按发生地点从西向东依次输出. 武士前进的事件, 算是发生在目的地。</p>
<p>在一次战斗中有可能发生上面的 6 至 11 号事件。这些事件都算同时发生，其时间就是战斗开始时间。一次战斗中的这些事件，序号小的应该先输出。</p>
<p>两个武士同时抵达同一城市，则先输出红武士的前进事件，后输出蓝武士的。</p>
<p>显然，13号事件发生之前的一瞬间一定发生了12号事件。输出时，这两件事算同一时间发生，但是应先输出12号事件</p>
<p>虽然任何一方的司令部被占领之后，就不会有任何事情发生了。但和司令部被占领同时发生的事件，全都要输出。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行是t,代表测试数据组数</p>
<p>每组样例共三行。</p>
<p>第一行，五个整数 M,N,R,K, T。其含义为：</p>
<p>每个司令部一开始都有M个生命元( 1 &lt;= M &lt;= 10000)</p>
<p>两个司令部之间一共有N个城市( 1 &lt;= N &lt;= 20 )</p>
<p>arrow的攻击力是R</p>
<p>lion每经过一场未能杀死敌人的战斗，忠诚度就降低K。</p>
<p>要求输出从0时0分开始，到时间T为止(包括T) 的所有事件。T以分钟为单位，0 &lt;= T &lt;= 5000</p>
<p>第二行：五个整数，依次是 dragon 、ninja、iceman、lion、wolf 的初始生命值。它们都大于0小于等于10000</p>
<p>第三行：五个整数，依次是 dragon 、ninja、iceman、lion、wolf 的攻击力。它们都大于0小于等于10000</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对每组数据，先输出一行：</p>
<p>Case n:</p>
<p>如对第一组数据就输出 Case1:</p>
<p>然后按恰当的顺序和格式输出到时间T为止发生的所有事件。每个事件都以事件发生的时间开头，时间格式是“时: 分”，“时”有三位，“分”有两位。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">20 1 10 10 1000</span><br><span class="line">20 20 30 10 20</span><br><span class="line">5 5 5 5 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">000:00 blue lion 1 born</span><br><span class="line">Its loyalty is 10</span><br><span class="line">000:10 blue lion 1 marched to city 1 with 10 elements and force 5</span><br><span class="line">000:30 blue lion 1 earned 10 elements for his headquarter</span><br><span class="line">000:50 20 elements in red headquarter</span><br><span class="line">000:50 20 elements in blue headquarter</span><br><span class="line">000:55 blue lion 1 has no weapon</span><br><span class="line">001:00 blue dragon 2 born</span><br><span class="line">Its morale is 0.00</span><br><span class="line">001:10 blue lion 1 reached red headquarter with 10 elements and force 5</span><br><span class="line">001:10 blue dragon 2 marched to city 1 with 20 elements and force 5</span><br><span class="line">001:30 blue dragon 2 earned 10 elements for his headquarter</span><br><span class="line">001:50 20 elements in red headquarter</span><br><span class="line">001:50 10 elements in blue headquarter</span><br><span class="line">001:55 blue lion 1 has no weapon</span><br><span class="line">001:55 blue dragon 2 has arrow(3)</span><br><span class="line">002:10 blue dragon 2 reached red headquarter with 20 elements and force 5</span><br><span class="line">002:10 red headquarter was taken</span><br></pre></td></tr></table></figure>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//魔兽世界终极版 by tetrahedron</span></span><br><span class="line"><span class="comment">//2020-4-18</span></span><br><span class="line"><span class="comment">//写得很烂，完全没有用继承和多态</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VACANT 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRAGON 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	NINJA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICEMAN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LION 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WOLF 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWORD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOMB 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARROW 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 10000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> M, N, R, K, T, HOUR, MIN, h, m;<span class="comment">//司令部初始生命，城市数，arrow攻击力，忠诚度降低数，终止时间，小时和分钟</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* S[] = &#123; <span class="string">&quot;dragon&quot;</span>,<span class="string">&quot;ninja&quot;</span>,<span class="string">&quot;iceman&quot;</span>,<span class="string">&quot;lion&quot;</span>,<span class="string">&quot;wolf&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* W[] = &#123; <span class="string">&quot;sword&quot;</span>,<span class="string">&quot;bomb&quot;</span>,<span class="string">&quot;arrow&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* B[] = &#123; <span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CREATE[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;<span class="comment">//红方和蓝方生成武士的顺序</span></span><br><span class="line"><span class="keyword">int</span> HP[<span class="number">5</span>], ATK[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">now</span><span class="params">()</span> </span>&#123;<span class="comment">//输出当前时间</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; setfill(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; h &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; setfill(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; m &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">weapon</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> atk;		<span class="comment">//武器攻击力</span></span><br><span class="line">	<span class="keyword">int</span> id;			<span class="comment">//默认编号，即WEAPON中编号</span></span><br><span class="line">	<span class="keyword">int</span> dur;		<span class="comment">//耐久</span></span><br><span class="line">	weapon(<span class="keyword">int</span> id_, <span class="keyword">int</span> atk_) :id(id_) &#123;</span><br><span class="line">		<span class="keyword">if</span> (id == SWORD) atk = atk_ * <span class="number">2</span> / <span class="number">10</span>, dur = INF;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (id == BOMB) atk = INF, dur = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> atk = R, dur = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> flag;		<span class="comment">//红0蓝1</span></span><br><span class="line">	<span class="keyword">int</span> hp;			<span class="comment">//生命</span></span><br><span class="line">	<span class="keyword">int</span> n;			<span class="comment">//位置红0蓝N+1</span></span><br><span class="line">	<span class="keyword">int</span> snum;		<span class="comment">//当前武士编号，需要出生的武士编号要+1</span></span><br><span class="line">	<span class="keyword">int</span> taken;		<span class="comment">//是否已有1个对方武士</span></span><br><span class="line">&#125; b[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solider</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> n;			<span class="comment">//在某一方中编号，即第n个生产出的武士</span></span><br><span class="line">	<span class="keyword">int</span> id;			<span class="comment">//默认编号，即SOLIDER中编号</span></span><br><span class="line">	<span class="keyword">int</span> flag;		<span class="comment">//红方0或蓝方1</span></span><br><span class="line">	<span class="keyword">int</span> hp;			<span class="comment">//生命值</span></span><br><span class="line">	<span class="keyword">int</span> hpp;		<span class="comment">//开战前生命值</span></span><br><span class="line">	<span class="keyword">int</span> atk;		<span class="comment">//攻击力</span></span><br><span class="line">	<span class="keyword">int</span> loyalty;	<span class="comment">//lion专属忠诚</span></span><br><span class="line">	<span class="keyword">double</span> morale;	<span class="comment">//dragon专属士气</span></span><br><span class="line">	weapon* w[<span class="number">3</span>];	<span class="comment">//武士拥有的武器</span></span><br><span class="line">	<span class="keyword">bool</span> yell;</span><br><span class="line">	<span class="keyword">bool</span> reached;</span><br><span class="line">	solider(<span class="keyword">int</span> n_, <span class="keyword">int</span> id_, <span class="keyword">int</span> flag_) :n(n_ + <span class="number">1</span>), id(id_), flag(flag_)&#123;<span class="comment">//注意此时+1</span></span><br><span class="line">		hpp = hp = HP[id_];</span><br><span class="line">		atk = ATK[id_];</span><br><span class="line">		loyalty = <span class="number">0</span>;</span><br><span class="line">		morale = <span class="number">0</span>;</span><br><span class="line">		yell = reached = <span class="number">0</span>;</span><br><span class="line">		w[<span class="number">0</span>] = w[<span class="number">1</span>] = w[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">		now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; born&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (id == DRAGON) &#123;</span><br><span class="line">			w[n % <span class="number">3</span>] = <span class="keyword">new</span> weapon(n % <span class="number">3</span>, atk);</span><br><span class="line">			morale = (b[flag].hp - HP[<span class="number">0</span>]) / (<span class="keyword">double</span>)HP[<span class="number">0</span>];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Its morale is &quot;</span> &lt;&lt; morale &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (id == NINJA) &#123;</span><br><span class="line">			w[n % <span class="number">3</span>] = <span class="keyword">new</span> weapon(n % <span class="number">3</span>, atk);</span><br><span class="line">			w[(n + <span class="number">1</span>) % <span class="number">3</span>] = <span class="keyword">new</span> weapon((n + <span class="number">1</span>) % <span class="number">3</span>, atk);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (id == ICEMAN) w[n % <span class="number">3</span>] = <span class="keyword">new</span> weapon(n % <span class="number">3</span>, atk);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (id == LION) &#123;</span><br><span class="line">			loyalty = b[flag].hp - HP[<span class="number">3</span>];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Its loyalty is &quot;</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; loyalty &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">city</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line">	<span class="keyword">int</span> hp;</span><br><span class="line">	<span class="keyword">int</span> win;	<span class="comment">//战斗胜利数，红连胜x场记为+x</span></span><br><span class="line">&#125; C[<span class="number">22</span>];</span><br><span class="line">solider* c[<span class="number">2</span>][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgefirst</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (C[i].flag == RED || (C[i].flag == VACANT &amp;&amp; i % <span class="number">2</span> == <span class="number">1</span>)) <span class="keyword">return</span> RED;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (C[i].flag == BLUE || (C[i].flag == VACANT &amp;&amp; i % <span class="number">2</span> == <span class="number">0</span>)) <span class="keyword">return</span> BLUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">born</span><span class="params">()</span> </span>&#123;<span class="comment">//武士降生</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> flag = <span class="number">0</span>; flag &lt; <span class="number">2</span>; flag++)</span><br><span class="line">		<span class="keyword">if</span> (b[flag].hp &gt;= HP[CREATE[flag][b[flag].snum % <span class="number">5</span>]]) &#123;</span><br><span class="line">			c[flag][b[flag].n] = <span class="keyword">new</span> solider(b[flag].snum, CREATE[flag][b[flag].snum % <span class="number">5</span>], flag);</span><br><span class="line">			b[flag].hp -= c[flag][b[flag].n]-&gt;hp;</span><br><span class="line">			b[flag].snum++;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//lion逃跑</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i == <span class="number">0</span> &amp;&amp; flag == BLUE) || (i == N + <span class="number">1</span> &amp;&amp; flag == RED)) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i] &amp;&amp; c[flag][i]-&gt;id == LION &amp;&amp; c[flag][i]-&gt;loyalty &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&quot; lion &quot;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; ran away&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				c[flag][i] = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">icemanlosehp</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c[flag][t]-&gt;hp &gt; <span class="number">9</span>) c[flag][t]-&gt;hp -= <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">else</span> c[flag][t]-&gt;hp = <span class="number">1</span>;</span><br><span class="line">	c[flag][t]-&gt;atk += <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headquarter</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c[<span class="number">1</span> - flag][b[flag].n] &amp;&amp; c[<span class="number">1</span> - flag][b[flag].n]-&gt;reached == <span class="number">0</span>) &#123;</span><br><span class="line">		c[<span class="number">1</span> - flag][b[flag].n]-&gt;reached = <span class="number">1</span>;</span><br><span class="line">		now(); <span class="built_in">cout</span> &lt;&lt; B[<span class="number">1</span> - flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - flag][b[flag].n]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - flag][b[flag].n]-&gt;n &lt;&lt; <span class="string">&quot; reached &quot;</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&quot; headquarter with &quot;</span> &lt;&lt; c[<span class="number">1</span> - flag][b[flag].n]-&gt;hp &lt;&lt; <span class="string">&quot; elements and force &quot;</span> &lt;&lt; c[<span class="number">1</span> - flag][b[flag].n]-&gt;atk &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (b[flag].taken) &#123;</span><br><span class="line">			now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&quot; headquarter was taken&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			b[flag].taken = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> b[flag].taken = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">march</span><span class="params">()</span> </span>&#123;<span class="comment">//武士前进和攻占司令部</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = b[<span class="number">1</span> - flag].n;</span><br><span class="line">		<span class="keyword">if</span> (c[flag][t + (flag == RED ? <span class="number">-1</span> : <span class="number">1</span>)]) c[flag][t] = c[flag][t + (flag == RED ? <span class="number">-1</span> : <span class="number">1</span>)];</span><br><span class="line">		<span class="keyword">if</span> (c[flag][t] &amp;&amp; c[flag][t]-&gt;id == ICEMAN &amp;&amp; (t - b[flag].n) % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; c[flag][t]-&gt;reached == <span class="number">0</span>) icemanlosehp(flag, t);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			t = (flag == RED ? i : N + <span class="number">1</span> - i);</span><br><span class="line">			<span class="keyword">int</span> pre = (flag == RED ? t - <span class="number">1</span> : t + <span class="number">1</span>);</span><br><span class="line">			c[flag][t] = c[flag][pre];</span><br><span class="line">			<span class="keyword">if</span> (c[flag][t] &amp;&amp; c[flag][t]-&gt;id == ICEMAN &amp;&amp; (t - b[flag].n) % <span class="number">2</span> == <span class="number">0</span>) icemanlosehp(flag, t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c[RED][<span class="number">0</span>] = c[BLUE][N + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">	headquarter(RED);<span class="comment">//红方司令部</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)<span class="comment">//城市</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i])  now(), <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; marched to city &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; with &quot;</span> &lt;&lt; c[flag][i]-&gt;hp &lt;&lt; <span class="string">&quot; elements and force &quot;</span> &lt;&lt; c[flag][i]-&gt;atk &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	headquarter(BLUE);<span class="comment">//蓝方司令部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hpborn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) C[i].hp += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gethp30</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i] &amp;&amp; !c[<span class="number">1</span> - flag][i]) &#123;</span><br><span class="line">				b[flag].hp += C[i].hp;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; earned &quot;</span> &lt;&lt; C[i].hp &lt;&lt; <span class="string">&quot; elements for his headquarter&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				C[i].hp = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;<span class="comment">//放箭</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)<span class="comment">//城市</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) &#123;</span><br><span class="line">			<span class="keyword">int</span> next = (flag == RED ? i + <span class="number">1</span> : i - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i] &amp;&amp; c[flag][i]-&gt;w[ARROW] &amp;&amp; c[flag][i]-&gt;w[ARROW]-&gt;dur &gt; <span class="number">0</span> &amp;&amp; c[<span class="number">1</span> - flag][next]) &#123;</span><br><span class="line">				c[<span class="number">1</span> - flag][next]-&gt;hp -= R;</span><br><span class="line">				c[flag][i]-&gt;w[ARROW]-&gt;dur--;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; shot&quot;</span>;</span><br><span class="line">				<span class="keyword">if</span> (c[<span class="number">1</span> - flag][next]-&gt;hp &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; and killed &quot;</span> &lt;&lt; B[<span class="number">1</span> - flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - flag][next]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - flag][next]-&gt;n;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usebomb</span><span class="params">()</span> </span>&#123;<span class="comment">//使用bomb</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="keyword">if</span> (c[RED][i] &amp;&amp; c[BLUE][i] &amp;&amp; c[RED][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; (c[RED][i]-&gt;w[BOMB] || c[BLUE][i]-&gt;w[BOMB])) &#123;</span><br><span class="line">			<span class="keyword">int</span> p = judgefirst(i);</span><br><span class="line">			<span class="keyword">int</span> php = c[p][i]-&gt;hp, qhp = c[<span class="number">1</span> - p][i]-&gt;hp;<span class="comment">//攻击方和反击方战斗前的生命</span></span><br><span class="line">			c[p][i]-&gt;hpp = c[p][i]-&gt;hp;</span><br><span class="line">			c[<span class="number">1</span> - p][i]-&gt;hpp = c[<span class="number">1</span> - p][i]-&gt;hp;</span><br><span class="line">			c[<span class="number">1</span> - p][i]-&gt;hp -= (c[p][i]-&gt;atk + (c[p][i]-&gt;w[SWORD] ? c[p][i]-&gt;w[SWORD]-&gt;atk : <span class="number">0</span>));</span><br><span class="line">			<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;hp &gt; <span class="number">0</span>) &#123;<span class="comment">//没打死，反击</span></span><br><span class="line">				<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;id != NINJA) &#123;</span><br><span class="line">					c[p][i]-&gt;hp -= c[<span class="number">1</span> - p][i]-&gt;atk / <span class="number">2</span>;</span><br><span class="line">					<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;w[SWORD]) c[p][i]-&gt;hp -= c[<span class="number">1</span> - p][i]-&gt;w[SWORD]-&gt;atk;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (c[p][i]-&gt;hp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (c[p][i]-&gt;w[BOMB]) &#123;</span><br><span class="line">						now(); <span class="built_in">cout</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; used a bomb and killed &quot;</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">						c[RED][i] = c[BLUE][i] = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> c[p][i]-&gt;hp = c[p][i]-&gt;hpp, c[<span class="number">1</span> - p][i]-&gt;hp = c[<span class="number">1</span> - p][i]-&gt;hpp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> c[p][i]-&gt;hp = c[p][i]-&gt;hpp, c[<span class="number">1</span> - p][i]-&gt;hp = c[<span class="number">1</span> - p][i]-&gt;hpp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//打死了</span></span><br><span class="line">				<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;w[BOMB]) &#123;</span><br><span class="line">					now(); <span class="built_in">cout</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="string">&quot; used a bomb and killed &quot;</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					c[RED][i] = c[BLUE][i] = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> c[p][i]-&gt;hp = c[p][i]-&gt;hpp, c[<span class="number">1</span> - p][i]-&gt;hp = c[<span class="number">1</span> - p][i]-&gt;hpp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cwin</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> i, <span class="keyword">int</span> hp)</span> </span>&#123;<span class="comment">//i城p方主动攻击q方胜利的结算，失败方战前血量hp</span></span><br><span class="line">	<span class="keyword">if</span> (q == <span class="number">2</span>) &#123;<span class="comment">//没人死</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = RED; j &lt;= BLUE; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (c[j][i]-&gt;id == DRAGON) c[j][i]-&gt;morale -= <span class="number">0.2</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[j][i]-&gt;id == LION) c[j][i]-&gt;loyalty -= K;</span><br><span class="line">		&#125;</span><br><span class="line">		C[i].win = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (c[<span class="number">1</span> - q][i]-&gt;id == LION) c[q][i]-&gt;hp += hp;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c[q][i]-&gt;id == WOLF) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = SWORD; j &lt;= ARROW; j++)</span><br><span class="line">				<span class="keyword">if</span> (!c[q][i]-&gt;w[j] &amp;&amp; c[<span class="number">1</span> - q][i]-&gt;w[j]) c[q][i]-&gt;w[j] = c[<span class="number">1</span> - q][i]-&gt;w[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c[q][i]-&gt;id == DRAGON) &#123;</span><br><span class="line">			c[q][i]-&gt;morale += <span class="number">0.2</span>;</span><br><span class="line">			<span class="keyword">if</span> (p == q) c[q][i]-&gt;yell = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q == RED) &#123;</span><br><span class="line">			<span class="keyword">if</span> (C[i].win &gt;= <span class="number">0</span>) C[i].win++;</span><br><span class="line">			<span class="keyword">else</span> C[i].win = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (C[i].win &lt;= <span class="number">0</span>) C[i].win--;</span><br><span class="line">			<span class="keyword">else</span> C[i].win = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cattack</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//在i城p方主动攻击</span></span><br><span class="line">	<span class="keyword">int</span> php = c[p][i]-&gt;hp, qhp = c[<span class="number">1</span> - p][i]-&gt;hp;<span class="comment">//攻击方和反击方战斗前的生命</span></span><br><span class="line">	c[<span class="number">1</span> - p][i]-&gt;hp -= c[p][i]-&gt;atk;</span><br><span class="line">	<span class="keyword">if</span> (c[p][i]-&gt;w[SWORD]) &#123;</span><br><span class="line">		c[<span class="number">1</span> - p][i]-&gt;hp -= c[p][i]-&gt;w[SWORD]-&gt;atk;</span><br><span class="line">		c[p][i]-&gt;w[SWORD]-&gt;atk = c[p][i]-&gt;w[SWORD]-&gt;atk * <span class="number">8</span> / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;hp &gt; <span class="number">0</span>) &#123;<span class="comment">//没打死，反击</span></span><br><span class="line">		<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;id != NINJA) &#123;</span><br><span class="line">			c[p][i]-&gt;hp -= c[<span class="number">1</span> - p][i]-&gt;atk / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;w[SWORD]) &#123;</span><br><span class="line">				c[p][i]-&gt;hp -= c[<span class="number">1</span> - p][i]-&gt;w[SWORD]-&gt;atk;</span><br><span class="line">				c[<span class="number">1</span> - p][i]-&gt;w[SWORD]-&gt;atk = c[<span class="number">1</span> - p][i]-&gt;w[SWORD]-&gt;atk * <span class="number">8</span> / <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c[p][i]-&gt;hp &lt;= <span class="number">0</span>) cwin(p, <span class="number">1</span> - p, i, php);<span class="comment">//主动攻击方死</span></span><br><span class="line">		<span class="keyword">else</span> cwin(p, <span class="number">2</span>, i, <span class="number">0</span>);<span class="comment">//都没死</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cwin(p, p, i, qhp);<span class="comment">//被攻击方死</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">battle</span><span class="params">()</span> </span>&#123;<span class="comment">//主动进攻，反击，战死，欢呼，获取生命，旗帜升起</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)<span class="comment">//对每个城进行战斗</span></span><br><span class="line">		<span class="keyword">if</span> (c[RED][i] &amp;&amp; c[BLUE][i]) &#123;<span class="comment">//有两个武士</span></span><br><span class="line">			c[RED][i]-&gt;hpp = c[RED][i]-&gt;hp;</span><br><span class="line">			c[BLUE][i]-&gt;hpp = c[BLUE][i]-&gt;hp;</span><br><span class="line">			<span class="keyword">if</span> (c[RED][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hp &gt; <span class="number">0</span>) cattack(judgefirst(i), i);<span class="comment">//hp都大于0</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[RED][i]-&gt;hp &lt;= <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hp &gt; <span class="number">0</span>) cwin(judgefirst(i), BLUE, i, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[RED][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hp &lt;= <span class="number">0</span>) cwin(judgefirst(i), RED, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = flag == RED ? i : N + <span class="number">1</span> - i;</span><br><span class="line">			<span class="keyword">if</span> (c[flag][t] &amp;&amp; c[<span class="number">1</span> - flag][t] &amp;&amp; c[flag][t]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[<span class="number">1</span> - flag][t]-&gt;hp &lt;= <span class="number">0</span> &amp;&amp; b[flag].hp &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">				c[flag][t]-&gt;hp += <span class="number">8</span>;</span><br><span class="line">				b[flag].hp -= <span class="number">8</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="keyword">if</span> (c[RED][i] &amp;&amp; c[BLUE][i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> p = judgefirst(i);</span><br><span class="line">			<span class="keyword">if</span> (c[RED][i]-&gt;hpp &gt; <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hpp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; attacked &quot;</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="string">&quot; in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; with &quot;</span> &lt;&lt; c[p][i]-&gt;hpp &lt;&lt; <span class="string">&quot; elements and force &quot;</span> &lt;&lt; c[p][i]-&gt;atk &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;hp &gt; <span class="number">0</span>) &#123;<span class="comment">//没打死，反击</span></span><br><span class="line">					<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;id != NINJA) now(), <span class="built_in">cout</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="string">&quot; fought back against &quot;</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">if</span> (c[p][i]-&gt;hp &lt;= <span class="number">0</span>) now(), <span class="built_in">cout</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; was killed in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> now(), <span class="built_in">cout</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="string">&quot; was killed in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//打死了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (c[p][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[p][i]-&gt;morale &gt;= <span class="number">0.8</span>) now(), <span class="built_in">cout</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&quot; dragon &quot;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; yelled in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">				<span class="keyword">if</span> (c[flag][i] &amp;&amp; c[<span class="number">1</span> - flag][i] &amp;&amp; c[flag][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[<span class="number">1</span> - flag][i]-&gt;hp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					b[flag].hp += C[i].hp;</span><br><span class="line">					now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; earned &quot;</span> &lt;&lt; C[i].hp &lt;&lt; <span class="string">&quot; elements for his headquarter&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					C[i].hp = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> ((C[i].win == <span class="number">2</span> &amp;&amp; C[i].flag != RED) || (C[i].win == <span class="number">-2</span> &amp;&amp; C[i].flag != BLUE)) &#123;</span><br><span class="line">				C[i].flag = (C[i].win == <span class="number">2</span> ? RED : BLUE);</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[C[i].flag] &lt;&lt; <span class="string">&quot; flag raised in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) <span class="keyword">if</span> (c[flag][i] &amp;&amp; c[flag][i]-&gt;hp &lt;= <span class="number">0</span>) c[flag][i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rehp</span><span class="params">()</span> </span>&#123;<span class="comment">//司令部报告生命</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = RED; i &lt;= BLUE; i++) now(), <span class="built_in">cout</span> &lt;&lt; b[i].hp &lt;&lt; <span class="string">&quot; elements in &quot;</span> &lt;&lt; B[i] &lt;&lt; <span class="string">&quot; headquarter&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coutdot</span><span class="params">(<span class="keyword">bool</span>&amp; tmp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tmp) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span>; tmp = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rew</span><span class="params">()</span> </span>&#123;<span class="comment">//武士报告武器</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++)</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i]) &#123;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; has &quot;</span>;</span><br><span class="line">				<span class="keyword">bool</span> tmp = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = ARROW; j &gt;= SWORD; j--)</span><br><span class="line">					<span class="keyword">if</span> (c[flag][i]-&gt;w[j]) &#123;</span><br><span class="line">						<span class="keyword">if</span> (j == SWORD) &#123;</span><br><span class="line">							<span class="keyword">if</span> (c[flag][i]-&gt;w[j]-&gt;atk == <span class="number">0</span>) c[flag][i]-&gt;w[j] = <span class="literal">NULL</span>;</span><br><span class="line">							<span class="keyword">else</span> coutdot(tmp), <span class="built_in">cout</span> &lt;&lt; W[j] &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; c[flag][i]-&gt;w[j]-&gt;atk &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (j == ARROW) &#123;</span><br><span class="line">							<span class="keyword">if</span> (c[flag][i]-&gt;w[j]-&gt;dur == <span class="number">0</span>) c[flag][i]-&gt;w[j] = <span class="literal">NULL</span>;</span><br><span class="line">							<span class="keyword">else</span> coutdot(tmp), <span class="built_in">cout</span> &lt;&lt; W[j] &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; c[flag][i]-&gt;w[j]-&gt;dur &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> coutdot(tmp), <span class="built_in">cout</span> &lt;&lt; W[j];</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">if</span> (!tmp) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no weapon&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化和输入</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N &gt;&gt; R &gt;&gt; K &gt;&gt; T &gt;&gt; HP[<span class="number">0</span>] &gt;&gt; HP[<span class="number">1</span>] &gt;&gt; HP[<span class="number">2</span>] &gt;&gt; HP[<span class="number">3</span>] &gt;&gt; HP[<span class="number">4</span>] &gt;&gt; ATK[<span class="number">0</span>] &gt;&gt; ATK[<span class="number">1</span>] &gt;&gt; ATK[<span class="number">2</span>] &gt;&gt; ATK[<span class="number">3</span>] &gt;&gt; ATK[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = RED; i &lt;= BLUE; i++) &#123;</span><br><span class="line">		b[i].hp = M; b[i].flag = i; b[i].n = (N + <span class="number">1</span>) * i; b[i].snum = <span class="number">0</span>; b[i].taken = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	HOUR = T / <span class="number">60</span>; MIN = T % <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		C[i].flag = VACANT; C[i].hp = <span class="number">0</span>; C[i].win = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) c[flag][i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;<span class="comment">//数据组数</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">		input();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		h = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			m = <span class="number">0</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; born();</span><br><span class="line">			m = <span class="number">5</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; run();</span><br><span class="line">			m = <span class="number">10</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; march();</span><br><span class="line">			<span class="keyword">if</span> (b[RED].taken == <span class="number">2</span> || b[BLUE].taken == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">			m = <span class="number">20</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; hpborn();</span><br><span class="line">			m = <span class="number">30</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; gethp30();</span><br><span class="line">			m = <span class="number">35</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; shoot();</span><br><span class="line">			m = <span class="number">38</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; usebomb();</span><br><span class="line">			m = <span class="number">40</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; battle();</span><br><span class="line">			m = <span class="number">50</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; rehp();</span><br><span class="line">			m = <span class="number">55</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; rew();</span><br><span class="line">			h++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
