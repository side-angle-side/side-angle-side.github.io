<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>利用Tensorflow实现的选课网验证码自动识别AI</title>
    <url>/2021/04/16/PKUAutoEletiveCaptchaHelper/</url>
    <content><![CDATA[<p>前几个星期受朋友的委托，开发了一款针对某大学选课网的验证码识别工具。朋友做的是补退选阶段自动选课部分，而我负责了其中的验证码识别模块。先说一说达到的效果吧，这款工具针对选课网验证码测试集识别率可以达到99.62%，单次识别耗时约0.03秒，实际运行准确率得等到下次选课才知道了，预计不会低于98%。部署在本地可以达到本校学生开发的自动选课工具的平均速度，识别准确度和速度均超越了调用商用验证码识别API。</p>
<a id="more"></a>
<h2 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h2><p>没过几天，我就收到了这样一大包带有标签的验证码图片：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2021/04/16/PKUAutoEletiveCaptchaHelper/g8gs_1615517901796011.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">g8gs_1615517901796011.png</div>
    <br>
</center>

<p>样本总数是19490个，全部爬取自北京大学选课网，并且在打码平台打好了标签。经过简单的观察和分析，我们可以归纳出验证码的以下几个特征：</p>
<ol>
<li>图片分别率为130*52，png格式。</li>
<li>图片只有一个通道，也就是说这张看起来是彩色的图像实际上是灰度图。</li>
<li>图片名前四个字字符即为对应的标签。</li>
<li>图片存在随机添加的噪点和线条，遮挡关系中均位于底层，因此对识别的影响程度不大。</li>
<li>字符有两种表现形式，一种是实心字符，另一种是空心的边框，对识别影响程度未知。</li>
<li>字符与字符间、字符与图片边界间可能存在遮挡关系，对识别影响程度较大。</li>
<li>验证码字符集是字母和数字的子集，具体来说不包含“0，1，i，j，o，z”这6个字符。</li>
<li>验证码不区分大小写，但图片中字符包含大小写。</li>
<li>同一验证码可能出现重复字符。</li>
<li>标签并非完全准确，后期统计估算的结果是，标签整体准确率约为90%。</li>
</ol>
<p>综合以上几点，我们需要做的是输入一张图片，输出一个字符串，这个字符串即为对该图片的识别结果。很显然这是一个多分类问题，分类总数是$30^4=8.1\times 10^5$。对于这个数量级的多分类问题，我对人工智能能否胜任还打了个问号。毕竟随机一个结果，正确的概率约等于中头奖。面向CSDN编程当然能查出不少别人的成功样例，但是别人的代码和我们目前的需求依然存在不小的差异。我也只能以一点点可怜的tensorflow基础开始写代码。</p>
<h2 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h2><p>tensorflow只能接受张量输入，因此我们首先要做的是把读取的图像转换成tensor类型。与此同时，我们还要从图片名中截出标签字段，转换成tensor一起送入神经网络训练。先把字母表写好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alphabet = [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>读入的标签也不能直接喂给模型，需要先转换成独热码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2vec</span>(<span class="params">text</span>):</span></span><br><span class="line">    vector = np.zeros([<span class="number">4</span>, <span class="number">30</span>])</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        idx = <span class="built_in">list</span>.index(c)</span><br><span class="line">        vector[i][idx] = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> vector</span><br></pre></td></tr></table></figure>
<p>在开始我们的工作前，我们还要把一大包图片分成训练集和测试集（当然keras也支持自动分割），我按照80%：20%的比例划分训练集和测试集。训练集中的损失函数值在反向传播时会更新所有的可训练参数，而测试集仅仅计算损失函数值，相当于预测。训练集和测试集不能有交集，否则达不到训练目的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">path=<span class="string">r&#x27;./img/&#x27;</span></span><br><span class="line"><span class="built_in">list</span>=os.listdir(path)</span><br><span class="line">random.shuffle(<span class="built_in">list</span>)</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;./img.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;./img_test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[:<span class="built_in">len</span>(<span class="built_in">list</span>)//<span class="number">5</span>]:</span><br><span class="line">    f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;./img_train.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>[<span class="built_in">len</span>(<span class="built_in">list</span>)//<span class="number">5</span>:]:</span><br><span class="line">    f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>有了这些字母表和函数，我们就可以愉快地往下写读文件的函数了。为了比较模型的稳定性，每次训练我都会随机划分训练集和测试集。我们把图片转换成numpy数组格式并进行归一化，tensorflow可直接读取numpy数组并转换成张量。归一化非常重要，否则你会看到模型loss函数和所有可训练参数直接飞升，通通显示NaN。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateds</span>(<span class="params">path, txt</span>):</span></span><br><span class="line">    f = <span class="built_in">open</span>(txt, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">    contents = f.readlines() </span><br><span class="line">    random.shuffle(contents)</span><br><span class="line">    f.close() </span><br><span class="line">    x, y_ = [], [] </span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">        value = text2vec(content[:<span class="number">4</span>])</span><br><span class="line">        img_path = path + content </span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path[:-<span class="number">1</span>])</span><br><span class="line">        img = np.array(img) </span><br><span class="line">        img = img / <span class="number">255.</span></span><br><span class="line">        x.append(img) </span><br><span class="line">        y_.append(value)</span><br><span class="line">    x = np.array(x)</span><br><span class="line">    y_ = np.array(y_)</span><br><span class="line">    x = x.astype(np.float32)</span><br><span class="line">    y_ = y_.astype(np.float32) </span><br><span class="line">    x = np.expand_dims(x, axis=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> x, y_ </span><br></pre></td></tr></table></figure>
<p>当然，实际的代码过程并没有我在这里展示的如此简单，一个极易被忽略的细节是通道。正常的RGB图有三个维度：宽度、高度和通道数。然而这奇葩的验证码竟然没有通道维！傻乎乎的我直接把tensor喂到模型中，报错显示维度不匹配。这小样竟然只有三个维度(None, 52, 130)，而二维卷积需要四个维度！琢磨了半天，我想直接给你加上通道维行不行，于是给图片张量添加了3号维度。竟然行了！这小家伙可是折磨了我整整一个晚上啊。</p>
<p>另外值得注意的是，二维卷积需求的张量维度分别是batch数、高度、宽度和通道数。碰巧numpy数组也是高度维在前，宽度维在后，如果反过来的话也很容易中招。</p>
<h2 id="利用keras搭建卷积神经网络"><a href="#利用keras搭建卷积神经网络" class="headerlink" title="利用keras搭建卷积神经网络"></a>利用keras搭建卷积神经网络</h2><p>keras已经把tensorflow的方法封装得相当到位了，搭建网络的过程并没有给我造成太大的困难。我先比较了一下常见的CNN代码实现难度，VGGNet算是最好写的，不用写类就能搞得定，而且代码结构也很规整。如果识别水平实在不行，那就再试试别的，比如InceptionNet或是ResNet。</p>
<p>我对VGGNet做了一些调整，在这里卷积神经网络基本结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model: &quot;model&quot;</span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">Layer (type)                    Output Shape         Param #     Connected to                     </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">input_1 (InputLayer)            [(None, 52, 130, 1)] 0                                            </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d (Conv2D)                 (None, 52, 130, 32)  320         input_1[0][0]                    </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization (BatchNorma (None, 52, 130, 32)  128         conv2d[0][0]                     </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation (Activation)         (None, 52, 130, 32)  0           batch_normalization[0][0]        </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_1 (Conv2D)               (None, 52, 130, 32)  9248        activation[0][0]                 </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_1 (BatchNor (None, 52, 130, 32)  128         conv2d_1[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_1 (Activation)       (None, 52, 130, 32)  0           batch_normalization_1[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">max_pooling2d (MaxPooling2D)    (None, 26, 65, 32)   0           activation_1[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dropout (Dropout)               (None, 26, 65, 32)   0           max_pooling2d[0][0]              </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_2 (Conv2D)               (None, 26, 65, 64)   18496       dropout[0][0]                    </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_2 (BatchNor (None, 26, 65, 64)   256         conv2d_2[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_2 (Activation)       (None, 26, 65, 64)   0           batch_normalization_2[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_3 (Conv2D)               (None, 26, 65, 64)   36928       activation_2[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_3 (BatchNor (None, 26, 65, 64)   256         conv2d_3[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_3 (Activation)       (None, 26, 65, 64)   0           batch_normalization_3[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">max_pooling2d_1 (MaxPooling2D)  (None, 13, 33, 64)   0           activation_3[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dropout_1 (Dropout)             (None, 13, 33, 64)   0           max_pooling2d_1[0][0]            </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_4 (Conv2D)               (None, 13, 33, 128)  73856       dropout_1[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_4 (BatchNor (None, 13, 33, 128)  512         conv2d_4[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_4 (Activation)       (None, 13, 33, 128)  0           batch_normalization_4[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_5 (Conv2D)               (None, 13, 33, 128)  147584      activation_4[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_5 (BatchNor (None, 13, 33, 128)  512         conv2d_5[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_5 (Activation)       (None, 13, 33, 128)  0           batch_normalization_5[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">max_pooling2d_2 (MaxPooling2D)  (None, 7, 17, 128)   0           activation_5[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dropout_2 (Dropout)             (None, 7, 17, 128)   0           max_pooling2d_2[0][0]            </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_6 (Conv2D)               (None, 7, 17, 256)   295168      dropout_2[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_6 (BatchNor (None, 7, 17, 256)   1024        conv2d_6[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_6 (Activation)       (None, 7, 17, 256)   0           batch_normalization_6[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_7 (Conv2D)               (None, 7, 17, 256)   590080      activation_6[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_7 (BatchNor (None, 7, 17, 256)   1024        conv2d_7[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_7 (Activation)       (None, 7, 17, 256)   0           batch_normalization_7[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">max_pooling2d_3 (MaxPooling2D)  (None, 4, 9, 256)    0           activation_7[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dropout_3 (Dropout)             (None, 4, 9, 256)    0           max_pooling2d_3[0][0]            </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_8 (Conv2D)               (None, 4, 9, 512)    1180160     dropout_3[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_8 (BatchNor (None, 4, 9, 512)    2048        conv2d_8[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_8 (Activation)       (None, 4, 9, 512)    0           batch_normalization_8[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">conv2d_9 (Conv2D)               (None, 4, 9, 512)    2359808     activation_8[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">batch_normalization_9 (BatchNor (None, 4, 9, 512)    2048        conv2d_9[0][0]                   </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">activation_9 (Activation)       (None, 4, 9, 512)    0           batch_normalization_9[0][0]      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">max_pooling2d_4 (MaxPooling2D)  (None, 2, 5, 512)    0           activation_9[0][0]               </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dropout_4 (Dropout)             (None, 2, 5, 512)    0           max_pooling2d_4[0][0]            </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">flatten (Flatten)               (None, 5120)         0           dropout_4[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dense (Dense)                   (None, 4096)         20975616    flatten[0][0]                    </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dropout_5 (Dropout)             (None, 4096)         0           dense[0][0]                      </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dense_1 (Dense)                 (None, 4096)         16781312    dropout_5[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dropout_6 (Dropout)             (None, 4096)         0           dense_1[0][0]                    </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dense_2 (Dense)                 (None, 30)           122910      dropout_6[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dense_3 (Dense)                 (None, 30)           122910      dropout_6[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dense_4 (Dense)                 (None, 30)           122910      dropout_6[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">dense_5 (Dense)                 (None, 30)           122910      dropout_6[0][0]                  </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">tf.convert_to_tensor (TFOpLambd (4, None, 30)        0           dense_2[0][0]                    </span><br><span class="line">                                                                 dense_3[0][0]                    </span><br><span class="line">                                                                 dense_4[0][0]                    </span><br><span class="line">                                                                 dense_5[0][0]                    </span><br><span class="line">__________________________________________________________________________________________________</span><br><span class="line">tf.compat.v1.transpose (TFOpLam (None, 4, 30)        0           tf.convert_to_tensor[0][0]       </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Total params: 42,968,152</span><br><span class="line">Trainable params: 42,964,184</span><br><span class="line">Non-trainable params: 3,968</span><br><span class="line">__________________________________________________________________________________________________</span><br></pre></td></tr></table></figure>
<p>第一部分是10层卷积。使用3*3的卷积核，卷积核个数从32开始，每两层变成原来的两倍，与此同时深度也会变为原来的两倍。卷积步长为1，使用全零填充。接着进行批标准化操作，使用relu激活函数。每两层我们做一次2*2的最大池化，池化步长为2，使用全零填充。每两层我们舍弃一次，每层舍弃20%的节点以防止模型过拟合。</p>
<p>第二部分是两层4096个节点的全连接，全连接前先把张量拉直成一维，采用relu激活函数。最后一步是连接到输出层，这里我们使用了4个全连接层代表了输出的四个字符，在这里我们使用softmax激活函数使输出符合概率分布。为了匹配最终的输出结果，我们还要调换一下输出张量的维度顺序。</p>
<p>最后的模型代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> *</span><br><span class="line">input_tensor = Input((<span class="number">52</span>, <span class="number">130</span>, <span class="number">1</span>))</span><br><span class="line">x = input_tensor</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    x = Convolution2D(filters=<span class="number">32</span> * <span class="number">2</span> ** (i // <span class="number">2</span>), kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    x = BatchNormalization()(x)</span><br><span class="line">    x = Activation(activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        x = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">        x = Dropout(<span class="number">0.2</span>)(x)</span><br><span class="line">x = Flatten()(x)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    x = Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">x = tf.convert_to_tensor([Dense(<span class="number">30</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)(x) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)])</span><br><span class="line">x = tf.transpose(x, perm=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h2 id="训练卷积神经网络"><a href="#训练卷积神经网络" class="headerlink" title="训练卷积神经网络"></a>训练卷积神经网络</h2><p>炼丹炉已经造好，原料也已准备完毕，现在终于可以开始“炼丹”了。加载模型，设置好优化器，设置好损失函数和准确度，设置好存档和断点续训，设置好batch大小和epoch，设置好回调函数，喂入数据和标签，现在开始听天由命了，我也不知道这台机器能学成什么鬼样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> *</span><br><span class="line">train_path = <span class="string">&#x27;./img/&#x27;</span></span><br><span class="line">train_txt = <span class="string">&#x27;./venv/img_train.txt&#x27;</span></span><br><span class="line">test_path = <span class="string">&#x27;./img/&#x27;</span></span><br><span class="line">test_txt = <span class="string">&#x27;./img_test.txt&#x27;</span></span><br><span class="line">x_train, y_train = generateds(train_path, train_txt)</span><br><span class="line">x_test, y_test = generateds(test_path, test_txt)</span><br><span class="line">model = Model(input_tensor, x)</span><br><span class="line">optimizer = Adadelta(learning_rate=<span class="number">0.8</span>)</span><br><span class="line">reduce_lr = LearningRateScheduler(scheduler)</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,optimizer=optimizer,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">checkpoint_save_path = <span class="string">&quot;./captcha.ckpt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(checkpoint_save_path + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">    print(<span class="string">&#x27;-------------load the model-----------------&#x27;</span>)</span><br><span class="line">    model.load_weights(checkpoint_save_path)</span><br><span class="line">cp_callback = ModelCheckpoint(filepath=checkpoint_save_path,save_weights_only=<span class="literal">True</span>, save_best_only=<span class="literal">True</span>)</span><br><span class="line">history = model.fit(x_train, y_train, batch_size=<span class="number">64</span>, epochs=<span class="number">20</span>, validation_data=(x_test, y_test), validation_freq=<span class="number">1</span>,callbacks=[cp_callback, reduce_lr])</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p>训了几个小时，我就发现有点不对劲了。loss函数和准确度几乎没有收敛的意思，仍在瞎蒙附近徘徊。这事就有点诡异了，按理说是会收敛的，难道是我的学习率还不够大？我的学习率是默认的0.01，这么复杂的模型，光是训练一轮就要40s，如果调大学习率恐怕会出现不收敛的情况。保险起见，我让它以低学习率通宵训练，看看800个epoch后是个什么样。</p>
<p>第二天早上起来，炼丹的结果让我喜出望外。一个晚上的风扇轰鸣没有白费，虽然开始的100个epoch的确是瞎蒙，但后来神经网络似乎找到了门道，准确度开始线性增长。单字符准确度从0.03增加到0.7，现在神经网络已经从人工智障逐步训练成人工智能了，但离应用还天远地远。4个字符组成的验证码准确度是单字符的4次方，也就是$0.7^4=0.2401$，从应用角度来看和完全不能用也没什么区别。也就是说，学到了，但没有完全学到。</p>
<p>接下来要做的事就简单了，我们仅需可劲地提高学习率。当然，高学习率也就导致了模型在短短10个epoch后准确率就达到90%，此后模型迅速出现过拟合现象。为此，我们需要设置指数衰减学习率，也就有了以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.backend <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scheduler</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> epoch != <span class="number">0</span>:</span><br><span class="line">        lr = get_value(model.optimizer.lr)</span><br><span class="line">        set_value(model.optimizer.lr, lr * <span class="number">0.5</span>)</span><br><span class="line">        print(<span class="string">&quot;lr changed to &#123;&#125;&quot;</span>.<span class="built_in">format</span>(lr * <span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">return</span> get_value(model.optimizer.lr)</span><br></pre></td></tr></table></figure>
<p>为了直观地显示训练进度，可以使用matplotlib绘制acc曲线。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">acc = history.history[<span class="string">&#x27;accuracy&#x27;</span>]</span><br><span class="line">val_acc = history.history[<span class="string">&#x27;val_accuracy&#x27;</span>]</span><br><span class="line">acc = [i ** <span class="number">4</span> <span class="keyword">for</span> i <span class="keyword">in</span> acc]</span><br><span class="line">val_acc = [i ** <span class="number">4</span> <span class="keyword">for</span> i <span class="keyword">in</span> val_acc]</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(acc, label=<span class="string">&#x27;Training Accuracy&#x27;</span>)</span><br><span class="line">plt.plot(val_acc, label=<span class="string">&#x27;Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Training and Validation Accuracy&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="优化识别准确率"><a href="#优化识别准确率" class="headerlink" title="优化识别准确率"></a>优化识别准确率</h2><p>在接下来的几个小时里，通过不断调整模型参数，单字符准确度从0.7迅速增加到0.95，训练一次模型的时间也从30分钟缩短到15分钟。然而，$0.95^4\approx0.815$，这依然达不到可应用的水平。现在我可以一个个的看看模型和标签不一样的地方在哪里了。我们先写个译码函数把输出张量转换成字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">y</span>):</span></span><br><span class="line">    y = np.argmax(y, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([alphabet[x] <span class="keyword">for</span> x <span class="keyword">in</span> y])</span><br></pre></td></tr></table></figure>
<p>把所有图片一起喂进去，和标签不一样的全部打印出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_ans, y_ans = generateds(train_path, <span class="string">&#x27;./venv/img.txt&#x27;</span>)</span><br><span class="line">y_pred = model.predict(x_ans)</span><br><span class="line">ans = []</span><br><span class="line">pred = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y_ans:</span><br><span class="line">    ans.append(decode(i))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y_pred:</span><br><span class="line">    pred.append(decode(i))</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ans)):</span><br><span class="line">    <span class="keyword">if</span> ans[i] != pred[i]:</span><br><span class="line">        <span class="keyword">if</span> j % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(j)</span><br><span class="line">        print(ans[i], <span class="string">&#x27;  &#x27;</span>, pred[i])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">print(j)</span><br></pre></td></tr></table></figure>
<p>好家伙，打印出1500多个！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sgan    sgam</span><br><span class="line">mam7    mamv</span><br><span class="line">tfsm    tfsn</span><br><span class="line">5mdh    4mdh</span><br><span class="line">d8fr    dbfr</span><br><span class="line">dcsb    d2sb</span><br><span class="line">htvn    htvm</span><br><span class="line">qm46    qh46</span><br><span class="line">cwpa    gwpa</span><br><span class="line">glmf    glmt</span><br><span class="line">wm4e    wmhe</span><br><span class="line">hapl    hbpl</span><br><span class="line">srgk    spgk</span><br><span class="line">mxms    mxm5</span><br><span class="line">bums    bum5</span><br><span class="line">twut    twu7</span><br><span class="line">apvn    apvh</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>点进去一个，一看是标签错了。又点进去一个，又是标签错了……一个个看下来有八成都是标签的错。看来我的神经网络也没有那么不堪嘛。修改标签的这部分工作实在是令人难以忍受，我足足花了几乎两个整天才把1500多个验证码一一人工看过一遍。当然，蛮干是不可能的，最好的办法是一边修改标签一边重新训练模型提高准确度。后来的训练结果如下，仅仅训练20轮准确率就达到99%以上，此时甚至还在欠拟合区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Epoch 1&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 38s 140ms&#x2F;step - loss: 4.0398 - accuracy: 0.0437 - val_loss: 3.3373 - val_accuracy: 0.0412</span><br><span class="line">Epoch 2&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 31s 128ms&#x2F;step - loss: 3.2931 - accuracy: 0.0583 - val_loss: 3.7456 - val_accuracy: 0.0402</span><br><span class="line">Epoch 3&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 31s 129ms&#x2F;step - loss: 2.9358 - accuracy: 0.1276 - val_loss: 3.1022 - val_accuracy: 0.1287</span><br><span class="line">Epoch 4&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 129ms&#x2F;step - loss: 2.1117 - accuracy: 0.3075 - val_loss: 1.4998 - val_accuracy: 0.4837</span><br><span class="line">Epoch 5&#x2F;20</span><br><span class="line">lr changed to 0.4000000059604645</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.9710 - accuracy: 0.6563 - val_loss: 0.8676 - val_accuracy: 0.7014</span><br><span class="line">Epoch 6&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.5527 - accuracy: 0.8030 - val_loss: 0.2733 - val_accuracy: 0.9088</span><br><span class="line">Epoch 7&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 129ms&#x2F;step - loss: 0.3350 - accuracy: 0.8831 - val_loss: 0.1302 - val_accuracy: 0.9582</span><br><span class="line">Epoch 8&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.2138 - accuracy: 0.9277 - val_loss: 0.1094 - val_accuracy: 0.9643</span><br><span class="line">Epoch 9&#x2F;20</span><br><span class="line">lr changed to 0.20000000298023224</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.1041 - accuracy: 0.9646 - val_loss: 0.0466 - val_accuracy: 0.9863</span><br><span class="line">Epoch 10&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.0779 - accuracy: 0.9747 - val_loss: 0.0421 - val_accuracy: 0.9890</span><br><span class="line">Epoch 11&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.0599 - accuracy: 0.9795 - val_loss: 0.0376 - val_accuracy: 0.9902</span><br><span class="line">Epoch 12&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 129ms&#x2F;step - loss: 0.0532 - accuracy: 0.9824 - val_loss: 0.0319 - val_accuracy: 0.9919</span><br><span class="line">Epoch 13&#x2F;20</span><br><span class="line">lr changed to 0.10000000149011612</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.0376 - accuracy: 0.9876 - val_loss: 0.0323 - val_accuracy: 0.9927</span><br><span class="line">Epoch 14&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.0321 - accuracy: 0.9889 - val_loss: 0.0306 - val_accuracy: 0.9931</span><br><span class="line">Epoch 15&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 130ms&#x2F;step - loss: 0.0283 - accuracy: 0.9905 - val_loss: 0.0271 - val_accuracy: 0.9942</span><br><span class="line">Epoch 16&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 32s 132ms&#x2F;step - loss: 0.0259 - accuracy: 0.9906 - val_loss: 0.0254 - val_accuracy: 0.9947</span><br><span class="line">Epoch 17&#x2F;20</span><br><span class="line">lr changed to 0.05000000074505806</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 35s 145ms&#x2F;step - loss: 0.0221 - accuracy: 0.9922 - val_loss: 0.0235 - val_accuracy: 0.9949</span><br><span class="line">Epoch 18&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 35s 145ms&#x2F;step - loss: 0.0186 - accuracy: 0.9936 - val_loss: 0.0258 - val_accuracy: 0.9944</span><br><span class="line">Epoch 19&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 36s 146ms&#x2F;step - loss: 0.0154 - accuracy: 0.9949 - val_loss: 0.0241 - val_accuracy: 0.9951</span><br><span class="line">Epoch 20&#x2F;20</span><br><span class="line">244&#x2F;244 [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] - 35s 145ms&#x2F;step - loss: 0.0197 - accuracy: 0.9933 - val_loss: 0.0234 - val_accuracy: 0.9951</span><br></pre></td></tr></table></figure>
<p>可视化结果如下：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2021/04/16/PKUAutoEletiveCaptchaHelper/final.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;"></div>
    <br>
</center>

<p>最后一次训练和标签不一致的样本数是75个，准确率达到99.62%。我们随便找个不一样的看看：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2021/04/16/PKUAutoEletiveCaptchaHelper/glmf_1615512501114772.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    "></div>
    <br>
</center>

<p>AI认为它是“glmf”，还是挺阴间的对吧？</p>
<h2 id="封装识别模块"><a href="#封装识别模块" class="headerlink" title="封装识别模块"></a>封装识别模块</h2><p>至此，我们的炼丹算是全部完成了，最后生成的模型文件有491MB。我们把模型的预测部分单独拎出来，封装成一个识别函数，输入图片路径返回字符串。把加载神经网络的部分封装成另一个函数，在主程序开始时调用以加载神经网络。实测加载神经网络大约需要1秒，每调用一次识别函数大约需要0.03秒。在识别函数处我预留了同时识别多张图片的接口，但目前还看不到有此需求。实际上由于并行计算的特性，一次识别不太多的多张图片所花的时间几乎相同。验证码识别部分的完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主程序开始时调用此函数加载神经网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    <span class="comment"># 输入层</span></span><br><span class="line">    input_tensor = Input((<span class="number">52</span>, <span class="number">130</span>, <span class="number">1</span>))</span><br><span class="line">    x = input_tensor</span><br><span class="line">    <span class="comment"># 10层卷积，每层批标准化，采用relu激活，每两层进行一次最大池化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        x = Convolution2D(filters=<span class="number">32</span> * <span class="number">2</span> ** (i // <span class="number">2</span>), kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">        x = BatchNormalization()(x)</span><br><span class="line">        x = Activation(activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            x = MaxPooling2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">    <span class="comment"># 拉直成一维送入全连接</span></span><br><span class="line">    x = Flatten()(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        x = Dense(<span class="number">4096</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment"># 输出层</span></span><br><span class="line">    x = tf.convert_to_tensor([Dense(<span class="number">30</span>, activation=<span class="string">&#x27;softmax&#x27;</span>)(x) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)])</span><br><span class="line">    x = tf.transpose(x, perm=[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="comment"># 加载神经网络</span></span><br><span class="line">    model = Model(input_tensor, x)</span><br><span class="line">    checkpoint = <span class="string">&quot;./captcha.ckpt&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(checkpoint + <span class="string">&#x27;.index&#x27;</span>):</span><br><span class="line">        model.load_weights(checkpoint)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别验证码，参数为图片路径和模型，返回值为识别结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">path, model</span>):</span></span><br><span class="line">    alphabet = [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;k&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">    <span class="comment"># 读取图片，预处理</span></span><br><span class="line">    x_arr = []</span><br><span class="line">    img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">    img = np.array(img)</span><br><span class="line">    img = img / <span class="number">255.</span></span><br><span class="line">    x_arr.append(img)</span><br><span class="line">    <span class="comment"># 转化为np_array并添加通道维</span></span><br><span class="line">    x_arr = np.array(x_arr)</span><br><span class="line">    x_arr = x_arr.astype(np.float32)</span><br><span class="line">    x_arr = np.expand_dims(x_arr, axis=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 识别结果并输出</span></span><br><span class="line">    y_arr = model.predict(x_arr)</span><br><span class="line">    pred = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> y_arr:</span><br><span class="line">        n = np.argmax(i, axis=<span class="number">1</span>)</span><br><span class="line">        pred.append(<span class="string">&#x27;&#x27;</span>.join([alphabet[j] <span class="keyword">for</span> j <span class="keyword">in</span> n]))</span><br><span class="line">    <span class="keyword">return</span> pred[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2021/04/16/PKUAutoEletiveCaptchaHelper/QRcode.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">扫描二维码阅读原文</div>
    <br>
</center>]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/04/20/newDSA/</url>
    <content><![CDATA[<h2 id="一-概论"><a href="#一-概论" class="headerlink" title="一    概论"></a>一    概论</h2><h3 id="1-1-数据结构和抽象数据类型"><a href="#1-1-数据结构和抽象数据类型" class="headerlink" title="1.1    数据结构和抽象数据类型"></a>1.1    数据结构和抽象数据类型</h3><p>数据结构包括逻辑、存储和运算三个部分。逻辑结构包括线性结构和非线性结构，线性结构包括线性表，非线性结构包括树和图。数据的存储结构是逻辑结构到物理存储单元的映射，包括顺序、链接、索引和散列。抽象数据类型（ADT）定义了一组运算的数学模型，与物理存储结构无关，它隐藏了运算实现的细节和内部数据结构，利于软件复用。</p>
<h3 id="1-2-算法特性和分类"><a href="#1-2-算法特性和分类" class="headerlink" title="1.2    算法特性和分类"></a>1.2    算法特性和分类</h3><p>算法具有通用性、有效性、确定性、有穷性的特点。基本算法分类包括穷举、回溯、搜索、递归、分治、贪心、动态规划等。</p>
<h3 id="1-3-算法复杂性分析"><a href="#1-3-算法复杂性分析" class="headerlink" title="1.3    算法复杂性分析"></a>1.3    算法复杂性分析</h3><p>令$p(n)$和$q(n)$是两个非负函数，称$p(n)$渐进地大于$q(n)$当且仅当</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}\frac{q(n)}{p(n)}=0</script><p>称$q(n)$渐进地小于$p(n)$当且仅当$p(n)$渐进地大于$q(n)$，称$p(n)$渐进地等于$q(n)$当且仅当$q(n)$不渐进地大于$p(n)$且$p(n)$不渐进地大于$q(n)$。</p>
<p>记法$f(n)=O(g(n))$中表示$f(n)$渐进地小于或等于$g(n)$。</p>
<p>记法$f(n)=\Omega(g(n))$中表示$f(n)$渐进地大于或等于$g(n)$。</p>
<p>记法$f(n)=\Theta(g(n))$中表示$f(n)$渐进地等于$g(n)$。</p>
<p>记法$f(n)=o(g(n))$中表示$f(n)$渐进地小于$g(n)$。</p>
<p>$g(n)$通常为系数为1的单项。</p>
<a id="more"></a>
<h2 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二    线性表"></a>二    线性表</h2><h3 id="myList-h"><a href="#myList-h" class="headerlink" title="myList.h"></a>myList.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//myList.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                    <span class="comment">// 置空线性表</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                    <span class="comment">// 线性表为空时，返回True</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;                <span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;            <span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>;                <span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> p)</span></span>;                <span class="comment">// 返回位置p的元素值</span></span><br><span class="line">    <span class="function">T <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;            <span class="comment">// 用value修改位置p的元素值</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h3 id="arrList-h"><a href="#arrList-h" class="headerlink" title="arrList.h"></a>arrList.h</h3><p><a herf="myList.h">#include “myList.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>            <span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrList</span> :</span> <span class="keyword">public</span> List&lt;T&gt; &#123;        <span class="comment">// 顺序表，向量</span></span><br><span class="line"><span class="keyword">private</span>:                        <span class="comment">// 线性表的取值类型和取值空间</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;                <span class="comment">// 私有变量，顺序表实例的最大长度</span></span><br><span class="line">    <span class="keyword">int</span> curLen;                    <span class="comment">// 私有变量，顺序表实例的当前长度</span></span><br><span class="line">    <span class="keyword">int</span> position;                <span class="comment">// 私有变量，当前处理位置</span></span><br><span class="line">    T *aList;                    <span class="comment">// 私有变量，存储顺序表的实例</span></span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 顺序表的运算集</span></span><br><span class="line">    arrList(<span class="keyword">const</span> <span class="keyword">int</span> size) &#123;        <span class="comment">// 创建一个新的顺序表，参数为表实例的最大长度</span></span><br><span class="line">        maxSize = size;</span><br><span class="line">        aList = <span class="keyword">new</span> T[maxSize];</span><br><span class="line">        curLen = position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~arrList() &#123;                    <span class="comment">// 析构函数，用于消除该表实例</span></span><br><span class="line">        <span class="keyword">delete</span>[] aList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                <span class="comment">// 将顺序表存储的内容清除，成为空表</span></span><br><span class="line">        <span class="keyword">delete</span>[] aList;</span><br><span class="line">        curLen = position = <span class="number">0</span>;</span><br><span class="line">        aList = <span class="keyword">new</span> T[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;                    <span class="comment">// 返回此顺序表的当前实际长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;            <span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;        <span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>;            <span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPos</span><span class="params">(<span class="keyword">const</span> T value)</span></span>;        <span class="comment">// 在线性表中查找值为value的元素，并返回第1次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;                     <span class="comment">// 打印线性表 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T </span></span><br><span class="line"><span class="keyword">int</span> arrList&lt;T&gt;::getPos(<span class="keyword">const</span> T value) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;                            <span class="comment">// 元素下标</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; curLen; i++) &#123;                <span class="comment">// 依次比较</span></span><br><span class="line">        <span class="keyword">if</span> (value == aList[i])            <span class="comment">// 下标为i的元素与value相等</span></span><br><span class="line">            <span class="keyword">return</span> i;                <span class="comment">// 返回下标i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                        <span class="comment">// 顺序表没有元素值为value的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设元素的类型为T， aList是存储顺序表的数组， maxSize是其最大长度；</span></span><br><span class="line"><span class="comment">// p为新元素value的插入位置,</span></span><br><span class="line"><span class="comment">// 插入成功则返回true, 否则返回false</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> arrList&lt;T&gt;::insert(<span class="keyword">int</span> p, <span class="keyword">const</span> T value) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (curLen &gt;= maxSize) &#123;                <span class="comment">// 检查顺序表是否溢出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The list is overflow&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; curLen) &#123;                <span class="comment">// 检查插入位置是否合法</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insertion is illegal&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = curLen; i &gt; p; i--)</span><br><span class="line">        aList[i] = aList[i - <span class="number">1</span>];            <span class="comment">// 从表尾curLen -1起往右移动直到p</span></span><br><span class="line">    aList[p] = value;                    <span class="comment">// 位置p处插入新元素</span></span><br><span class="line">    curLen++;                        <span class="comment">// 表的实际长度增1 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> arrList&lt;T&gt;::del(<span class="keyword">int</span> p) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (curLen &lt;= <span class="number">0</span>) &#123;                <span class="comment">// 检查顺序表是否为空</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; No element to delete \n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; curLen - <span class="number">1</span>) &#123;            <span class="comment">// 检查删除位置是否合法</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deletion is illegal\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = p; i &lt; curLen - <span class="number">1</span>; i++)</span><br><span class="line">        aList[i] = aList[i + <span class="number">1</span>];            <span class="comment">// 从位置p开始每个元素左移直到curLen,</span></span><br><span class="line">    curLen--;                        <span class="comment">// 表的实际长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">void</span> arrList&lt;T&gt;::print() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curLen; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; aList[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Link-h"><a href="#Link-h" class="headerlink" title="Link.h"></a>Link.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;                            <span class="comment">// 用于保存结点元素的内容</span></span><br><span class="line">    Link *next;                        <span class="comment">// 指向后继结点的指针</span></span><br><span class="line">    Link(<span class="keyword">const</span> T info, Link *nextValue = <span class="literal">NULL</span>) &#123;    <span class="comment">// 具有两个参数的Link构造函数</span></span><br><span class="line">        data = info;</span><br><span class="line">        next = nextValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Link(Link *nextValue = <span class="literal">NULL</span>) &#123;            <span class="comment">// 具有一个参数的Link构造函数</span></span><br><span class="line">        next = nextValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lnkList-h"><a href="#lnkList-h" class="headerlink" title="lnkList.h"></a>lnkList.h</h3><p><a herf="Link.h">#include “Link.h”</a></p>
<p><a herf="myList.h">#include “myList.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myList.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Link.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkList</span> :</span> <span class="keyword">public</span> List&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Link&lt;T&gt; *head;                    <span class="comment">// 单链表的头指针</span></span><br><span class="line">    Link&lt;T&gt; *tail;                    <span class="comment">// 单链表的尾指针</span></span><br><span class="line">    <span class="function">Link&lt;T&gt; *<span class="title">setPos</span><span class="params">(<span class="keyword">int</span> p)</span></span>;                <span class="comment">// 返回线性表指向第p个元素的指针值     </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    lnkList(<span class="keyword">int</span>);                        <span class="comment">// 构造函数</span></span><br><span class="line">    ~lnkList();                        <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                     <span class="comment">// 将链表存储的内容清除，成为空表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;                              <span class="comment">// 返回此顺序表的当前实际长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;                   <span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;            <span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>;                     <span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;           <span class="comment">// 返回位置p的元素值 </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getPos</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> T value)</span></span>;    <span class="comment">// 查找值为value的元素，并返回第1次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">lnkList&lt;T&gt;::lnkList(<span class="keyword">int</span> defSize) &#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Link&lt;T&gt;(<span class="number">9999</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">lnkList&lt;T&gt;::~lnkList() &#123;</span><br><span class="line">    Link&lt;T&gt; *tmp;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定线性表的元素类型为T</span></span><br><span class="line">Link&lt;T&gt; *lnkList&lt;T&gt;::setPos(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    Link&lt;T&gt; *p;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">-1</span>)                   <span class="comment">// i为-1则定位到&quot;虚&quot;头结点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Link&lt;T&gt;(head-&gt;next);      <span class="comment">// 若i为0则定位到第一个结点     </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; count &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> p;                <span class="comment">// 指向第 i 结点，i＝0,1,…，当链表中结点数小于i时返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 线性表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> lnkList&lt;T&gt;::insert(<span class="keyword">int</span> i, T value) &#123;</span><br><span class="line">    Link&lt;T&gt; *p, *q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = setPos(i - <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;        <span class="comment">// p是第i个结点的前驱</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; the insertion point is illegal&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = <span class="keyword">new</span> Link&lt;T&gt;(value, p-&gt;next);</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    <span class="keyword">if</span> (p == tail)                        <span class="comment">// 插入点在链尾，插入结点成为新的链尾</span></span><br><span class="line">        tail = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete a node from singly linked list</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 线性表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> lnkList&lt;T&gt;::del(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    Link&lt;T&gt; *p, *q;</span><br><span class="line">    <span class="keyword">if</span> ((p = setPos(i - <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;        <span class="comment">// 待删结点不存在，即给定的i大于当前链中元素个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; the deletion point is illegal&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;next;                            <span class="comment">// q是真正待删结点</span></span><br><span class="line">    <span class="keyword">if</span> (q == tail) &#123;                        <span class="comment">// 待删结点为尾结点，则修改尾指针</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;                        <span class="comment">// 删除结点q 并修改链指针</span></span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">void</span> lnkList&lt;T&gt;::print() &#123;</span><br><span class="line">    Link&lt;T&gt; *tmp = head;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;begin\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;end\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-栈与队列"><a href="#三-栈与队列" class="headerlink" title="三    栈与队列"></a>三    栈与队列</h2><h3 id="myStack-h"><a href="#myStack-h" class="headerlink" title="myStack.h"></a>myStack.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//myStack.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> 					<span class="comment">// 栈的元素类型为 T</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: 	            			<span class="comment">// 栈的运算集</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;	   			<span class="comment">// 变为空栈</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span></span>; 		<span class="comment">// item入栈，成功则返回真，否则返回假</span></span><br><span class="line"> 	<span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;				<span class="comment">// 返回栈顶内容并弹出，成功返回真，否则返回假,</span></span><br><span class="line"> 	<span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T&amp; item)</span></span>;	  			<span class="comment">// 返回栈顶内容但不弹出成功返回真，否则返回假,</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; 	   			<span class="comment">// 若栈已空返回真</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;        			<span class="comment">// 若栈已满返回真</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="lnkStack-h"><a href="#lnkStack-h" class="headerlink" title="lnkStack.h"></a>lnkStack.h</h3><p><a herf="myStack.h">#include “myStack.h”</a></p>
<p><a herf="Link.h">#include “Link.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Link.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkStack</span> :</span> <span class="keyword">public</span> Stack&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:                                <span class="comment">// 栈的链式存储</span></span><br><span class="line">    Link&lt;T&gt; *top;                    <span class="comment">// 指向栈顶的指针</span></span><br><span class="line">    <span class="keyword">int</span> size;                    <span class="comment">// 存放元素的个数</span></span><br><span class="line"><span class="keyword">public</span>:                                <span class="comment">// 栈运算的链式实现</span></span><br><span class="line">    lnkStack(<span class="keyword">int</span> defSize) &#123;                <span class="comment">// 构造函数</span></span><br><span class="line">        top = <span class="literal">NULL</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~lnkStack() &#123;                    <span class="comment">// 析构函数</span></span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 清空栈内容</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Link&lt;T&gt; *tmp = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;                <span class="comment">// 入栈操作的链式实现	</span></span><br><span class="line">        Link&lt;T&gt; *tmp = <span class="keyword">new</span> Link&lt;T&gt;(item, top);</span><br><span class="line">        top = tmp;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T *item)</span> </span>&#123;                <span class="comment">// 出栈的链式实现</span></span><br><span class="line">        Link&lt;T&gt; *tmp;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = top-&gt;data;</span><br><span class="line">        tmp = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = tmp;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T *item)</span> </span>&#123;                <span class="comment">// 返回栈顶内容，但不弹出</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = top-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="arrStack-h"><a href="#arrStack-h" class="headerlink" title="arrStack.h"></a>arrStack.h</h3><p><a herf="myStack.h">#include “myStack.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  array-based stack: definition and implementation for some methods</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrStack</span> :</span> <span class="keyword">public</span> Stack&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:                            <span class="comment">// 栈的顺序存储</span></span><br><span class="line">    <span class="keyword">int</span> mSize;            <span class="comment">// 栈中最多可存放的元素个数</span></span><br><span class="line">    T *st;            <span class="comment">// 存放栈元素的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> top;                    <span class="comment">// 栈顶位置，应小于mSize </span></span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 栈的运算的顺序实现</span></span><br><span class="line">    arrStack(<span class="keyword">int</span> size) &#123;                <span class="comment">// 创建一个顺序栈的实例</span></span><br><span class="line">        mSize = size;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        st = <span class="keyword">new</span> T[mSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arrStack() &#123;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~arrStack() &#123;                    <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] st;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 清空栈内容</span></span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;            <span class="comment">// 入栈操作的顺序实现	</span></span><br><span class="line">        <span class="keyword">if</span> (top == mSize - <span class="number">1</span>) &#123;            <span class="comment">// 栈已满 </span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈满溢出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 新元素入栈并修改栈顶指针</span></span><br><span class="line">            st[++top] = item;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T *item)</span> </span>&#123;                                    <span class="comment">// 出栈的顺序实现</span></span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;                                   <span class="comment">// 栈为空</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *item = st[top--];             <span class="comment">// 返回栈顶元素并修改栈顶指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T *item)</span> </span>&#123;                     <span class="comment">// 返回栈顶内容，但不弹出</span></span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;                     <span class="comment">// 栈空</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *item = st[top];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (top == <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (top == mSize - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Calculator-h"><a href="#Calculator-h" class="headerlink" title="Calculator.h"></a>Calculator.h</h3><p><a herf="arrStack.h">#include “arrStack.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Class Declaration 类的说明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    arrStack&lt;<span class="keyword">double</span>&gt; s;        <span class="comment">// 这个栈用于压入保存操作数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">GetTwoOperands</span><span class="params">(<span class="keyword">double</span> &amp;opd1, <span class="keyword">double</span> &amp;opd2)</span></span>;    <span class="comment">// 从栈顶弹出两个操作数opd1和opd2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Compute</span><span class="params">(<span class="keyword">char</span> op)</span></span>;    <span class="comment">// 调用GetTwoOperands，并按op运算对两个操作数进行计算</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//       Calculator()&#123;&#125; ;		// 创建计算器实例，开辟一个空栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;            <span class="comment">// 后缀表达式的读入，在遇到符号&quot;=&quot;时 ，启动求值计算 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;        <span class="comment">// 计算器的清除，为随后的下一次计算做准备  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算器类class Calculator中部分成员函数的程序实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Calculator::GetTwoOperands</span><span class="params">(<span class="keyword">double</span> &amp;opd1, <span class="keyword">double</span> &amp;opd2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Missing operand!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.pop(&amp;opd1);                            <span class="comment">// 右操作数</span></span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Missing operand!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.pop(&amp;opd2);                        <span class="comment">// 左操作数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculator::Compute</span><span class="params">(<span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result;</span><br><span class="line">    <span class="keyword">double</span> operand1, operand2;</span><br><span class="line">    result = GetTwoOperands(operand1, operand2);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">                s.push(operand2 + operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">                s.push(operand2 - operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">                s.push(operand2 * operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                <span class="keyword">if</span> (operand1 == <span class="number">0.0</span>) &#123;</span><br><span class="line">                    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Divide by 0!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    s.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    s.push(operand2 / operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculator::Run</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> newOperand, res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c, c != <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                Compute(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="built_in">cin</span>.putback(c);</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; newOperand;</span><br><span class="line">                s.push(newOperand);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">        s.pop(&amp;res);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;                    <span class="comment">// 印出求值的最后结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="myQueue-h"><a href="#myQueue-h" class="headerlink" title="myQueue.h"></a>myQueue.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>  &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: 			        		<span class="comment">// 队列的运算集</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;					<span class="comment">// 变为空队列</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T item)</span></span>; 		<span class="comment">// item入队，插入队尾，成功则返回真否则返回假</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T item)</span></span>;     	<span class="comment">// 返回队头元素并从队列中删除，成功则返回真</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">front</span><span class="params">(T* item)</span></span>;	       	<span class="comment">// 返回队头元素，但不删除，成功则返回真</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; 				<span class="comment">// 返回真，若队列已空</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;       			<span class="comment">// 返回真，若队列已满</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="arrQueue-h"><a href="#arrQueue-h" class="headerlink" title="arrQueue.h"></a>arrQueue.h</h3><p><a herf="myQueue.h">#include “myQueue.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array-base queue</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrQueue</span> :</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;</span>T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mSize;                        <span class="comment">// 存放队列的数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> front;                            <span class="comment">// 表示队头所在位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> rear;                            <span class="comment">// 表示队尾所在位置的下标</span></span><br><span class="line">    T *qu;     <span class="comment">// 存放类型为T的队列元素的数组</span></span><br><span class="line"><span class="keyword">public</span>:                                <span class="comment">// 队列的运算集</span></span><br><span class="line">    arrQueue(<span class="keyword">int</span> size) &#123;                    <span class="comment">// 创建队列的实例</span></span><br><span class="line">        mSize = size + <span class="number">1</span>;                    <span class="comment">// 浪费一个存储空间，以区别队列空和队列满</span></span><br><span class="line">        qu = <span class="keyword">new</span> T[mSize];</span><br><span class="line">        front = rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~arrQueue() &#123;                    <span class="comment">// 消除该实例，并释放其空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] qu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> clear&#123;                        <span class="comment">// 清空队列</span></span><br><span class="line">            front = rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(T item)</span> </span>&#123;                <span class="comment">//  item入队，插入队尾</span></span><br><span class="line">        <span class="keyword">if</span> (((rear + <span class="number">1</span>) % mSize) == front) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列已满，溢出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qu[rear] = item;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % mSize;            <span class="comment">// 循环后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T &amp;item)</span> </span>&#123;                <span class="comment">// 返回队头元素并从队列中删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = qu[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % mSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">front</span><span class="params">(T &amp;item)</span> </span>&#123;                    <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = qu[front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lnkQueue-h"><a href="#lnkQueue-h" class="headerlink" title="lnkQueue.h"></a>lnkQueue.h</h3><p><a herf="lnkQueue.h">#include “lnkQueue.h”</a></p>
<p><a herf="Link.h">#include “Link.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Link.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkQueue</span> :</span> <span class="keyword">public</span> Queue&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;                            <span class="comment">// 队列中当前元素的个数</span></span><br><span class="line">    Link&lt;T&gt; *front;                            <span class="comment">// 表示队头的指针</span></span><br><span class="line">    Link&lt;T&gt; *rear;                            <span class="comment">// 表示队尾的指针</span></span><br><span class="line"><span class="keyword">public</span>:                                    <span class="comment">// 队列的运算集</span></span><br><span class="line">    lnkQueue(<span class="keyword">int</span> size) &#123;                        <span class="comment">// 创建队列的实例</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        front = rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~lnkQueue() &#123;                        <span class="comment">// 消除该实例，并释放其空间</span></span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                            <span class="comment">// 清空队列</span></span><br><span class="line">        <span class="keyword">while</span> (front != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rear = front;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> rear;</span><br><span class="line">        &#125;</span><br><span class="line">        rear = <span class="literal">NULL</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;                <span class="comment">//  item入队，插入队尾</span></span><br><span class="line">        <span class="keyword">if</span> (rear == <span class="literal">NULL</span>) &#123;                <span class="comment">// 空队列</span></span><br><span class="line">            front = rear = <span class="keyword">new</span> Link&lt;T&gt;(item, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 添加新的元素</span></span><br><span class="line">            rear-&gt;next = <span class="keyword">new</span> Link&lt;T&gt;(item, <span class="literal">NULL</span>);</span><br><span class="line">            rear = rear-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T *item)</span> </span>&#123;                    <span class="comment">// 返回队头元素并从队列中删除</span></span><br><span class="line">        Link&lt;T&gt; *tmp;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;                        <span class="comment">// 队列为空，没有元素可出队</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = front-&gt;data;</span><br><span class="line">        tmp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">            rear = <span class="literal">NULL</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getFront</span><span class="params">(T *item)</span> </span>&#123;                        <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;                        <span class="comment">// 队列为空，没有元素可出队</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = front-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Link&lt;T&gt; *p = front;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四-字符串"><a href="#四-字符串" class="headerlink" title="四    字符串"></a>四    字符串</h2><h3 id="myString-h"><a href="#myString-h" class="headerlink" title="myString.h"></a>myString.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String(<span class="keyword">char</span> *s) &#123;</span><br><span class="line">        size = <span class="built_in">strlen</span>(s);</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>];</span><br><span class="line">        assert(str != <span class="string">&#x27;\0&#x27;</span>);       <span class="comment">// 当开辟动态区域不成功时，运行异常退出</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">Substr</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> left = size - pos;                    <span class="comment">// 自下标pos向右计数到串尾查看剩余长度</span></span><br><span class="line">        String tmp;</span><br><span class="line">        <span class="keyword">char</span> *p, *q;</span><br><span class="line">        <span class="comment">// 以下7行语句，全是为取出子串做准备工作</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= size)                        <span class="comment">// 若下标pos值超过本串实际串长，则返回空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; left)                        <span class="comment">// 若n超过自pos以右的子串长度，则把n变小</span></span><br><span class="line">            n = left;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp.str;                    <span class="comment">// 释放原来的存储空间</span></span><br><span class="line">        tmp.str = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">        assert(tmp.str != <span class="literal">NULL</span>);                <span class="comment">// 若开辟动态存储空间失败，则退出</span></span><br><span class="line">        p = tmp.str;                        <span class="comment">//  p指向暂无内容的字符串</span></span><br><span class="line">        q = &amp;str[pos];                        <span class="comment">//  q指向本实例串str数组下标pos处</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            *p++ = *q++;                    <span class="comment">// 将q所指的内容赋值给 p，并同时后移</span></span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;                        <span class="comment">// 循环结束后，让temp.str的结尾为&#x27;\0&#x27;</span></span><br><span class="line">        tmp.size = n;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> String &amp;s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> String &amp;s) &#123;</span><br><span class="line">    os &lt;&lt; s.str;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="KMPStrMatching-h"><a href="#KMPStrMatching-h" class="headerlink" title="KMPStrMatching.h"></a>KMPStrMatching.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPStrMatching</span><span class="params">(<span class="built_in">string</span> T, <span class="built_in">string</span> P,  <span class="keyword">int</span> *N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;							<span class="comment">// 模式的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;							<span class="comment">// 目标的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> pLen = P. length ( );             		<span class="comment">// 模式的长度</span></span><br><span class="line">    <span class="keyword">int</span> tLen = T.length( );					<span class="comment">// 目标的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tLen &lt; pLen) 				    		<span class="comment">// 如果目标比模式短，匹配无法成功</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);          			</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; pLen  &amp;&amp;  j &lt; tLen)  &#123;  		<span class="comment">// 反复比较对应字符来开始匹配</span></span><br><span class="line">       		<span class="keyword">if</span> ( i == <span class="number">-1</span>  ||  T[j] == P[i]) </span><br><span class="line">    			i++,  j++;</span><br><span class="line">    		<span class="keyword">else</span> i = N[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= pLen)</span><br><span class="line">    		<span class="keyword">return</span> (j - pLen + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">findNext</span><span class="params">(<span class="built_in">string</span> P)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span> m = P.length();    					<span class="comment">// m为字符串P的长度</span></span><br><span class="line">  	assert(m &gt; <span class="number">0</span>);     					<span class="comment">// 若m＝0，退出</span></span><br><span class="line">  	<span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[m];  				<span class="comment">// 动态存储区开辟整数数组</span></span><br><span class="line">    assert(next != <span class="number">0</span>);   					<span class="comment">// 若开辟存储区域失败，退出</span></span><br><span class="line">  	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) &#123; 						<span class="comment">// 计算i=1..m-1的next值</span></span><br><span class="line">		<span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; P[i] != P[k])  		<span class="comment">// 求最大首尾子串</span></span><br><span class="line">			k = next[k];		</span><br><span class="line">        i++;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">if</span> (i == m) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (P[i] == P[k] ) 				</span><br><span class="line">			next[i] = next[k];				<span class="comment">//  P[i]和P[k]相等，优化</span></span><br><span class="line">		<span class="keyword">else</span> next[i] = k;					<span class="comment">// 不需要优化，就是位置i的首尾子串长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="五-二叉树"><a href="#五-二叉树" class="headerlink" title="五    二叉树"></a>五    二叉树</h2><h3 id="BinaryTreeNode-h"><a href="#BinaryTreeNode-h" class="headerlink" title="BinaryTreeNode.h"></a>BinaryTreeNode.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  BinaryTreeNode.h  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;</span>T&gt;;	<span class="comment">//声明二叉树为结点类的友元类，便于访问私有数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T  info;				     	    	<span class="comment">//二叉树结点数据域</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* left;		   		<span class="comment">//二叉树结点指向左子树的指针</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* right;    			<span class="comment">//二叉树结点指向左子树的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTreeNode();							<span class="comment">//缺省构造函数</span></span><br><span class="line">	BinaryTreeNode(<span class="keyword">const</span> T&amp; inf);	 			<span class="comment">//给定数据的构造函数</span></span><br><span class="line">	BinaryTreeNode(<span class="keyword">const</span> T&amp; inf,BinaryTreeNode&lt;T&gt;* l, BinaryTreeNode&lt;T&gt;* r);<span class="comment">//给定了结点值和左右子树的构造函数</span></span><br><span class="line">	<span class="function">T  <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>;							<span class="comment">//返回当前结点的数据</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;*  <span class="title">leftchild</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//返回当前结点左子树</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;*  <span class="title">rightchild</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//返回当前结点右子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setLeftchild</span><span class="params">(BinaryTreeNode&lt;T&gt;*)</span> </span>;	<span class="comment">//设置当前结点的左子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setRightchild</span><span class="params">(BinaryTreeNode&lt;T&gt;*)</span> </span>;	<span class="comment">//设置当前结点的右子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>; 				<span class="comment">//设置当前结点的数据域</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span>  <span class="title">isLeaf</span><span class="params">()</span> <span class="keyword">const</span></span>;				<span class="comment">//判定当前结点是否为叶结点,若是返回true</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> BinaryTreeNode&lt;T&gt;&amp; Node)&#123;<span class="keyword">this</span> = Node;&#125;;<span class="comment">//重载赋值操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//****** BinaryTreeNode Implementation *******//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode()  &#123;</span><br><span class="line">	left = right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode(<span class="keyword">const</span> T&amp; inf)  &#123;	<span class="comment">//给定数据的构造函数</span></span><br><span class="line">	info = inf;</span><br><span class="line">	left = right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode(<span class="keyword">const</span> T&amp; inf,BinaryTreeNode* l, BinaryTreeNode* r)  &#123;<span class="comment">//给定数据的左右指针的构造函数</span></span><br><span class="line">	info = inf;</span><br><span class="line">	left = l;</span><br><span class="line">	right = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T  BinaryTreeNode&lt;T&gt;::value() <span class="keyword">const</span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> info; </span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;*  BinaryTreeNode&lt;T&gt;::leftchild() <span class="keyword">const</span>  &#123; <span class="comment">//返回当前结点指向左子树的指针</span></span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;												</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;*  BinaryTreeNode&lt;T&gt;::rightchild() <span class="keyword">const</span>  &#123; <span class="comment">//返回当前结点指向右子树的指针</span></span><br><span class="line">	<span class="keyword">return</span> right;								</span><br><span class="line">&#125;			</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setLeftchild(BinaryTreeNode&lt;T&gt;* subroot)  &#123; <span class="comment">//设置当前结点的左子树</span></span><br><span class="line">	left = subroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setRightchild(BinaryTreeNode&lt;T&gt;* subroot)  &#123; <span class="comment">//设置当前结点的右子树</span></span><br><span class="line">	right = subroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setValue(<span class="keyword">const</span> T&amp; val)  &#123;	<span class="comment">//设置当前结点的数据域</span></span><br><span class="line">	info = val; </span><br><span class="line">&#125; 									</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span>  BinaryTreeNode&lt;T&gt;::isLeaf() <span class="keyword">const</span>	 &#123;	<span class="comment">//判定当前结点是否为叶结点,若是返回true</span></span><br><span class="line">	<span class="keyword">return</span> (left == <span class="literal">NULL</span>) &amp;&amp; (right == <span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BinaryTree-h"><a href="#BinaryTree-h" class="headerlink" title="BinaryTree.h"></a>BinaryTree.h</h3><p><a herf="BinaryTreeNode.h">#include “BinaryTreeNode.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************BinaryTree.h****************//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BinaryTreeNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Tags</span>&#123;</span>Left,Right&#125;;    <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackElement</span>  &#123;</span>         <span class="comment">//StackElement</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer;</span><br><span class="line">	Tags tag;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	BinaryTreeNode&lt;T&gt;*  root;      			<span class="comment">//二叉树根结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTree()&#123;root = <span class="literal">NULL</span>;&#125;;				<span class="comment">//构造函数</span></span><br><span class="line">	~BinaryTree() &#123;DeleteBinaryTree(root);&#125;;	<span class="comment">//析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;						<span class="comment">//判定二叉树是否为空树</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">Root</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> root;&#125;;	<span class="comment">//返回二叉树根结点</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">Parent</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;<span class="comment">//返回current的父结点</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">LeftSibling</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;</span><br><span class="line">	<span class="comment">//返回current结点的左兄弟</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">RightSibling</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;</span><br><span class="line">	<span class="comment">//返回current结点的右兄弟</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(<span class="keyword">const</span> T&amp; info, BinaryTree&lt;T&gt;&amp; leftTree, BinaryTree&lt;T&gt;&amp; rightTree)</span></span>;</span><br><span class="line">	<span class="comment">//构造一棵以info为根、leftTree和rightTree为左右子树的新二叉树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;  	<span class="comment">//前序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;		<span class="comment">//中序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;	<span class="comment">//后序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归前序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归中序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归后序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>; 	<span class="comment">//按层次周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DeleteBinaryTree</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;	<span class="comment">//删除二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; Value;&#125;;           <span class="comment">//访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********  BianryTree Implementation  ***********//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;T&gt;:: isEmpty() <span class="keyword">const</span>  &#123;      <span class="comment">//判定二叉树是否为空树</span></span><br><span class="line">	<span class="keyword">return</span> ( root? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::Parent(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;						<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> != root &amp;&amp; <span class="literal">NULL</span> != current)  &#123;		</span><br><span class="line">		<span class="keyword">while</span>(!aStack.empty() || pointer)	&#123;</span><br><span class="line">			<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">				<span class="keyword">if</span>(current == pointer-&gt;leftchild() ||current == pointer-&gt;rightchild()) <span class="comment">//如果当前pointer的孩子就是current，返回parent</span></span><br><span class="line">					<span class="keyword">return</span> pointer;</span><br><span class="line">				aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">				pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  &#123;                         <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">				pointer = aStack.top();			<span class="comment">//栈顶元素退栈                 </span></span><br><span class="line">				aStack.pop();</span><br><span class="line">				pointer = pointer-&gt;rightchild();  	<span class="comment">//当前链接结构指向右孩子</span></span><br><span class="line">			&#125;<span class="comment">//endif</span></span><br><span class="line">		&#125; <span class="comment">//endwhile</span></span><br><span class="line">	&#125;<span class="comment">//endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::LeftSibling(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="comment">//返回current结点的左兄弟</span></span><br><span class="line">	<span class="keyword">if</span>(current)  &#123;</span><br><span class="line">		BinaryTreeNode&lt;T&gt;* temp = Parent(current);    <span class="comment">//返回current结点的父结点</span></span><br><span class="line">		<span class="keyword">if</span> ((temp == <span class="literal">NULL</span>) || current == temp-&gt;leftchild())</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">NULL</span>;	  <span class="comment">//如果父结点为空，或者current没有左兄弟，返回空</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> temp-&gt;leftchild();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::RightSibling(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="comment">//返回current结点的右兄弟</span></span><br><span class="line">	<span class="keyword">if</span>(current)  &#123;</span><br><span class="line">		BinaryTreeNode&lt;T&gt;* temp = Parent(current);<span class="comment">//返回current结点的父结点</span></span><br><span class="line">		<span class="keyword">if</span>(temp == <span class="literal">NULL</span>||current == temp-&gt;rightchild())</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">NULL</span>;		    <span class="comment">//如果父结点为空，或者current没有右兄弟</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> temp-&gt;rightchild();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: CreateTree (<span class="keyword">const</span> T&amp; info, BinaryTree&lt;T&gt;&amp; leftTree, BinaryTree&lt;T&gt;&amp; rightTree)  &#123;</span><br><span class="line">	<span class="comment">//由左子树leftTree、右子树rightTree和数据元素info创建一棵新树，根结点是info</span></span><br><span class="line">	<span class="comment">//其中this、leftTree、rightTree必须是不同的三棵树</span></span><br><span class="line">	root = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;(info, leftTree.root, rightTree.root);	<span class="comment">//创建新树</span></span><br><span class="line">	leftTree.root = rightTree.root = <span class="literal">NULL</span>;  <span class="comment">//原来两棵子树的根结点指空，避免访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: DeleteBinaryTree(BinaryTreeNode&lt;T&gt;* root)  &#123; <span class="comment">//以后序周游的方式删除二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root)  &#123;</span><br><span class="line">		DeleteBinaryTree(root-&gt;left);				<span class="comment">//递归删除左子树</span></span><br><span class="line">		DeleteBinaryTree(root-&gt;right);		    <span class="comment">//递归删除右子树</span></span><br><span class="line">		<span class="keyword">delete</span> root;							<span class="comment">//删除根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrder (BinaryTreeNode&lt;T&gt;* root)  &#123;  <span class="comment">//前序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">		PreOrder(root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		PreOrder(root-&gt;rightchild());			<span class="comment">//访问右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: InOrder (BinaryTreeNode&lt;T&gt;* root)  &#123;  <span class="comment">//中序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		InOrder (root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">		InOrder (root-&gt;rightchild());			<span class="comment">//访问右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: PostOrder (BinaryTreeNode&lt;T&gt;* root)  &#123; <span class="comment">//后序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		PostOrder(root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		PostOrder (root-&gt;rightchild());		<span class="comment">//访问右子树</span></span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;<span class="comment">//非递归前序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;						<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">while</span>(!aStack.empty() || pointer)	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">			Visit(pointer-&gt;value());			<span class="comment">//访问当前结点</span></span><br><span class="line">			aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  &#123;                         <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">			pointer = aStack.top();			<span class="comment">//栈顶元素退栈                 </span></span><br><span class="line">			aStack.pop();</span><br><span class="line">			pointer = pointer-&gt;rightchild();  	<span class="comment">//当前链接结构指向右孩子</span></span><br><span class="line">		&#125;<span class="comment">//endif</span></span><br><span class="line">    &#125; <span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::InOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;</span><br><span class="line">	<span class="comment">//非递归中序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;							<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">while</span>(!aStack.empty() || pointer)  &#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">			aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  &#123;                            <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">			pointer = aStack.top();</span><br><span class="line">			aStack.pop();					<span class="comment">//栈顶元素退栈    </span></span><br><span class="line">			Visit(pointer-&gt;value());		<span class="comment">//访问当前结点</span></span><br><span class="line">			pointer = pointer-&gt;rightchild(); 	<span class="comment">//当前链接结构指向右孩子             </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PostOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;</span><br><span class="line">	<span class="comment">//非递归后序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;							<span class="comment">//使用STL栈部分</span></span><br><span class="line">	StackElement&lt;T&gt; element;</span><br><span class="line">	<span class="built_in">stack</span>&lt;StackElement&lt;T &gt; &gt; aStack;			<span class="comment">//栈申明</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;							<span class="comment">//空树即返回</span></span><br><span class="line">	<span class="keyword">else</span> pointer = root;						<span class="comment">//保存输入参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!aStack.empty() || pointer) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pointer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			element.pointer = pointer;</span><br><span class="line">			element.tag = Left;</span><br><span class="line">			aStack.push(element);</span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//沿左子树方向向下周游</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		element = aStack.top();</span><br><span class="line">		aStack.pop();							<span class="comment">//托出栈顶元素</span></span><br><span class="line">		pointer = element.pointer;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (element.tag == Left)&#123;</span><br><span class="line">			<span class="comment">//从左子树回来</span></span><br><span class="line">			element.tag = Right;</span><br><span class="line">			aStack.push(element);</span><br><span class="line">			pointer = pointer-&gt;rightchild();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                                  <span class="comment">//从右子树回来</span></span><br><span class="line">			Visit(pointer-&gt;value());		    <span class="comment">//访问当前结点</span></span><br><span class="line">			pointer = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::LevelOrder(BinaryTreeNode&lt;T&gt;* root)	&#123;</span><br><span class="line">	<span class="comment">//按层次周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;							<span class="comment">//使用STL的队列</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;BinaryTreeNode&lt;T&gt;*&gt; aQueue;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;			<span class="comment">//保存输入参数</span></span><br><span class="line">	<span class="keyword">if</span> (pointer)</span><br><span class="line">		aQueue.push(pointer);                  <span class="comment">//根结点入队列</span></span><br><span class="line">	<span class="keyword">while</span> (!aQueue.empty())  &#123;                 <span class="comment">//队列非空</span></span><br><span class="line">		pointer = aQueue.front();			 	<span class="comment">//取队列首结点</span></span><br><span class="line">		aQueue.pop();                        <span class="comment">//当前结点出队列</span></span><br><span class="line">        Visit(pointer-&gt;value());					<span class="comment">//访问当前结点</span></span><br><span class="line">		<span class="keyword">if</span>(pointer-&gt;leftchild())</span><br><span class="line">			aQueue.push(pointer-&gt;leftchild());		<span class="comment">//左子树进队列</span></span><br><span class="line">		<span class="keyword">if</span>(pointer-&gt;rightchild())</span><br><span class="line">			aQueue.push(pointer-&gt;rightchild());	<span class="comment">//右子树进队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BinarySearchTree-h"><a href="#BinarySearchTree-h" class="headerlink" title="BinarySearchTree.h"></a>BinarySearchTree.h</h3><p><a herf="BinaryTree.h">#include “BinaryTree.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*******  BinarySearchTree.h  ******//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;BinaryTreeNode.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BinaryTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> :</span> <span class="keyword">public</span> BinaryTree&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinarySearchTree() &#123; <span class="keyword">this</span>-&gt;root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~BinarySearchTree() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(BinaryTreeNode&lt;T&gt; *newpointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt; *<span class="title">Root</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;root; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(BinaryTreeNode&lt;T&gt; *root, BinaryTreeNode&lt;T&gt; *newpointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(BinaryTreeNode&lt;T&gt; *pointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNodeEx</span><span class="params">(BinaryTreeNode&lt;T&gt; *pointer)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********  implemention ***********//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::Initialize(BinaryTreeNode&lt;T&gt; *newpointer) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root = newpointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::InsertNode(BinaryTreeNode&lt;T&gt; *root,</span><br><span class="line">                                     BinaryTreeNode&lt;T&gt; *newpointer) &#123;                          <span class="comment">//向二叉搜索树插入新结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;                 <span class="comment">//如果是空树，初始化</span></span><br><span class="line">        Initialize(newpointer);            <span class="comment">//用指针newpointer初始化二叉搜索树树根，赋值实现</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        pointer = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newpointer-&gt;value() == pointer-&gt;value())</span><br><span class="line">            <span class="keyword">return</span>;                      <span class="comment">//相等则不用插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newpointer-&gt;value() &lt; pointer-&gt;value()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pointer-&gt;leftchild() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pointer-&gt;left = newpointer;        <span class="comment">//作为左子树</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> pointer = pointer-&gt;leftchild();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pointer-&gt;rightchild() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pointer-&gt;right = newpointer;      <span class="comment">//作为右子树</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> pointer = pointer-&gt;rightchild();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void BinarySearchTree&lt;T&gt;::DeleteNode(BinaryTreeNode&lt;T&gt;* pointer)  &#123;      //教材中写出这个算法</span></span><br><span class="line"><span class="comment">	//二叉搜索树中结点的删除</span></span><br><span class="line"><span class="comment">	BinaryTreeNode&lt;T&gt;* temppointer = NULL;</span></span><br><span class="line"><span class="comment">	if(!pointer)                            //如果删除的是空结点，则返回</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	BinaryTreeNode&lt;T&gt;* parent = Parent(pointer);</span></span><br><span class="line"><span class="comment">	if (pointer-&gt;leftchild() == NULL)  &#123;</span></span><br><span class="line"><span class="comment">		//被删结点无左子树，则将其右子树的根代替该删除结点</span></span><br><span class="line"><span class="comment">		if (parent == NULL)                 //被删除结点是根结点</span></span><br><span class="line"><span class="comment">			root = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		else if (parent-&gt;leftchild() == pointer)</span></span><br><span class="line"><span class="comment">			parent-&gt;left = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">			parent-&gt;right = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		delete pointer;                     //删除该结点</span></span><br><span class="line"><span class="comment">		pointer = NULL;</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	else                                 //左子树不为空时</span></span><br><span class="line"><span class="comment">		temppointer = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	while (temppointer-&gt;rightchild() != NULL)  //在左子树中找对称序的最后一个结点</span></span><br><span class="line"><span class="comment">		temppointer = temppointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">	//被删除结点的右子树作为temppointer的右子树</span></span><br><span class="line"><span class="comment">	temppointer-&gt;right = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">	//被删除结点的左子树根代替被删除结点</span></span><br><span class="line"><span class="comment">	if(NULL == parent)</span></span><br><span class="line"><span class="comment">		root = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	else if (parent-&gt;leftchild() == pointer)</span></span><br><span class="line"><span class="comment">		parent-&gt;left = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	else </span></span><br><span class="line"><span class="comment">		parent-&gt;right = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	delete pointer;                          //删除该结点</span></span><br><span class="line"><span class="comment">	pointer = NULL;</span></span><br><span class="line"><span class="comment">	return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::DeleteNodeEx(BinaryTreeNode&lt;T&gt; *pointer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pointer == <span class="literal">NULL</span>)                    <span class="comment">// 若待删除结点不存在，返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *temppointer;         <span class="comment">// 用于保存替换结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *tempparent = <span class="literal">NULL</span>;  <span class="comment">// 用于保存替换结点的父结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *parent = Parent(pointer); <span class="comment">// 保存删除结点的父结点</span></span><br><span class="line">    <span class="comment">// 如果待删除结点的左子树为空，就将它的右子树代替它</span></span><br><span class="line">    <span class="keyword">if</span> (pointer-&gt;leftchild() == <span class="literal">NULL</span>)</span><br><span class="line">        temppointer = pointer-&gt;rightchild();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当待删除结点左子树不为空，就在左子树中寻找最大结点替换待删除结点</span></span><br><span class="line">        temppointer = pointer-&gt;leftchild();</span><br><span class="line">        <span class="keyword">while</span> (temppointer-&gt;rightchild() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tempparent = temppointer;</span><br><span class="line">            temppointer = temppointer-&gt;rightchild();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除替换结点</span></span><br><span class="line">        <span class="keyword">if</span> (tempparent == <span class="literal">NULL</span>)</span><br><span class="line">            pointer-&gt;left = temppointer-&gt;leftchild();</span><br><span class="line">        <span class="keyword">else</span> tempparent-&gt;right = temppointer-&gt;leftchild();</span><br><span class="line">        temppointer-&gt;left = pointer-&gt;leftchild();    <span class="comment">// 继承pointer的左子树</span></span><br><span class="line">        temppointer-&gt;right = pointer-&gt;rightchild();  <span class="comment">// 继承pointer的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用替换结点去替代真正的删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = temppointer;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;leftchild() == pointer)</span><br><span class="line">        parent-&gt;left = temppointer;</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;right = temppointer;</span><br><span class="line">    <span class="keyword">delete</span> pointer;                            <span class="comment">// 删除该结点</span></span><br><span class="line">    pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="MinHeap-h"><a href="#MinHeap-h" class="headerlink" title="MinHeap.h"></a>MinHeap.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************  算法5.12 堆的类定义和筛选法  **********************/</span></span><br><span class="line"><span class="comment">/****************           MinHeap.h           **********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> &#123;</span>                            <span class="comment">//最小堆类定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heapArray;                            <span class="comment">//存放堆数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> CurrentSize;                        <span class="comment">//当前堆中元素数目</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                            <span class="comment">//堆所能容纳的最大元素数目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> pos_x, <span class="keyword">int</span> pos_y)</span></span>;        <span class="comment">//交换位置x和y的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">()</span></span>;                        <span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinHeap(<span class="keyword">const</span> <span class="keyword">int</span> n);                 <span class="comment">//构造函数,n表示初始化堆的最大元素数目</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MinHeap() &#123; <span class="keyword">delete</span>[]heapArray; &#125;;    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                            <span class="comment">// 如果堆空，则返回真</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//如果是叶结点，返回TRUE</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回左孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rightchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回右孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//返回父结点位置</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> pos, T &amp;node)</span></span>;            <span class="comment">//删除给定下标的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T &amp;newNode)</span></span>;            <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="function">T &amp;<span class="title">RemoveMin</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶删除最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftUp</span><span class="params">(<span class="keyword">int</span> position)</span></span>;             <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftDown</span><span class="params">(<span class="keyword">int</span> left)</span></span>;             <span class="comment">//筛选法函数，参数left表示开始处理的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">MinHeap&lt;T&gt;::MinHeap(<span class="keyword">const</span> <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    CurrentSize = <span class="number">0</span>;</span><br><span class="line">    MaxSize = n;                        <span class="comment">//初始化堆容量为n</span></span><br><span class="line">    heapArray = <span class="keyword">new</span> T[MaxSize];            <span class="comment">//创建堆空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处进行堆元素的赋值工作</span></span><br><span class="line">    heapArray[<span class="number">0</span>] = <span class="number">19</span>;                 <span class="comment">//亦可以用插入的办法构造</span></span><br><span class="line">    heapArray[<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line">    heapArray[<span class="number">2</span>] = <span class="number">35</span>;</span><br><span class="line">    heapArray[<span class="number">3</span>] = <span class="number">65</span>;</span><br><span class="line">    heapArray[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    heapArray[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">    heapArray[<span class="number">6</span>] = <span class="number">7</span>;</span><br><span class="line">    heapArray[<span class="number">7</span>] = <span class="number">45</span>;</span><br><span class="line">    CurrentSize = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    BuildHeap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::isEmpty() &#123;            <span class="comment">// 如果堆空，则返回真&#123;</span></span><br><span class="line">    <span class="keyword">return</span> ((CurrentSize) ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::isLeaf(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &gt;= CurrentSize / <span class="number">2</span>) &amp;&amp; (pos &lt; CurrentSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::BuildHeap() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = CurrentSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)    <span class="comment">//反复调用筛选函数</span></span><br><span class="line">        SiftDown(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::leftchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">1</span>;                        <span class="comment">//返回左孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::rightchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">2</span>;                          <span class="comment">//返回右孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::parent(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos - <span class="number">1</span>) / <span class="number">2</span>;                           <span class="comment">//返回父结点位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::Insert(<span class="keyword">const</span> T &amp;newNode) &#123;  <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == MaxSize)                   <span class="comment">//堆空间已经满</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    heapArray[CurrentSize] = newNode;</span><br><span class="line">    SiftUp(CurrentSize);                       <span class="comment">//向上调整</span></span><br><span class="line">    CurrentSize++;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::SiftUp(<span class="keyword">int</span> position) &#123;    <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="keyword">int</span> temppos = position;</span><br><span class="line">    T temp = heapArray[temppos];</span><br><span class="line">    <span class="keyword">while</span> ((temppos &gt; <span class="number">0</span>) &amp;&amp; (heapArray[parent(temppos)] &gt; temp)) &#123;</span><br><span class="line">        heapArray[temppos] = heapArray[parent(temppos)];</span><br><span class="line">        temppos = parent(temppos);</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[temppos] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::swap(<span class="keyword">int</span> pos_x, <span class="keyword">int</span> pos_y)     <span class="comment">//交换位置x和y的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    T temp = heapArray[pos_x];</span><br><span class="line">    heapArray[pos_x] = heapArray[pos_y];</span><br><span class="line">    heapArray[pos_y] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T &amp;MinHeap&lt;T&gt;::RemoveMin() &#123;                <span class="comment">//从堆顶删除最小值</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Can&#x27;t Delete&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        swap(<span class="number">0</span>, --CurrentSize);                    <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (CurrentSize &gt; <span class="number">1</span>)</span><br><span class="line">            SiftDown(<span class="number">0</span>);                        <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        <span class="keyword">return</span> heapArray[CurrentSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::Remove(<span class="keyword">int</span> pos, T &amp;node) &#123;    <span class="comment">// 删除给定下标的元素</span></span><br><span class="line">    <span class="keyword">if</span> ((pos &lt; <span class="number">0</span>) || (pos &gt;= CurrentSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    node = heapArray[pos];</span><br><span class="line">    heapArray[pos] = heapArray[--CurrentSize];        <span class="comment">// 用最后的元素值替代删除位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (heapArray[parent(pos)] &gt; heapArray[pos])</span><br><span class="line">        SiftUp(pos);                        <span class="comment">// 当前元素小于父结点，需要上升调整</span></span><br><span class="line">    <span class="keyword">else</span> SiftDown(pos);                        <span class="comment">// 当前元素大于父结点，向下筛</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::SiftDown(<span class="keyword">int</span> left) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = left;                                <span class="comment">// 标识父结点</span></span><br><span class="line">    <span class="keyword">int</span> j = leftchild(i);                            <span class="comment">// 标识关键值较小的子结点</span></span><br><span class="line">    T temp = heapArray[i];                    <span class="comment">// 保存父结点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; CurrentSize) &#123;                    <span class="comment">// 过筛</span></span><br><span class="line">        <span class="keyword">if</span> ((j &lt; CurrentSize - <span class="number">1</span>) &amp;&amp; (heapArray[j] &gt; heapArray[j + <span class="number">1</span>]))</span><br><span class="line">            j++;                                <span class="comment">// j指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; heapArray[j]) &#123;</span><br><span class="line">            heapArray[i] = heapArray[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = leftchild(j);                        <span class="comment">// 向下继续</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="HuffmanTree-h"><a href="#HuffmanTree-h" class="headerlink" title="HuffmanTree.h"></a>HuffmanTree.h</h3><p><a herf="MinHeap.h">#include “MinHeap.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -------- HuffmanTree.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T info;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *parent;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *left;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HuffmanTreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">leftchild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> left; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">rightchild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> right; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info &gt; HN.info; &#125;; <span class="comment">// 注意要重载运算符</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info &lt; HN.info; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info == HN.info; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *root;                    <span class="comment">//Huffman树的树根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把ht1和ht2为根的Huffman子树合并成一棵以parent为根的二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MergeTree</span><span class="params">(HuffmanTreeNode&lt;T&gt; &amp;ht1, HuffmanTreeNode&lt;T&gt; &amp;ht2, HuffmanTreeNode&lt;T&gt; *parent)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(HuffmanTreeNode&lt;T&gt; *root)</span></span>;<span class="comment">//删除Huffman树或其子树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造Huffman树，weight是存储权值的数组，n是数组长度</span></span><br><span class="line">    HuffmanTree(T weight[], <span class="keyword">int</span> n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~HuffmanTree() &#123; DeleteTree(root); &#125;;    <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(HuffmanTreeNode&lt;T&gt; *root)</span></span>;          <span class="comment">//中序周游 </span></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">GetRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">HuffmanTree&lt;T&gt;::HuffmanTree(T weight[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">    MinHeap&lt;HuffmanTreeNode&lt;T&gt; &gt; heap(n);        <span class="comment">//定义最小值堆</span></span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *parent, firstchild, secondchild;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *NodeList = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;                    <span class="comment">//初始化</span></span><br><span class="line">        NodeList[i].info = weight[i];</span><br><span class="line">        NodeList[i].parent = NodeList[i].left = NodeList[i].right = <span class="literal">NULL</span>;</span><br><span class="line">        heap.Insert(NodeList[i]);                <span class="comment">//向堆中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;                    <span class="comment">//通过n-1次合并建立Huffman树</span></span><br><span class="line">        parent = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;;</span><br><span class="line">        firstchild = heap.RemoveMin();                <span class="comment">//选择权值最小的结点</span></span><br><span class="line">        secondchild = heap.RemoveMin();                <span class="comment">//选择权值次小的结点</span></span><br><span class="line">        MergeTree(firstchild, secondchild, parent);    <span class="comment">//合并权值最小的两棵树</span></span><br><span class="line">        heap.Insert(*parent);                    <span class="comment">//把parent插入到堆中去</span></span><br><span class="line">        root = parent;                            <span class="comment">//建立根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[]NodeList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::DeleteTree(HuffmanTreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        DeleteTree(root-&gt;left);</span><br><span class="line">        DeleteTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::InOrder(HuffmanTreeNode&lt;T&gt; *root) &#123; <span class="comment">//中序周游</span></span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        InOrder(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        InOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::MergeTree(HuffmanTreeNode&lt;T&gt; &amp;ht1, HuffmanTreeNode&lt;T&gt; &amp;ht2, HuffmanTreeNode&lt;T&gt; *parent) &#123;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *l = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;();</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *r = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    *l = ht1; <span class="comment">// 不能写为l = &amp;ht1，注意地址引用，开辟的是新空间，或者应用拷贝构造函数，只是有些麻烦</span></span><br><span class="line">    *r = ht2;</span><br><span class="line"></span><br><span class="line">    parent-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    parent-&gt;left = l;</span><br><span class="line">    parent-&gt;right = r;</span><br><span class="line">    parent-&gt;info = ht1.info + ht2.info;</span><br><span class="line">    ht1.parent = ht2.parent = parent; <span class="comment">// 指向父节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="六-树"><a href="#六-树" class="headerlink" title="六    树"></a>六    树</h2><h3 id="TreeNode-h"><a href="#TreeNode-h" class="headerlink" title="TreeNode.h"></a>TreeNode.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>        <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value);             <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~TreeNode() &#123;&#125;;                 <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span>;                         <span class="comment">//如果结点是叶，返回true</span></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span></span>;                             <span class="comment">//返回结点的值 </span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span></span>;         <span class="comment">//返回第一个左孩子</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span></span>;         <span class="comment">//返回右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;)</span></span>;                     <span class="comment">//设置结点的值 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span></span>;     <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span></span>;   <span class="comment">//设置右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertFirst</span><span class="params">(TreeNode&lt;T&gt; *node)</span></span>;     <span class="comment">//以第一个左孩子身份插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertNext</span><span class="params">(TreeNode&lt;T&gt; *node)</span></span>;     <span class="comment">//以右兄弟的身份插入结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt;::TreeNode(<span class="keyword">const</span> T &amp;value) &#123;    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    m_Value = value;</span><br><span class="line">    pChild = <span class="literal">NULL</span>;</span><br><span class="line">    pSibling = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> TreeNode&lt;T&gt;::isLeaf() &#123;</span><br><span class="line">    <span class="comment">//如果结点是叶，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (pChild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T TreeNode&lt;T&gt;::Value() &#123;                    <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="keyword">return</span> m_Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt; *TreeNode&lt;T&gt;::LeftMostChild() &#123; <span class="comment">//返回第一个左孩子</span></span><br><span class="line">    <span class="keyword">return</span> pChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt; *TreeNode&lt;T&gt;::RightSibling() &#123;    <span class="comment">//返回右兄弟</span></span><br><span class="line">    <span class="keyword">return</span> pSibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setValue(T &amp;value) &#123;</span><br><span class="line">    <span class="comment">//设置结点的值</span></span><br><span class="line">    m_Value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setChild(TreeNode&lt;T&gt; *pointer) &#123;  <span class="comment">//设置左孩子</span></span><br><span class="line">    pChild = pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setSibling(TreeNode&lt;T&gt; *pointer) &#123;  <span class="comment">//设置右兄弟</span></span><br><span class="line">    pSibling = pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::InsertFirst(TreeNode&lt;T&gt; *node) &#123;</span><br><span class="line">    <span class="comment">//以第一个孩子的身份插入结点</span></span><br><span class="line">    <span class="keyword">if</span> (pChild)</span><br><span class="line">        node-&gt;pSibling = pChild;</span><br><span class="line">    pChild = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::InsertNext(TreeNode&lt;T&gt; *node) &#123; <span class="comment">//以右兄弟的身份插入结点</span></span><br><span class="line">    <span class="keyword">if</span> (pSibling)</span><br><span class="line">        node-&gt;pSibling = pSibling;</span><br><span class="line">    pSibling = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tree-h"><a href="#Tree-h" class="headerlink" title="Tree.h"></a>Tree.h</h3><p><a herf="TreeNode.h">#include “TreeNode.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;queue&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TreeNode.h</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">using namespace std;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">class Tree &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">private:</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *root;                         //树根结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void DestroyNodes(TreeNode &lt;T&gt; *root);       //删除以root为根的子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">public:</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    Tree();                                        //构造函数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    virtual ~Tree();                            //析构函数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *getRoot();                        //返回树中的根结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void CreateRoot(const T &amp;rootValue);     //创建树中的根结点，使根结点元素的值为rootValue</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    bool isEmpty();                             //判断是否为空树，如果是则返回true</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *Parent(TreeNode &lt;T&gt; *current);        //返回current结点的父结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *PrevSibling(TreeNode &lt;T&gt; *current); //返回current结点的前一个邻居结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void DeleteSubTree(TreeNode &lt;T&gt; *subroot);        //删除以subroot为根的子树的所有结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void RootFirstTraverse(TreeNode &lt;T&gt; *root);        //先根深度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void RootLastTraverse(TreeNode &lt;T&gt; *root);        //后根深度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void WidthTraverse(TreeNode &lt;T&gt; *root);            //广度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void Visit(T Value) &#123;                            //访问</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        cout &lt;&lt; Value;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">Tree&lt;T&gt;::Tree() &#123;                            //构造函数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    root = NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">Tree&lt;T&gt;::~Tree() &#123;                            //析构函数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (root)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        DeleteSubTree(root);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">TreeNode &lt;T&gt; *Tree&lt;T&gt;::getRoot() &#123;            //返回树中的根结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return root;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::CreateRoot(const T &amp;rootValue) &#123;//创建树中的根结点，使根结点元素的值为rootValue</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (!root)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        root = new TreeNode&lt;T&gt;(rootValue);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">bool Tree&lt;T&gt;::isEmpty() &#123;         //判断是否为空树，如果是则返回true</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (root)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        return false;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return true;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">TreeNode &lt;T&gt; *Tree&lt;T&gt;::PrevSibling(TreeNode &lt;T&gt; *current) &#123;//返回current结点的前一个邻居结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    using std::queue;                                //使用STL队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    queue&lt;TreeNode &lt; T&gt; * &gt; aQueue;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *pointer = root;                        //标识当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *prev = NULL;                        //标识当前结点的前一个兄弟结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    //当前结点为空，树为空或所求结点为根结点时，返回NULL	</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if ((current == NULL) || (pointer == NULL) || (current == root))</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        return NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (pointer) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        if (pointer == current)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            return prev;                            //找到当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        prev = pointer;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;pSibling;                    //沿当前结点右兄弟结点链寻找</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (!aQueue.empty()) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        prev = NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = aQueue.front();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        aQueue.pop();                                //出队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;LeftMostChild();            //下降到左子结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (pointer) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            if (pointer == current)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                return prev;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            prev = pointer;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;pSibling;                //沿当前结点右兄弟结点链寻找</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">TreeNode &lt;T&gt; *Tree&lt;T&gt;::Parent(TreeNode &lt;T&gt; *current) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    using std::queue;                                // 使用STL队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    queue&lt;TreeNode &lt; T&gt; * &gt; aQueue;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *pointer = root;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *upperlevelpointer = NULL;            // 用于记录parent结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (current != NULL &amp;&amp; pointer != current) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (pointer) &#123;                            // 森林中所有根结点进队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            if (current == pointer)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                return NULL;                    // 根的父结点指针为空，返回</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (!aQueue.empty()) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = aQueue.front();                    // 取队列首结点指针</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            aQueue.pop();                            // 出队列	</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            upperlevelpointer = pointer;                    // 指向上一层的结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;LeftMostChild();        // 指向当前结点的最左孩子</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            while (pointer) &#123;                        // 当前结点的子结点进队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                if (current == pointer)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                    return upperlevelpointer;        // 返回父结点指针</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                else &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                    aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                    pointer = pointer-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;//end if</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::DestroyNodes(TreeNode &lt;T&gt; *root) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    //删除以root为根的子树的所有结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (root) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        DestroyNodes(root-&gt;LeftMostChild());    //递归删除第一子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        DestroyNodes(root-&gt;RightSibling());        //递归删除其他子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        delete root;                            //删除根结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::DeleteSubTree(TreeNode &lt;T&gt; *subroot) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    // 删除以subroot为根的子树的所有结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (subroot == NULL) return;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *pointer = Parent(subroot);    // 找subroot的父结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (pointer == NULL)                            // subroot就是森林第一个树根</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        root = subroot-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    else if (pointer-&gt;LeftMostChild() == subroot)        // subroot为最左子结点的情况</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer-&gt;setChild(subroot-&gt;RightSibling());</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    else &#123;                                    // subroot有左兄弟</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;LeftMostChild();        // 下降到最左兄弟</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (pointer-&gt;RightSibling() != subroot)    // 顺右链找到直接左兄弟</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer-&gt;setSibling(subroot-&gt;RightSibling());</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    subroot-&gt;setSibling(NULL);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    DestroyNodes(subroot);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">//树的深度、广度周游算法</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::RootFirstTraverse(TreeNode &lt;T&gt; *root) &#123;    //先根深度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (NULL != root) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        Visit(root-&gt;Value());                      //访问当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        RootFirstTraverse(root-&gt;LeftMostChild());   //周游头一棵树树根的子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        root = root-&gt;RightSibling();                  //周游其他的树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::RootLastTraverse(TreeNode &lt;T&gt; *root) &#123;    //后根深度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (NULL != root) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        RootLastTraverse(root-&gt;LeftMostChild());  //周游头一棵树树根的子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        Visit(root-&gt;Value());                    //访问当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        root = root-&gt;RightSibling();                //周游其他的树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::WidthTraverse(TreeNode &lt;T&gt; *root) &#123;  // 广度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    using std::queue;                             // 使用STL队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    queue&lt;TreeNode &lt; T&gt; * &gt; aQueue;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *pointer = root;                // 根作为当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (pointer) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        aQueue.push(pointer);                  // 当前结点进入队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;RightSibling();         // 指向当前结点的右兄弟</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (!aQueue.empty()) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = aQueue.front();                // 取队列首结点指针</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        aQueue.pop();                         // 出队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        Visit(pointer-&gt;Value());                 // 访问当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;LeftMostChild();       // 指向当前结点的最左孩子</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (pointer) &#123;                       // 当前结点的子结点进队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br></pre></td></tr></table></figure>
<h3 id="ParTreeNode-h"><a href="#ParTreeNode-h" class="headerlink" title="ParTreeNode.h"></a>ParTreeNode.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类ParTreeNode描述了树的结点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParTreeNode</span> &#123;</span>                        <span class="comment">//树结点定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;                    <span class="comment">//结点的值</span></span><br><span class="line">    ParTreeNode&lt;T&gt; *parent;                    <span class="comment">//父结点指针</span></span><br><span class="line">    <span class="keyword">int</span> nCount;                            <span class="comment">//以此结点为根的子树的总结点个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ParTreeNode();                            <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ParTreeNode() &#123;&#125;;                <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span></span>;                            <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span></span>;            <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function">ParTreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">()</span></span>;            <span class="comment">//返回父结点指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(ParTreeNode&lt;T&gt; *par)</span></span>;    <span class="comment">//设置父结点指针</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;                        <span class="comment">//返回结点数目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> count)</span></span>;        <span class="comment">//设置结点数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ParTreeNode抽象数据类型成员函数的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode&lt;T&gt;::ParTreeNode() &#123;            <span class="comment">//构造函数</span></span><br><span class="line">    parent = <span class="literal">NULL</span>;</span><br><span class="line">    nCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T ParTreeNode&lt;T&gt;::getValue() &#123;                <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setValue(<span class="keyword">const</span> T &amp;val) &#123;            <span class="comment">//设置结点的值</span></span><br><span class="line">    value = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode&lt;T&gt; *ParTreeNode&lt;T&gt;::getParent() &#123;            <span class="comment">//返回父结点指针</span></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setParent(ParTreeNode&lt;T&gt; *par) &#123;   <span class="comment">//设置父结点指针</span></span><br><span class="line">    parent = par;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> ParTreeNode&lt;T&gt;::getCount() &#123;                        <span class="comment">//返回结点数目</span></span><br><span class="line">    <span class="keyword">return</span> nCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setCount(<span class="keyword">const</span> <span class="keyword">int</span> count) &#123;        <span class="comment">//设置结点数目</span></span><br><span class="line">    nCount = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ParTree-h"><a href="#ParTree-h" class="headerlink" title="ParTree.h"></a>ParTree.h</h3><p><a herf="ParTreeNode.h">#include “ParTreeNode.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类ParTree描述了树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParTree</span> &#123;</span>                                <span class="comment">//树定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ParTreeNode &lt;T&gt; *<span class="built_in">array</span>;                        <span class="comment">//存储树结点的数组</span></span><br><span class="line">    <span class="keyword">int</span> Size;                                    <span class="comment">//数组大小</span></span><br><span class="line">    ParTree(<span class="keyword">const</span> <span class="keyword">int</span> size);                    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ParTree();                            <span class="comment">//析构函数</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *Find(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span>;<span class="comment">//查找node结点的根结点</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *FindPC(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span>; <span class="comment">// 带压缩</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                    <span class="comment">//把下标为i，j的结点合并成一棵子树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnionPC</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                 <span class="comment">//带压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Different</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                <span class="comment">//判定下标为i，j的结点是否在一棵树中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的成员函数的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTree&lt;T&gt;::ParTree(<span class="keyword">const</span> <span class="keyword">int</span> size) &#123;            <span class="comment">//构造函数</span></span><br><span class="line">    Size = size;</span><br><span class="line">    <span class="built_in">array</span> = <span class="keyword">new</span> ParTreeNode&lt;T&gt;[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTree&lt;T&gt;::~ParTree() &#123;                        <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：找到目标结点的根结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode &lt;T&gt; *ParTree&lt;T&gt;::Find(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span> &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointer = node;</span><br><span class="line">    <span class="keyword">while</span> (pointer-&gt;getParent() != <span class="literal">NULL</span>)</span><br><span class="line">        pointer = pointer-&gt;getParent();</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：带路径压缩的Find算法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode &lt;T&gt; *ParTree&lt;T&gt;::FindPC(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;getParent() == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    node-&gt;setParent(FindPC(node-&gt;getParent()));</span><br><span class="line">    <span class="keyword">return</span> node-&gt;getParent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：判定下标为i，j的结点是否在一棵树中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> ParTree&lt;T&gt;::Different(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = Find(&amp;<span class="built_in">array</span>[i]);        <span class="comment">//找到结点i的根</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = Find(&amp;<span class="built_in">array</span>[j]);        <span class="comment">//找到结点j的根</span></span><br><span class="line">    <span class="keyword">return</span> pointeri != pointerj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把下标为i，j的结点合并成一棵子树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTree&lt;T&gt;::Union(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = Find(&amp;<span class="built_in">array</span>[i]);        <span class="comment">//找到结点i的根</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = Find(&amp;<span class="built_in">array</span>[j]);        <span class="comment">//找到结点j的根</span></span><br><span class="line">    <span class="keyword">if</span> (pointeri != pointerj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointeri-&gt;getCount() &gt;= pointerj-&gt;getCount()) &#123;</span><br><span class="line">            pointerj-&gt;setParent(pointeri);</span><br><span class="line">            pointeri-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pointeri-&gt;setParent(pointerj);</span><br><span class="line">            pointerj-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：归并两个集合， 带压缩</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTree&lt;T&gt;::UnionPC(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = FindPC(&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = FindPC(&amp;<span class="built_in">array</span>[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointeri != pointerj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointeri-&gt;getCount() &gt;= pointerj-&gt;getCount()) &#123;</span><br><span class="line">            pointerj-&gt;setParent(pointeri);</span><br><span class="line">            pointeri-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pointeri-&gt;setParent(pointerj);</span><br><span class="line">            pointerj-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DualTagTree-cpp"><a href="#DualTagTree-cpp" class="headerlink" title="DualTagTree.cpp"></a>DualTagTree.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;TreeNode.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10                             <span class="comment">//结点数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>           <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带“双标记”的先根次序 结点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualTagTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T info;                   <span class="comment">//树结点信息</span></span><br><span class="line">    <span class="keyword">int</span> ltag;                   <span class="comment">//左标记</span></span><br><span class="line">    <span class="keyword">int</span> rtag;                 <span class="comment">//右标记</span></span><br><span class="line"></span><br><span class="line">    DualTagTreeNode() &#123;&#125;;               <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~DualTagTreeNode() &#123;&#125;;      <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结点类的ADT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line">        m_Value = value;</span><br><span class="line">        pChild = <span class="literal">NULL</span>;</span><br><span class="line">        pSibling = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Value; &#125;;                     <span class="comment">// 获得结点的信息</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pChild; &#125;;   <span class="comment">// 返回第一个左子树</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pSibling; &#125;;  <span class="comment">// 返回第一个右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;value)</span> </span>&#123; m_Value = value; &#125;;      <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pChild = pointer; &#125;;   <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pSibling = pointer; &#125;;  <span class="comment">//设置右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树类ADT，只写出了相关的变量及函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode&lt;T&gt; *root;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">(TreeNode&lt;T&gt; *root, TreeNode&lt;T&gt; *current)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree() &#123; root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    Tree(DualTagTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count); <span class="comment">//带双标记先根次序构造算法</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;          <span class="comment">//返回树中的根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; Value; &#125;;           <span class="comment">//访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RootFirstTraverse</span><span class="params">(TreeNode&lt;T&gt; *root)</span></span>;      <span class="comment">//先根次序周游，作为测试使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：带双标记先根次序构造算法 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Tree&lt;T&gt;::Tree(DualTagTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count) &#123;</span><br><span class="line"><span class="comment">//利用带双标记位的先根次序表示的树构造左孩子右兄弟方式表示的树</span></span><br><span class="line">    <span class="comment">//使用STL中的stack</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> &lt; TreeNode&lt;T&gt; * &gt; aStack;</span><br><span class="line">    <span class="comment">//准备建立根结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">    root = pointer;</span><br><span class="line">    <span class="comment">//处理一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pointer-&gt;setValue(nodeArray[i].info);</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].rtag == <span class="number">0</span>)</span><br><span class="line">            aStack.push(pointer);                        <span class="comment">//将结点压栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pointer-&gt;setSibling(<span class="literal">NULL</span>);                    <span class="comment">//右兄弟设为空</span></span><br><span class="line">        TreeNode&lt;T&gt; *temppointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].ltag == <span class="number">0</span>)</span><br><span class="line">            pointer-&gt;setChild(temppointer);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pointer-&gt;setChild(<span class="literal">NULL</span>);                    <span class="comment">//左孩子设为空</span></span><br><span class="line">            pointer = aStack.top();</span><br><span class="line">            aStack.pop();</span><br><span class="line">            pointer-&gt;setSibling(temppointer);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer = temppointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理最后一个结点</span></span><br><span class="line">    pointer-&gt;setValue(nodeArray[count - <span class="number">1</span>].info);</span><br><span class="line">    pointer-&gt;setChild(<span class="literal">NULL</span>);</span><br><span class="line">    pointer-&gt;setSibling(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：先根深度遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::RootFirstTraverse(TreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Visit(root-&gt;Value());</span><br><span class="line">        RootFirstTraverse(root-&gt;LeftMostChild());</span><br><span class="line">        root = root-&gt;RightSibling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构.图6.5(a)所示的森林</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;      A              G      \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   /  |  \\         /   \\   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  B   C    D      H     I   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;     / \\          |         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    E   F         J         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  0 , there is    a right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  1 , there isn&#x27;t a right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  0 , there is    a left child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  1 , there isn&#x27;t a left child&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构的带双标记先根次序表示 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayNode</span><span class="params">(<span class="keyword">char</span> *Info, <span class="keyword">int</span> *nRtag, <span class="keyword">int</span> *nLtag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;info   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Info[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nRtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nRtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nLtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：周游树，在这里只列举一种（先根次序）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Tree&lt;<span class="keyword">char</span>&gt; *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;FirstRoot traverse:  &quot;</span>;</span><br><span class="line">    tree-&gt;RootFirstTraverse(tree-&gt;getRoot()); <span class="comment">// 先根深度优先周游</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示森林结构</span></span><br><span class="line">    DisplayTree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带双标记先根次序构造算法，图6.5(a)所示的森林的带双标记位的先根次序表示为例</span></span><br><span class="line">    <span class="keyword">char</span> strInfo[N] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;I&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nRtag[N] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nLtag[N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dualtag_FirstRoot create tree.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//打印带双标记位的先根次序表示</span></span><br><span class="line">    DisplayNode(strInfo, nRtag, nLtag);</span><br><span class="line"></span><br><span class="line">    DualTagTreeNode&lt;<span class="keyword">char</span>&gt; *nodeArray = <span class="keyword">new</span> DualTagTreeNode&lt;<span class="keyword">char</span>&gt;[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;                <span class="comment">//设置带双标记位的先根次序结点类</span></span><br><span class="line">        nodeArray[i].info = strInfo[i];</span><br><span class="line">        nodeArray[i].rtag = nRtag[i];</span><br><span class="line">        nodeArray[i].ltag = nLtag[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Tree&lt;<span class="keyword">char</span>&gt; <span class="title">aTree</span><span class="params">(nodeArray, N)</span></span>; <span class="comment">// 建树</span></span><br><span class="line">    Traverse(&amp;aTree);               <span class="comment">// 周游树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DualTagWidthTree-cpp"><a href="#DualTagWidthTree-cpp" class="headerlink" title="DualTagWidthTree.cpp"></a>DualTagWidthTree.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10                             <span class="comment">// 结点数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>           <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带“双标记”的次序结点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualTagWidthTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T info;                   <span class="comment">//树结点信息</span></span><br><span class="line">    <span class="keyword">int</span> ltag;                  <span class="comment">//左标记</span></span><br><span class="line">    <span class="keyword">int</span> rtag;                 <span class="comment">//右标记</span></span><br><span class="line"></span><br><span class="line">    DualTagWidthTreeNode() &#123;&#125;;               <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~DualTagWidthTreeNode() &#123;&#125;;      <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结点类的ADT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line">        m_Value = value;</span><br><span class="line">        pChild = <span class="literal">NULL</span>;</span><br><span class="line">        pSibling = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Value; &#125;;                     <span class="comment">// 获得结点的信息</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pChild; &#125;;   <span class="comment">// 返回第一个左子树</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pSibling; &#125;;  <span class="comment">// 返回第一个右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;value)</span> </span>&#123; m_Value = value; &#125;;      <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pChild = pointer; &#125;;   <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pSibling = pointer; &#125;;  <span class="comment">//设置右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树类ADT，只写出了相关的变量及函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode&lt;T&gt; *root;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">(TreeNode&lt;T&gt; *root, TreeNode&lt;T&gt; *current)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree() &#123; root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    Tree(DualTagWidthTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count); <span class="comment">//带双标记先根次序构造算法 </span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;          <span class="comment">//返回树中的根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; Value; &#125;;           <span class="comment">//访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RootFirstTraverse</span><span class="params">(TreeNode&lt;T&gt; *root)</span></span>;      <span class="comment">//先根次序周游，作为测试使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：带双标记层次次序构造算法 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Tree&lt;T&gt;::Tree(DualTagWidthTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="comment">//由带双标记位的层次次序表示构造左孩子右兄弟方式表示的树</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;                                 <span class="comment">//使用STL队列</span></span><br><span class="line">    <span class="built_in">queue</span> &lt; TreeNode&lt;T&gt; * &gt; aQueue;</span><br><span class="line">    <span class="comment">//准备建立根结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">    root = pointer;</span><br><span class="line">    <span class="comment">//处理一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pointer-&gt;setValue(nodeArray[i].info);</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].ltag == <span class="number">0</span>)</span><br><span class="line">            aQueue.push(pointer);                       <span class="comment">//将结点入队</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pointer-&gt;setChild(<span class="literal">NULL</span>);                   <span class="comment">//左孩子设为空</span></span><br><span class="line">        TreeNode&lt;T&gt; *temppointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].rtag == <span class="number">0</span>)</span><br><span class="line">            pointer-&gt;setSibling(temppointer);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pointer-&gt;setSibling(<span class="literal">NULL</span>);                    <span class="comment">//右兄弟设为空</span></span><br><span class="line">            pointer = aQueue.front();                     <span class="comment">//取队列首结点指针</span></span><br><span class="line">            aQueue.pop();                            <span class="comment">//队首元素出队列</span></span><br><span class="line">            pointer-&gt;setChild(temppointer);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer = temppointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理最后一个结点</span></span><br><span class="line">    pointer-&gt;setValue(nodeArray[count - <span class="number">1</span>].info);</span><br><span class="line">    pointer-&gt;setChild(<span class="literal">NULL</span>);</span><br><span class="line">    pointer-&gt;setSibling(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：先根深度遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::RootFirstTraverse(TreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Visit(root-&gt;Value());</span><br><span class="line">        RootFirstTraverse(root-&gt;LeftMostChild());</span><br><span class="line">        root = root-&gt;RightSibling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：周游树，在这里只列举一种（先根次序）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Tree&lt;<span class="keyword">char</span>&gt; *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;FirstRoot traverse:  &quot;</span>;</span><br><span class="line">    tree-&gt;RootFirstTraverse(tree-&gt;getRoot()); <span class="comment">// 先根深度优先周游</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构.图6.5(a)所示的森林</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;      A              G      \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   /  |  \\         /   \\   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  B   C    D      H     I   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;     / \\          |         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    E   F         J         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  0  have right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  1  havn&#x27;t right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  0  have left child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  1  havn&#x27;t left child&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构的带双标记层次次序表示 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayNode</span><span class="params">(<span class="keyword">char</span> *Info, <span class="keyword">int</span> *nRtag, <span class="keyword">int</span> *nLtag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;info   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Info[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nRtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nRtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nLtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示森林结构</span></span><br><span class="line">    DisplayTree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带双标记层次次序构造算法，图6.5(a)所示的森林的带双标记位的层次次序表示为例</span></span><br><span class="line">    <span class="keyword">char</span> strInfo[N] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;J&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nRtag[N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nLtag[N] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dualtag_Width create tree.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//打印带双标记位的层次次序表示 </span></span><br><span class="line">    DisplayNode(strInfo, nRtag, nLtag);</span><br><span class="line"></span><br><span class="line">    DualTagWidthTreeNode&lt;<span class="keyword">char</span>&gt; *nodeArray = <span class="keyword">new</span> DualTagWidthTreeNode&lt;<span class="keyword">char</span>&gt;[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;                <span class="comment">//设置带双标记位的层次次序结点类 </span></span><br><span class="line">        nodeArray[i].info = strInfo[i];</span><br><span class="line">        nodeArray[i].rtag = nRtag[i];</span><br><span class="line">        nodeArray[i].ltag = nLtag[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Tree&lt;<span class="keyword">char</span>&gt; <span class="title">aTree</span><span class="params">(nodeArray, N)</span></span>; <span class="comment">// 建树</span></span><br><span class="line">    Traverse(&amp;aTree);               <span class="comment">// 周游树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="七-图"><a href="#七-图" class="headerlink" title="七    图"></a>七    图</h2><h3 id="Graph-h"><a href="#Graph-h" class="headerlink" title="Graph.h"></a>Graph.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//***********   Graph.h   ************//</span></span><br><span class="line"><span class="comment">//图的基类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Edge类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> weight;    <span class="comment">//weight是边的权</span></span><br><span class="line">    <span class="keyword">int</span> from;      <span class="comment">//from是边的始点</span></span><br><span class="line">    <span class="keyword">int</span> to;        <span class="comment">//to是边的终点</span></span><br><span class="line">    Edge() &#123;        <span class="comment">// 构造函数</span></span><br><span class="line">        from = <span class="number">-1</span>;</span><br><span class="line">        to = <span class="number">-1</span>;</span><br><span class="line">        weight = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Edge(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">int</span> w) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">        from = f;</span><br><span class="line">        to = t;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &lt; arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight == arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &gt; arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &lt;= arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &gt;= arg.weight); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> numVertex;             <span class="comment">//图的顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> numEdge;                <span class="comment">//图的边的数目</span></span><br><span class="line">    <span class="keyword">int</span> *Mark;                    <span class="comment">/*Mark指针指向保存有图的顶点的标志位的数组,标志位用来标记某顶点是否被访问过*/</span></span><br><span class="line">    <span class="keyword">int</span> *Indegree;                <span class="comment">//Indegree指针指向保存有图的顶点的入度的数组</span></span><br><span class="line">    Graph(<span class="keyword">int</span> numVert) &#123;        <span class="comment">//构造函数</span></span><br><span class="line">        numVertex = numVert;      <span class="comment">//确定图的顶点的个数</span></span><br><span class="line">        numEdge = <span class="number">0</span>;                <span class="comment">//确定图的边的数目</span></span><br><span class="line">        Indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex]; <span class="comment">/*为保存图的顶点的入度申请数组,Indegree为数组指针*/</span></span><br><span class="line">        Mark = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex];     <span class="comment">/*为图的顶点的标志位申请数组,Mark为数组指针*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;    <span class="comment">/*确定图的顶点的标志位和入度,即所有顶点的标志位初始化为未被访问过,入度初始化为0*/</span></span><br><span class="line">            Mark[i] = UNVISITED;</span><br><span class="line">            Indegree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graph() &#123;                <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] Mark;</span><br><span class="line">        <span class="keyword">delete</span>[] Indegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;    <span class="comment">// 返回与顶点oneVertex相关联的第一条边</span></span><br><span class="line">        Edge myEdge;</span><br><span class="line">        myEdge.from = oneVertex;</span><br><span class="line">        myEdge.to = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> myEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123;      <span class="comment">// 返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        <span class="keyword">return</span> preEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">VerticesNum</span><span class="params">()</span> </span>&#123;        <span class="comment">//返回图的顶点个数</span></span><br><span class="line">        <span class="keyword">return</span> numVertex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">EdgesNum</span><span class="params">()</span> </span>&#123;            <span class="comment">//返回图的边数</span></span><br><span class="line">        <span class="keyword">return</span> numEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FromVertex</span><span class="params">(Edge oneEdge)</span> </span>&#123;  <span class="comment">// 返回oneEdge的始点</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ToVertex</span><span class="params">(Edge oneEdge)</span> </span>&#123;    <span class="comment">// 返回oneEdge的终点</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Weight</span><span class="params">(Edge oneEdge)</span> </span>&#123;        <span class="comment">// 返回oneEdge的权值</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEdge</span><span class="params">(Edge oneEdge)</span> </span>&#123;    <span class="comment">//如果oneEdge是边则返回TRUE，否则返回FALSE</span></span><br><span class="line">        <span class="keyword">if</span> (oneEdge.weight &gt; <span class="number">0</span> &amp;&amp; oneEdge.weight &lt; INFINITE &amp;&amp; oneEdge.to &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Graphl-h"><a href="#Graphl-h" class="headerlink" title="Graphl.h"></a>Graphl.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************** Link.h **************//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listUnit</span> &#123;</span>    <span class="comment">//邻接表表目中数据部分的结构定义</span></span><br><span class="line">    <span class="keyword">int</span> vertex;      <span class="comment">//边的终点</span></span><br><span class="line">    <span class="keyword">int</span> weight;      <span class="comment">//边的权</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span>   <span class="comment">//链表元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Elem element;      <span class="comment">//表目的数据</span></span><br><span class="line">    Link *next;        <span class="comment">//表目指针，指向下一个表目</span></span><br><span class="line">    Link(<span class="keyword">const</span> Elem &amp;elemval, Link *nextval = <span class="literal">NULL</span>) &#123; <span class="comment">//构造函数</span></span><br><span class="line">        element = elemval;</span><br><span class="line">        next = nextval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Link(Link *nextval = <span class="literal">NULL</span>) &#123;                    <span class="comment">//构造函数</span></span><br><span class="line">        next = nextval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span>   <span class="comment">//链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Link&lt;Elem&gt; *head;  <span class="comment">//head指针并不储存任何实际元素，其存在只是为了操作方便</span></span><br><span class="line">    LList() &#123;          <span class="comment">//构造函数</span></span><br><span class="line">        head = <span class="keyword">new</span> Link&lt;Elem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeall</span><span class="params">()</span> </span>&#123;  <span class="comment">//释放边表所有表目占据的空间</span></span><br><span class="line">        Link&lt;Elem&gt; *fence;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123; <span class="comment">//逐步释放每个表目占据的空间</span></span><br><span class="line">            fence = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> fence;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~LList() &#123;                <span class="comment">//析构函数</span></span><br><span class="line">        removeall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphl</span> :</span> <span class="keyword">public</span> Graph &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LList&lt;listUnit&gt; *graList;  <span class="comment">//graList是保存所有边表的数组	</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graphl(<span class="keyword">int</span> numVert) : Graph(numVert) &#123; <span class="comment">//构造函数</span></span><br><span class="line">        graList = <span class="keyword">new</span> LList&lt;listUnit&gt;[numVertex]; <span class="comment">/*为graList数组申请空间，图有</span></span><br><span class="line"><span class="comment">										  numVertex个顶点，则有numVertex个边表*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graphl() &#123;                        <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] graList;                   <span class="comment">//释放空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;   <span class="comment">//返回顶点oneVertex的第一条边</span></span><br><span class="line">        Edge myEdge;                   <span class="comment">//边myEdge将作为函数的返回值</span></span><br><span class="line">        myEdge.from = oneVertex;       <span class="comment">//将顶点oneVertex作为边myEdge的始点</span></span><br><span class="line">        <span class="comment">/*graList[oneVertex].head保存的是顶点oneVertex的边表，</span></span><br><span class="line"><span class="comment">        temp-&gt;next指向顶点oneVertex的第一条边(如果temp-&gt;next</span></span><br><span class="line"><span class="comment">        不为null)*/</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[oneVertex].head;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;        <span class="comment">//如果顶点oneVertex的第一条边确实存在</span></span><br><span class="line">            myEdge.to = temp-&gt;next-&gt;element.vertex;</span><br><span class="line">            myEdge.weight = temp-&gt;next-&gt;element.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果找到了顶点oneVertex的第一条边,则返回的myEdge确实是一条边;如果没有</span></span><br><span class="line"><span class="comment">        找到顶点oneVertex的第一条边,则myEdge的成员变量to为-1,根据IsEdge函数判</span></span><br><span class="line"><span class="comment">        断可知myEdge不是一条边*/</span></span><br><span class="line">        <span class="keyword">return</span> myEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123;  <span class="comment">// 返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        Edge myEdge;                    <span class="comment">// myEdge的初始成员变量to为-1</span></span><br><span class="line">        myEdge.from = preEdge.from;        <span class="comment">// 将边的始点置为与上一条边的相同</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[preEdge.from].head;        <span class="comment">// temp指向边表头一个</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt;= preEdge.to)</span><br><span class="line">            temp = temp-&gt;next;            <span class="comment">// 确定边preEdge的位置</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;        <span class="comment">// 边preEdge的下一条边存在</span></span><br><span class="line">            myEdge.to = temp-&gt;next-&gt;element.vertex;</span><br><span class="line">            myEdge.weight = temp-&gt;next-&gt;element.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge;                    <span class="comment">// 如果没有找到第一条边，myEdge.to=-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;  <span class="comment">//为图设定一条边</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[from].head;  <span class="comment">/*graList[from].head保存的是顶点from的</span></span><br><span class="line"><span class="comment">													边表，temp-&gt;next指向顶点from的第一条边</span></span><br><span class="line"><span class="comment">													(如果temp-&gt;next不为null)*/</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt; to)</span><br><span class="line">            temp = temp-&gt;next;   <span class="comment">/*确定边(from,to)或&lt;from,to&gt;在边表中的位置,如果不存在,</span></span><br><span class="line"><span class="comment">									则边(from,to)或&lt;from,to&gt;为新加的一条边*/</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;  <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中不存在且在边表中其后</span></span><br><span class="line"><span class="comment">									已无其它边,则在边表中加入这条边*/</span></span><br><span class="line">            temp-&gt;next = <span class="keyword">new</span> Link&lt;listUnit&gt;;</span><br><span class="line">            temp-&gt;next-&gt;element.vertex = to;</span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex == to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中已存在,</span></span><br><span class="line"><span class="comment">												故只需要改变边的权值*/</span></span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex &gt; to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中不存在,但在边表中</span></span><br><span class="line"><span class="comment">												其后存在其它边,则在边表中插入这条边*/</span></span><br><span class="line">            Link&lt;listUnit&gt; *other = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = <span class="keyword">new</span> Link&lt;listUnit&gt;;</span><br><span class="line">            temp-&gt;next-&gt;element.vertex = to;</span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            temp-&gt;next-&gt;next = other;</span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;          <span class="comment">//删掉图的一条边</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[from].head;  <span class="comment">/*graList[from].head保存的是顶点from的边表，temp-&gt;next指向顶点from的第一条边(如果temp-&gt;next不为null)*/</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt; to)</span><br><span class="line">            temp = temp-&gt;next;    <span class="comment">/*确定边(from,to)或&lt;from,to&gt;在边表中的位置(如果该边存在)*/</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;        <span class="comment">//边(from,to)或&lt;from,to&gt;在边表中不存在,则不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex &gt; to)</span><br><span class="line">            <span class="keyword">return</span>;        <span class="comment">//边(from,to)或&lt;from,to&gt;在边表中不存在,则不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex == to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中存在且确</span></span><br><span class="line"><span class="comment">											   定了该边在边表中的位置,则从边表中将其删掉*/</span></span><br><span class="line">            Link&lt;listUnit&gt; *other = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp-&gt;next;</span><br><span class="line">            temp-&gt;next = other;</span><br><span class="line">            numEdge--;</span><br><span class="line">            Indegree[to]--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IniGraphl</span><span class="params">(Graphl *Graphl, <span class="keyword">int</span> A[N][N])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::IniGraphl</span><span class="params">(Graphl *Graphl, <span class="keyword">int</span> A[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                Graphl-&gt;setEdge(i, j, A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：深度优先搜索算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;    <span class="comment">//深度优先搜索算法实现</span></span><br><span class="line">    G.Mark[v] = VISITED;       <span class="comment">//访问顶点v，并标记其标志位</span></span><br><span class="line">    Visit(G, v);</span><br><span class="line">    <span class="comment">//访问V邻接到的未被访问过的顶点，并递归地按照深度优先的方式进行周游</span></span><br><span class="line">    <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED)</span><br><span class="line">            DFS(G, G.ToVertex(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;           <span class="comment">// 广度优先搜索算法的实现</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;                    <span class="comment">// 初始化广度优先周游要用到的队列</span></span><br><span class="line">    Visit(G, v);                       <span class="comment">// 问顶点v，并标记其标志位</span></span><br><span class="line">    G.Mark[v] = VISITED;</span><br><span class="line">    Q.push(v);                       <span class="comment">// v入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">// 如果队列仍然有元素</span></span><br><span class="line">        <span class="keyword">int</span> u = Q.front();              <span class="comment">// 队列顶部元素</span></span><br><span class="line">        Q.pop();                     <span class="comment">// 队列顶部元素出队</span></span><br><span class="line">        <span class="comment">// 该顶点邻接到的每一个未访问顶点都入队</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(u); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED) &#123;</span><br><span class="line">                Visit(G, G.ToVertex(e));</span><br><span class="line">                G.Mark[G.ToVertex(e)] = VISITED;</span><br><span class="line">                Q.push(G.ToVertex(e));  <span class="comment">// 入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示顶点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;V&#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Graphm-h"><a href="#Graphm-h" class="headerlink" title="Graphm.h"></a>Graphm.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的相邻矩阵表示法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphm</span> :</span> <span class="keyword">public</span> Graph &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> **matrix;                <span class="comment">//指向相邻矩阵的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IniGraphm</span><span class="params">(Graphm *Graphm, <span class="keyword">int</span> A[N][N])</span></span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;            <span class="comment">// 深度优先搜索  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;            <span class="comment">// 广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;        <span class="comment">// 访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graphm(<span class="keyword">int</span> numVert) : Graph(numVert) &#123;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">int</span> i, j;            <span class="comment">//i, j作为for循环中的计数器</span></span><br><span class="line">        matrix = (<span class="keyword">int</span> **) <span class="keyword">new</span> <span class="keyword">int</span> *[numVertex]; <span class="comment">/*申请matrix数组,该数组有numVertex个元素,每个元素是整型指针类型*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numVertex; i++)        <span class="comment">/*matrix数组的每个元素,都指向一个具有numVertex个元素的数组*/</span></span><br><span class="line">            matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">             i &lt; numVertex; i++)       <span class="comment">/*相邻矩阵的所有元素都初始化为0,如果矩阵元素matrix[i][j]不为0,则表明顶点i与顶点j之间有一条边,边的权即为matrix[i][j]的值*/</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numVertex; j++)</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graphm() &#123;                            <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++)</span><br><span class="line">            <span class="keyword">delete</span>[] matrix[i];            <span class="comment">//释放每个matrix[i]申请的空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] matrix;                <span class="comment">//释放matrix指针指向的空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;    <span class="comment">//返回顶点oneVertex的第一条边</span></span><br><span class="line">        Edge myEdge;                        <span class="comment">//边myEdge将作为函数的返回值</span></span><br><span class="line">        myEdge.from = oneVertex;            <span class="comment">//将顶点oneVertex作为边myEdge的始点</span></span><br><span class="line">        <span class="comment">//  myEdge.to = -1; </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;<span class="comment">/* 下面寻找第一个使得matrix[oneVertex][i]</span></span><br><span class="line"><span class="comment">												不为0的i值，那么边(oneVertex,i)或者</span></span><br><span class="line"><span class="comment">												弧&lt;oneVertex,i&gt;即为顶点oneVertex</span></span><br><span class="line"><span class="comment">												的第一条边，将顶点i作为边myEdge的终点边myEdge</span></span><br><span class="line"><span class="comment">			                                    的权为矩阵元素matrix[oneVertex][i]的值*/</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[oneVertex][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                myEdge.to = i;</span><br><span class="line">                myEdge.weight = matrix[oneVertex][i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge;<span class="comment">/*如果找到了顶点oneVertex的第一条边,则返回的myEdge确实是一条边；</span></span><br><span class="line"><span class="comment">		              如果没有找到顶点oneVertex的第一条边,则myEdge的成员变量to为-1，</span></span><br><span class="line"><span class="comment">		              根据IsEdge函数判断可知myEdge不是一条边*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123; <span class="comment">//返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        Edge myEdge;</span><br><span class="line">        myEdge.from = preEdge.from; <span class="comment">/*将边myEdge的始点置为与上一条边preEdge的始点相同*/</span></span><br><span class="line">        <span class="keyword">if</span> (preEdge.to &lt; numVertex) &#123;</span><br><span class="line">            <span class="comment">//如果preEdge.to+1&gt;=numVertex,那么就不存在下一条边了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = preEdge.to + <span class="number">1</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">                <span class="comment">/*寻找下一个使得//matrix[preEdge.from][i]不为0的i值,那么</span></span><br><span class="line"><span class="comment">                (preEdge.from,i)或者&lt;preEdge.from,i&gt;即为顶点preEdge.from的下一条边*/</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[preEdge.from][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    myEdge.to = i;</span><br><span class="line">                    myEdge.weight = matrix[preEdge.from][i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge; <span class="comment">/*如果找到了顶点preEdge.from的下一条边，则返回的myEdge确实是一条边；</span></span><br><span class="line"><span class="comment">					   如果没有找到顶点preEdge.from的下一条边，则myEdge的成员变量to为-1，</span></span><br><span class="line"><span class="comment">						根据IsEdge函数判断可知myEdge不是一条边*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;    <span class="comment">//为图设定一条边</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[from][to] &lt;= <span class="number">0</span>) &#123;  <span class="comment">/*如果matrix[from][to]&lt;=0，则边(from,to) 或者&lt;from,to&gt;</span></span><br><span class="line"><span class="comment">			                       将是新增的一条边，否则该边已经存在（现在只是对该边进行修改）*/</span></span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[from][to] = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;     <span class="comment">//删除图的一条边</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[from][to] &gt; <span class="number">0</span>) &#123; <span class="comment">/*如果matrix[from][to]&gt;0，则边(from,to)或者&lt;from,to&gt;确实存在，</span></span><br><span class="line"><span class="comment">			                      否则该边实际上并不存在（从而不必对图的边数和顶点to的入度进行修改）*/</span></span><br><span class="line">            numEdge--;</span><br><span class="line">            Indegree[to]--;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[from][to] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::IniGraphm</span><span class="params">(Graphm *Graphm, <span class="keyword">int</span> A[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                Graphm-&gt;setEdge(i, j, A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：深度优先搜索算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;    <span class="comment">//深度优先搜索算法实现</span></span><br><span class="line">    G.Mark[v] = VISITED;       <span class="comment">//访问顶点v，并标记其标志位</span></span><br><span class="line">    Visit(G, v);</span><br><span class="line">    <span class="comment">//访问V邻接到的未被访问过的顶点，并递归地按照深度优先的方式进行周游</span></span><br><span class="line">    <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED)</span><br><span class="line">            DFS(G, G.ToVertex(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">// 广度优先搜索算法的实现</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;                    <span class="comment">// 初始化广度优先周游要用到的队列</span></span><br><span class="line">    Visit(G, v);                       <span class="comment">// 问顶点v，并标记其标志位</span></span><br><span class="line">    G.Mark[v] = VISITED;</span><br><span class="line">    Q.push(v);                       <span class="comment">// v入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">// 如果队列仍然有元素</span></span><br><span class="line">        <span class="keyword">int</span> u = Q.front();              <span class="comment">// 队列顶部元素</span></span><br><span class="line">        Q.pop();                     <span class="comment">// 队列顶部元素出队</span></span><br><span class="line">        <span class="comment">// 该顶点邻接到的每一个未访问顶点都入队</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(u); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED) &#123;</span><br><span class="line">                Visit(G, G.ToVertex(e));</span><br><span class="line">                G.Mark[G.ToVertex(e)] = VISITED;</span><br><span class="line">                Q.push(G.ToVertex(e));  <span class="comment">// 入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示顶点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;V&#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="TopsortbyQueue-cpp"><a href="#TopsortbyQueue-cpp" class="headerlink" title="TopsortbyQueue.cpp"></a>TopsortbyQueue.cpp</h3><p><a herf="Graphm.h">#include “Graphm.hh”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图的相邻矩阵表示存储图，实现图的拓扑排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示排序后的序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************************************************</span></span><br><span class="line"><span class="comment">//[算法7.7] 队列实现的图拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopsortbyQueue</span><span class="params">(Graph &amp;G)</span> </span>&#123;      <span class="comment">//队列方式实现的拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)    <span class="comment">//初始化Mark数组</span></span><br><span class="line">        G.Mark[i] = UNVISITED;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Q.push(i);                <span class="comment">//图中入度为0的顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">//如果队列中还有图的顶点</span></span><br><span class="line">        <span class="keyword">int</span> V = Q.front();</span><br><span class="line">        Q.pop();                     <span class="comment">//一个顶点出队</span></span><br><span class="line">        Visit(G, V);</span><br><span class="line">        G.Mark[V] = VISITED;</span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(V); G.IsEdge(e); e = G.NextEdge(e)) &#123;</span><br><span class="line">            G.Indegree[G.ToVertex(e)]--;  <span class="comment">//所有与之相邻的顶点入度-1</span></span><br><span class="line">            <span class="keyword">if</span> (G.Indegree[G.ToVertex(e)] == <span class="number">0</span>)</span><br><span class="line">                Q.push(G.ToVertex(e));   <span class="comment">//入度为0的顶点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[i] == UNVISITED) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 此图有环！&quot;</span>;        <span class="comment">//图有环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//C0  C1  C2  C3  C4  C5  C6  C7  C8	</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;  <span class="comment">//该图为图7.18表示课程优先关系的有向无环图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>;              <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Top sort by Queue is : &quot;</span>;</span><br><span class="line">    TopsortbyQueue(aGraphm);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOK! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra-cpp"><a href="#Dijkstra-cpp" class="headerlink" title="Dijkstra.cpp"></a>Dijkstra.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图的相邻矩阵表示方法,还要用到最小值堆</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 9999    <span class="comment">//设置最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph_matrix.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[代码7.8] Dijkstra算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span>  &#123;</span>      <span class="comment">//定义Dist类，下面的Dijkstra算法和Floyd算法要用到</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	 <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">	 <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">	 <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">	 Dist() &#123;&#125;;</span><br><span class="line">	 ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Dist &amp; arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length==arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&gt;arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&lt;=arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&gt;=arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra算法，其中参数G是图，参数s是源顶点，D是保存最短距离及其路径的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; G, <span class="keyword">int</span> s, Dist* &amp;D)</span>  </span>&#123;</span><br><span class="line">	D = <span class="keyword">new</span> Dist[G. VerticesNum()];          	<span class="comment">// D数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;   	<span class="comment">// 初始化Mark数组、D数组</span></span><br><span class="line">		G.Mark[i] = UNVISITED;</span><br><span class="line">        D[i].index = i;</span><br><span class="line">        D[i].length = INFINITE;</span><br><span class="line">        D[i].pre = s;</span><br><span class="line">    &#125;</span><br><span class="line">    D[s].length = <span class="number">0</span>; </span><br><span class="line">    <span class="function">MinHeap&lt;Dist&gt; <span class="title">H</span><span class="params">(G. EdgesNum())</span></span>;       	<span class="comment">// 最小值堆（minheap）</span></span><br><span class="line">    H.Insert(D[s]);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> FOUND = <span class="literal">false</span>;</span><br><span class="line">        Dist d;</span><br><span class="line">        <span class="keyword">while</span> (!H.isEmpty())  &#123;</span><br><span class="line">			d = H.RemoveMin(); </span><br><span class="line">			<span class="keyword">if</span>(G.Mark[d.index]==UNVISITED) &#123;                <span class="comment">//打印出路径信息</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;vertex index: &quot;</span> &lt;&lt;d.index&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;vertex pre  : &quot;</span> &lt;&lt;d.pre  &lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;V0 --&gt; V&quot;</span> &lt;&lt; d.index &lt;&lt;<span class="string">&quot;  length    : &quot;</span> &lt;&lt;d.length&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (G.Mark[d.index] == UNVISITED) &#123; <span class="comment">//找到距离s最近的顶点</span></span><br><span class="line">				FOUND = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span> (!FOUND)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> v = d.index;</span><br><span class="line">		G.Mark[v] = VISITED;           		<span class="comment">// 把该点加入已访问组</span></span><br><span class="line">		<span class="comment">// 因为v的加入，需要刷新v邻接点的D值</span></span><br><span class="line">		<span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e);e = G.NextEdge(e))</span><br><span class="line">			<span class="keyword">if</span> (D[G.ToVertex(e)].length &gt; (D[v].length+G.Weight(e))) &#123;</span><br><span class="line">				D[G.ToVertex(e)].length = D[v].length+G.Weight(e);</span><br><span class="line">				D[G.ToVertex(e)].pre = v;</span><br><span class="line">				H.Insert(D[G.ToVertex(e)]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] =  &#123;          <span class="comment">//图7.20  单源最短路径的示例</span></span><br><span class="line"><span class="comment">//  v0  v1  v2  v3  v4  </span></span><br><span class="line">	 <span class="number">0</span>, <span class="number">10</span>,  <span class="number">0</span>, <span class="number">30</span>, <span class="number">100</span>,</span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>, <span class="number">50</span>,  <span class="number">0</span>,  <span class="number">0</span>, </span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, <span class="number">10</span>, </span><br><span class="line">     <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>,  <span class="number">0</span>, <span class="number">60</span>, </span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line"> aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"> Dist *D;</span><br><span class="line"> Dijkstra(aGraphm, <span class="number">0</span>, D);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图用相邻矩阵表示方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"><span class="comment">//这里要注意 图类中的边为无穷大的时候也应该看成是一条边</span></span><br><span class="line"><span class="comment">//所以要修改一下IsEdge函数的定义</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span> &#123;</span>      <span class="comment">//定义Dist类，下面的Dijkstra算法和Floyd算法要用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">    <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">    Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[算法7.9] Floyd算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(Graph &amp;G, Dist **&amp;D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, v;                               <span class="comment">// i,j,v是计数器</span></span><br><span class="line">    D = <span class="keyword">new</span> Dist *[G.VerticesNum()];          <span class="comment">// 为数组D申请空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        D[i] = <span class="keyword">new</span> Dist[G.VerticesNum()];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)          <span class="comment">// 初始化数组D</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.VerticesNum(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                D[i][j].length = <span class="number">0</span>;</span><br><span class="line">                D[i][j].pre = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                D[i][j].length = INFINITE;</span><br><span class="line">                D[i][j].pre = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.VerticesNum(); v++)</span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e)) &#123;</span><br><span class="line">            D[v][G.ToVertex(e)].length = G.Weight(e);</span><br><span class="line">            D[v][G.ToVertex(e)].pre = v;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果两个顶点间的最短路径经过顶点v，则更新最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.VerticesNum(); v++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.VerticesNum(); j++)</span><br><span class="line">                <span class="keyword">if</span> (D[i][j].length &gt; (D[i][v].length + D[v][j].length)) &#123;</span><br><span class="line">                    D[i][j].length = D[i][v].length + D[v][j].length;</span><br><span class="line">                    D[i][j].pre = D[v][j].pre;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line"><span class="comment">//	V0    V1    V2</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">3</span>, INFINITE, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Dist **D;</span><br><span class="line">    Floyd(aGraphm, D);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; D[i][j].length &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7         <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span> &#123;</span>      <span class="comment">//定义Dist类，下面的Prim算法要用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">    <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">    Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graphm &amp;G, <span class="keyword">int</span> s, Dist *&amp;D)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minVertex</span><span class="params">(Graph &amp;G, Dist *&amp;D)</span> </span>&#123;            <span class="comment">// 在Dist数组中找最小值</span></span><br><span class="line">    <span class="keyword">int</span> i, v;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[i] == UNVISITED) &#123;</span><br><span class="line">            v = i;                        <span class="comment">// 让v为随意一个未访问的定义</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> ((G.Mark[i] == UNVISITED) &amp;&amp; (D[i] &lt; D[v]))</span><br><span class="line">            v = i;                        <span class="comment">// 保存目前发现的具有最小距离的顶点</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最小支撑树的Prim算法，</span></span><br><span class="line"><span class="comment">//参数G是图，参数s是开始顶点，参数MST是保存最小支撑树中所有边的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdgetoMST</span><span class="params">(Edge e, Edge *&amp;MST, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MST[n] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> s, Edge *&amp;MST)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MSTtag = <span class="number">0</span>;                       <span class="comment">// 最小生成树边的标号</span></span><br><span class="line">    MST = <span class="keyword">new</span> Edge[G.VerticesNum() - <span class="number">1</span>];</span><br><span class="line">    Dist *D;</span><br><span class="line">    D = <span class="keyword">new</span> Dist[G.VerticesNum()];            <span class="comment">// D数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;    <span class="comment">// 初始化Mark数组、D数组</span></span><br><span class="line">        G.Mark[i] = UNVISITED;</span><br><span class="line">        D[i].index = i;</span><br><span class="line">        D[i].length = INFINITE;</span><br><span class="line">        D[i].pre = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    D[s].length = <span class="number">0</span>;</span><br><span class="line">    G.Mark[s] = VISITED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum() - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (D[v] == INFINITY) <span class="keyword">return</span>;        <span class="comment">// 非连通，有不可达顶点，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为v的加入，需要刷新v邻接点的D值</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] != VISITED &amp;&amp; (D[G.ToVertex(e)].length &gt; e.weight)) &#123;</span><br><span class="line">                D[G.ToVertex(e)].length = e.weight;</span><br><span class="line">                D[G.ToVertex(e)].pre = v;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        v = minVertex(G, D);</span><br><span class="line"></span><br><span class="line">        G.Mark[v] = VISITED;</span><br><span class="line">        <span class="function">Edge <span class="title">edge</span><span class="params">(D[v].pre, D[v].index, D[v].length)</span></span>;</span><br><span class="line"></span><br><span class="line">        AddEdgetoMST(edge, MST, MSTtag++);  <span class="comment">// 将边e加到MST中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//   v0  v1  v2  v3  v4  v5  v6     </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">20</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;                                    <span class="comment">//图7.24 带权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Edge *D;</span><br><span class="line">    Prim(aGraphm, <span class="number">0</span>, D);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;V&quot;</span> &lt;&lt; D[i].from &lt;&lt; <span class="string">&quot;-&gt;V&quot;</span> &lt;&lt; D[i].to &lt;&lt; <span class="string">&quot;   Weight is : &quot;</span> &lt;&lt; D[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7         <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ParTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最小支撑树的Kruskal算法，</span></span><br><span class="line"><span class="comment">//参数G是图，参数MST是保存最小支撑树中所有边的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdgetoMST</span><span class="params">(Edge e, Edge *&amp;MST, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MST[n] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Graph &amp;G, Edge *&amp;MST)</span> </span>&#123;</span><br><span class="line">    <span class="function">ParTree&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(G.VerticesNum())</span></span>;           <span class="comment">//等价类</span></span><br><span class="line">    <span class="function">MinHeap&lt;Edge&gt; <span class="title">H</span><span class="params">(G.EdgesNum())</span></span>;        <span class="comment">//最小值堆（minheap）    </span></span><br><span class="line">    MST = <span class="keyword">new</span> Edge[G.VerticesNum() - <span class="number">1</span>];      <span class="comment">//最小支撑树</span></span><br><span class="line">    <span class="keyword">int</span> MSTtag = <span class="number">0</span>;                         <span class="comment">//最小支撑树边的标号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)  <span class="comment">//将图的所有边插入最小值堆H中</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(i); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.FromVertex(e) &lt; G.ToVertex(e))  <span class="comment">//因为是无向图，所以应防止重复插入</span></span><br><span class="line">                H.Insert(e);</span><br><span class="line">    <span class="keyword">int</span> EquNum = G.VerticesNum();              <span class="comment">//开始时有|V|个等价类</span></span><br><span class="line">    <span class="keyword">while</span> (EquNum &gt; <span class="number">1</span>) &#123;                     <span class="comment">//合并等价类</span></span><br><span class="line">        Edge e = H.RemoveMin();               <span class="comment">//获得下一条权最小的边</span></span><br><span class="line">        <span class="keyword">if</span> (e.weight == INFINITE) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不存在最小支撑树.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] MST;                     <span class="comment">//释放空间</span></span><br><span class="line">            MST = <span class="literal">NULL</span>;                   <span class="comment">//MST是空数组</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> from = G.FromVertex(e);            <span class="comment">//记录该条边的信息</span></span><br><span class="line">        <span class="keyword">int</span> to = G.ToVertex(e);</span><br><span class="line">        <span class="keyword">if</span> (A.Different(from, to)) &#123;            <span class="comment">//如果边e的两个顶点不在一个等价类</span></span><br><span class="line">            A.Union(from, to);     <span class="comment">//将边e的两个顶点所在的两个等价类合并为一个</span></span><br><span class="line">            AddEdgetoMST(e, MST, MSTtag++); <span class="comment">//将边e加到MST</span></span><br><span class="line">            EquNum--;                     <span class="comment">//将等价类的个数减1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//   v0  v1  v2  v3  v4  v5  v6     </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">20</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;                                    <span class="comment">//图7.24 带权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Edge *D;</span><br><span class="line">    Kruskal(aGraphm, D);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;V&quot;</span> &lt;&lt; D[i].from &lt;&lt; <span class="string">&quot;-&gt;V&quot;</span> &lt;&lt; D[i].to &lt;&lt; <span class="string">&quot;   Weight is : &quot;</span> &lt;&lt; D[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八-内排序"><a href="#八-内排序" class="headerlink" title="八    内排序"></a>八    内排序</h2><h3 id="InsertSort-h"><a href="#InsertSort-h" class="headerlink" title="InsertSort.h"></a>InsertSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接插入排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    Record TempRecord;                        <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;                    <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        TempRecord = Array[i];                    <span class="comment">// 先把记录Array[i]保留在临时记录变量中</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                            <span class="comment">// 内存循环变量从j从i-1开始</span></span><br><span class="line">        <span class="comment">// 往前寻找记录i的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; TempRecord &lt; Array[j]) &#123;</span><br><span class="line">            Array[j + <span class="number">1</span>] = Array[j];                <span class="comment">// 将那些大于等于记录i的记录后移</span></span><br><span class="line">            j = j - <span class="number">1</span>;                        <span class="comment">// 下标j前移</span></span><br><span class="line">        &#125;</span><br><span class="line">        Array[j + <span class="number">1</span>] = TempRecord;                <span class="comment">// 此时j+1就是记录i的正确位置，回填</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShellSort-h"><a href="#ShellSort-h" class="headerlink" title="ShellSort.h"></a>ShellSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;            <span class="comment">// Shell排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> delta = n / <span class="number">2</span>; delta &gt; <span class="number">0</span>; delta /= <span class="number">2</span>)        <span class="comment">// 增量delta每次除以2递减</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++)            <span class="comment">// 分别对delta个子序列进行插入排序</span></span><br><span class="line">            ModInsSort(&amp;Array[i], n - i, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModInsSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> delta)</span> </span>&#123;    <span class="comment">// 修改的插入排序算法，参数delta表示当前的增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = delta; i &lt; n; i += delta)            <span class="comment">// 对子序列中第i个记录，寻找合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= delta; j -= delta) &#123;        <span class="comment">//  j以dealta为步长向前寻找逆置对进行调整</span></span><br><span class="line">            <span class="keyword">if</span> (Array[j] &lt; Array[j - delta])        <span class="comment">//  Array[j] &lt; Array[j-delta]，则二者为逆置对</span></span><br><span class="line">                swap(Array, j, j - delta);        <span class="comment">// 交换Array[j]和Array[j-delta]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SelectSort-h"><a href="#SelectSort-h" class="headerlink" title="SelectSort.h"></a>SelectSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;    <span class="comment">// 直接选择排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;            <span class="comment">// 依次选出第i小的记录，即剩余记录中最小的那个</span></span><br><span class="line">        <span class="keyword">int</span> Smallest = i;                <span class="comment">// 首先假设记录i就是最小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)            <span class="comment">// 开始向后扫描所有剩余记录</span></span><br><span class="line">            <span class="keyword">if</span> (Array[j] &lt; Array[Smallest])</span><br><span class="line">                Smallest = j;            <span class="comment">// 如果发现更小的记录，记录它的位置</span></span><br><span class="line">        swap(Array, i, Smallest);            <span class="comment">// 交换Array[i]和 Array[Smallest]，第i小的记录到位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    SelectSort(Array, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MaxHeap-h"><a href="#MaxHeap-h" class="headerlink" title="MaxHeap.h"></a>MaxHeap.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heapArray;                            <span class="comment">//存放堆数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> CurrentSize;                        <span class="comment">//当前堆中元素数目</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                            <span class="comment">//堆所能容纳的最大元素数目</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(T *<span class="built_in">array</span>, <span class="keyword">int</span> num, <span class="keyword">int</span> max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~MaxHeap() &#123;&#125;;                    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//如果是叶结点，返回TRUE</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回左孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rightchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回右孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//返回父结点位置</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> pos, T &amp;node)</span></span>;            <span class="comment">//删除给定下标的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftDown</span><span class="params">(<span class="keyword">int</span> left)</span></span>;                <span class="comment">//筛选法函数，参数left表示开始处理的数组下标</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftUp</span><span class="params">(<span class="keyword">int</span> position)</span></span>;                <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T &amp;newNode)</span></span>;            <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveMax</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶移动最大值到尾部</span></span><br><span class="line">    <span class="function">T &amp;<span class="title">RemoveMax</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶删除最大值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">MaxHeap&lt;T&gt;::MaxHeap(T *<span class="built_in">array</span>, <span class="keyword">int</span> num, <span class="keyword">int</span> max) &#123;</span><br><span class="line">    heapArray = <span class="built_in">array</span>;</span><br><span class="line">    CurrentSize = num;</span><br><span class="line">    MaxSize = max;</span><br><span class="line">    BuildHeap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::BuildHeap() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = CurrentSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        SiftDown(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::isLeaf(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &gt;= CurrentSize / <span class="number">2</span>) &amp;&amp; (pos &lt; CurrentSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::leftchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">1</span>;                        <span class="comment">//返回左孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::rightchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">2</span>;                        <span class="comment">//返回右孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::parent(<span class="keyword">int</span> pos) <span class="keyword">const</span>    <span class="comment">//返回父节点位置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (pos - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::SiftDown(<span class="keyword">int</span> left) &#123;</span><br><span class="line">    <span class="comment">//准备</span></span><br><span class="line">    <span class="keyword">int</span> i = left;                            <span class="comment">//标识父结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>;                        <span class="comment">//标识关键值较小的子结点		</span></span><br><span class="line">    T temp = heapArray[i];                <span class="comment">//保存父结点</span></span><br><span class="line">    <span class="comment">//过筛</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; CurrentSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((j &lt; CurrentSize) &amp;&amp; (heapArray[j] &lt; heapArray[j + <span class="number">1</span>]))</span><br><span class="line">            j++;                        <span class="comment">//j指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; heapArray[j]) &#123;</span><br><span class="line">            heapArray[i] = heapArray[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * j + <span class="number">1</span>;                    <span class="comment">//向下继续</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::SiftUp(<span class="keyword">int</span> position) &#123;<span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="keyword">int</span> temppos = position;</span><br><span class="line">    T temp = heapArray[temppos];</span><br><span class="line">    <span class="keyword">int</span> parentpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (temppos &gt; <span class="number">0</span>)</span><br><span class="line">        parentpos = parent(temppos);</span><br><span class="line">    <span class="keyword">while</span> ((temppos &gt; <span class="number">0</span>) &amp;&amp; (heapArray[parentpos] &lt; temp)) &#123;</span><br><span class="line">        heapArray[temppos] = heapArray[parentpos];</span><br><span class="line">        temppos = parentpos;</span><br><span class="line">        parentpos = parent(temppos);</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[temppos] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::Insert(<span class="keyword">const</span> T &amp;newNode) &#123;<span class="comment">//向堆中插入一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == MaxSize)                <span class="comment">//堆空间已经满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    heapArray[CurrentSize] = newNode;</span><br><span class="line">    SiftUp(CurrentSize);                    <span class="comment">//向上调整</span></span><br><span class="line">    CurrentSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T &amp;MaxHeap&lt;T&gt;::RemoveMax() &#123;</span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//AfxMessageBox(&quot;Can&#x27;t Delete&quot;);</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T temp = heapArray[<span class="number">0</span>];                    <span class="comment">//取堆顶元素</span></span><br><span class="line">        heapArray[<span class="number">0</span>] = heapArray[CurrentSize - <span class="number">1</span>];    <span class="comment">//堆末元素上升至堆顶</span></span><br><span class="line">        CurrentSize--;</span><br><span class="line">        SiftDown(<span class="number">0</span>);                            <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::MoveMax() &#123;</span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//堆为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T temp = heapArray[<span class="number">0</span>];                    <span class="comment">//取堆顶元素</span></span><br><span class="line">        heapArray[<span class="number">0</span>] = heapArray[CurrentSize - <span class="number">1</span>];    <span class="comment">//堆末元素上升至堆顶</span></span><br><span class="line">        CurrentSize--;</span><br><span class="line">        SiftDown(<span class="number">0</span>);                            <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        heapArray[CurrentSize] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::Remove(<span class="keyword">int</span> pos, T &amp;node) &#123;<span class="comment">// 删除给定下标的元素</span></span><br><span class="line">    <span class="keyword">if</span> ((pos &lt; <span class="number">0</span>) || (pos &gt; CurrentSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    heapArray[pos] = heapArray[--CurrentSize];    <span class="comment">//指定元素置于最后</span></span><br><span class="line">    SiftUp(pos);                                <span class="comment">//上升筛</span></span><br><span class="line">    SiftDown(pos);                                <span class="comment">//向下筛	</span></span><br><span class="line">    node = heapArray[CurrentSize];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Heapsort-h"><a href="#Heapsort-h" class="headerlink" title="Heapsort.h"></a>Heapsort.h</h3><p><a herf="MaxHeap.h">#include “MaxHeap.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MaxHeap.h&quot;</span></span></span><br><span class="line"><span class="comment">//堆排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapsort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MaxHeap&lt;Record&gt; max_heap = MaxHeap&lt;Record&gt;(Array, n, n);    <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)         <span class="comment">// 依次找出剩余记录中的最大记录，即堆顶</span></span><br><span class="line">        max_heap.MoveMax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BubbleSort-h"><a href="#BubbleSort-h" class="headerlink" title="BubbleSort.h"></a>BubbleSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span>  </span>&#123;	<span class="comment">// 优化的冒泡排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">	<span class="keyword">bool</span> NoSwap;			<span class="comment">// 是否发生了交换的标志</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)  &#123;</span><br><span class="line">	NoSwap = <span class="literal">true</span>;		<span class="comment">// 标志初始为真</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=i; j--)</span><br><span class="line">	  <span class="keyword">if</span> (Array[j] &lt; Array[j<span class="number">-1</span>])  &#123;	<span class="comment">// 判断（Array[j-1]，Array[j]）是否逆置</span></span><br><span class="line">		swap(Array, j, j<span class="number">-1</span>);	<span class="comment">// 交换逆置对Array[j]，Array[j-1]</span></span><br><span class="line">		NoSwap = <span class="literal">false</span>;		<span class="comment">// 发生了交换，标志变为假</span></span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">if</span> (NoSwap)  			<span class="comment">// 如果没发生过交换，表示已排好序，结束算法</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="QuickSort-h"><a href="#QuickSort-h" class="headerlink" title="QuickSort.h"></a>QuickSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;                <span class="comment">// 选择轴值，参数left,right分别表示序列的左右端下标</span></span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2</span>;                        <span class="comment">// 选择中间记录作为轴值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// Array[]为待排序数组，left,right分别为数组两端</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;                    <span class="comment">// 如果子序列中只有0或1个记录，就不需排序</span></span><br><span class="line">    <span class="keyword">int</span> pivot = ::SelectPivot(left, right);            <span class="comment">// 选择轴值</span></span><br><span class="line">    swap(Array, pivot, right);                <span class="comment">// 分割前先将轴值放到数组末端</span></span><br><span class="line">    pivot = Partition(Array, left, right);            <span class="comment">// 分割后轴值已到达正确位置</span></span><br><span class="line">    QuickSort(Array, left, pivot - <span class="number">1</span>);                <span class="comment">// 对轴值左边的子序列进行递归快速排序</span></span><br><span class="line">    QuickSort(Array, pivot + <span class="number">1</span>, right);            <span class="comment">// 对轴值右边的子序列进行递归快速排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// 分割函数，分割后轴值已到达正确位置</span></span><br><span class="line">    <span class="keyword">int</span> l = left;                                <span class="comment">//  l为左指针，r为右指针</span></span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    Record TempRecord = Array[r];                <span class="comment">// 将轴值存放在临时变量中</span></span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;                            <span class="comment">// 开始分割，l,r不断向中间移动，直到相遇</span></span><br><span class="line">        <span class="comment">// l指针向右移动，直到找到一个大于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[l] &lt;= TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把&quot;&lt;=&quot;改写为&quot;&lt;&quot;，反正不稳定</span></span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到右边的空位</span></span><br><span class="line">            Array[r] = Array[l];</span><br><span class="line">            r--;                            <span class="comment">//  r指针向左移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r指针向左移动，直到找到一个小于等于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[r] &gt; TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把&quot;&gt;&quot;改写为&quot;&gt;=&quot;，减少记录移动</span></span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到左边的空位</span></span><br><span class="line">            Array[l] = Array[r];</span><br><span class="line">            l++;                            <span class="comment">// l指针向右移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">//end while</span></span><br><span class="line">    Array[l] = TempRecord;                    <span class="comment">// 把轴值回填到分界位置l上</span></span><br><span class="line">    <span class="keyword">return</span> l;                                <span class="comment">// 返回分界位置l</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModQuickSort-h"><a href="#ModQuickSort-h" class="headerlink" title="ModQuickSort.h"></a>ModQuickSort.h</h3><p><a herf="InsertSort.h">#include “InsertSort.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;            <span class="comment">// 选择轴值，参数left,right分别表示序列的左右端下标</span></span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2</span>;                    <span class="comment">// 选择中间纪录作为轴值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModQuickSort</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;  <span class="comment">// 优化的快速排序，</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;            <span class="comment">// 如果序列中只有0或1个记录，就不用排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; THRESHOLD) &#123;        <span class="comment">// 对长度大于阈值(28最佳)的长子串处理</span></span><br><span class="line">        <span class="keyword">int</span> pivot = ::SelectPivot(left, right);        <span class="comment">// 选择轴值	</span></span><br><span class="line">        swap(Array, pivot, right);        <span class="comment">// 将轴值放在数组末端</span></span><br><span class="line">        pivot = Partition(Array, left, right);        <span class="comment">// 分割后轴值已到达正确位置</span></span><br><span class="line">        ModQuickSort(Array, left, pivot - <span class="number">1</span>);        <span class="comment">// 对轴值左边的子序列进行递归快速排序</span></span><br><span class="line">        ModQuickSort(Array, pivot + <span class="number">1</span>, right);        <span class="comment">// 对轴值右边的子序列进行递归快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// 分割函数，分割后轴值已到达正确位置</span></span><br><span class="line">    <span class="keyword">int</span> l = left;                                <span class="comment">//  l为左指针，r为右指针</span></span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    Record TempRecord = Array[r];                <span class="comment">// 将轴值存放在临时变量中</span></span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;                            <span class="comment">// 开始分割，l,r不断向中间移动，直到相遇</span></span><br><span class="line">        <span class="comment">// l指针向右移动，直到找到一个大于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[l] &lt;= TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把“&lt;=”改写为“&lt;”，反正不稳定</span></span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到右边的空位</span></span><br><span class="line">            Array[r] = Array[l];</span><br><span class="line">            r--;                            <span class="comment">//  r指针向左移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r指针向左移动，直到找到一个小于等于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[r] &gt; TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把“&gt;”改写为“&gt;=”，减少记录移动</span></span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到左边的空位</span></span><br><span class="line">            Array[l] = Array[r];</span><br><span class="line">            l++;                            <span class="comment">// l指针向右移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">//end while</span></span><br><span class="line">    Array[l] = TempRecord;                    <span class="comment">// 把轴值回填到分界位置l上</span></span><br><span class="line">    <span class="keyword">return</span> l;                                <span class="comment">// 返回分界位置l</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ModQuickSort(Array, <span class="number">0</span>, n - <span class="number">1</span>);            <span class="comment">// 调用优化的递归快排，不处理小子串</span></span><br><span class="line">    InsertSort(Array, n);                <span class="comment">// 最后这个序列进行扫尾插入排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MergeSort-h"><a href="#MergeSort-h" class="headerlink" title="MergeSort.h"></a>MergeSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两路归并排序，Array[]为待排序数组，left，right分别为数组两端</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;                            <span class="comment">// 如果序列中只有0或1个记录，就不用排序</span></span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;                    <span class="comment">//从中间划分为两个子序列</span></span><br><span class="line">        MergeSort(Array, TempArray, left, middle);        <span class="comment">//对左边一半进行递归</span></span><br><span class="line">        MergeSort(Array, TempArray, middle + <span class="number">1</span>, right);    <span class="comment">//对右边一半进行递归</span></span><br><span class="line">        Merge(Array, TempArray, left, right, middle);        <span class="comment">// 进行归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> middle)</span> </span>&#123;  <span class="comment">//归并过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; j++)                    <span class="comment">// 将数组暂存入临时数组</span></span><br><span class="line">        TempArray[j] = Array[j];</span><br><span class="line">    <span class="keyword">int</span> index1 = left;                                <span class="comment">// 左边子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> index2 = middle + <span class="number">1</span>;                            <span class="comment">// 右边子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> i = left;                                    <span class="comment">// 从左开始归并</span></span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= middle &amp;&amp; index2 &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//取较小者插入合并数组中</span></span><br><span class="line">        <span class="keyword">if</span> (TempArray[index1] &lt;= TempArray[index2])    <span class="comment">// 为保证稳定性，相等时左边优先</span></span><br><span class="line">            Array[i++] = TempArray[index1++];</span><br><span class="line">        <span class="keyword">else</span> Array[i++] = TempArray[index2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= middle)                        <span class="comment">// 只剩左序列，可以直接复制</span></span><br><span class="line">        Array[i++] = TempArray[index1++];</span><br><span class="line">    <span class="keyword">while</span> (index2 &lt;= right)                        <span class="comment">// 与上个循环互斥，直接复制剩余的右序列</span></span><br><span class="line">        Array[i++] = TempArray[index2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Record *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) temp = <span class="keyword">new</span> Record[n];            <span class="comment">// 申请辅助数组</span></span><br><span class="line">    MergeSort(<span class="built_in">array</span>, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ModMergeSort-h"><a href="#ModMergeSort-h" class="headerlink" title="ModMergeSort.h"></a>ModMergeSort.h</h3><p><a herf="InsertSort.h">#include “InsertSort.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接插入排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    Record TempRecord;                        <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;                    <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        TempRecord = Array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从i开始往前寻找记录i的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; TempRecord &lt; Array[j]) &#123;</span><br><span class="line">            Array[j + <span class="number">1</span>] = Array[j];                <span class="comment">// 将那些大于等于记录i的记录后移</span></span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Array[j + <span class="number">1</span>] = TempRecord;                <span class="comment">// 此时j后面就是记录i的正确位置，回填</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModMergeSort</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	if (right &lt;= left)	return;						// 如果只含有一个元素，直接返回		  </span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; THRESHOLD) &#123;                <span class="comment">//如果序列长度大于阈值(16最佳)，跳出递归</span></span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;                    <span class="comment">// 从中间划分为两个子序列</span></span><br><span class="line">        ModMergeSort(Array, TempArray, left, middle);    <span class="comment">// 对左边一半进行递归</span></span><br><span class="line">        ModMergeSort(Array, TempArray, middle + <span class="number">1</span>, right);    <span class="comment">// 对右边一半进行递归</span></span><br><span class="line">        ModMerge(Array, TempArray, left, right, middle);    <span class="comment">// 进行归并</span></span><br><span class="line">    &#125; <span class="keyword">else</span> InsertSort(&amp;Array[left], right - left + <span class="number">1</span>);            <span class="comment">// 若长度小于等于阈值，采用直接插入排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModMerge</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> middle)</span> </span>&#123;    <span class="comment">//归并过程</span></span><br><span class="line">    <span class="keyword">int</span> index1, index2;                            <span class="comment">// 两个子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt;= middle; i++)                        <span class="comment">// 复制左边的子序列</span></span><br><span class="line">        TempArray[i] = Array[i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= right - middle; j++)                    <span class="comment">// 复制右边的子序列，但顺序颠倒过来</span></span><br><span class="line">        TempArray[right - j + <span class="number">1</span>] = Array[j + middle];</span><br><span class="line">    <span class="comment">// 开始归并，取较小者插入合并数组中</span></span><br><span class="line">    <span class="keyword">for</span> (index1 = left, index2 = right, k = left; k &lt;= right; k++)</span><br><span class="line">        <span class="keyword">if</span> (TempArray[index1] &lt;= TempArray[index2])    <span class="comment">// 为保证稳定性，相等时左边优先</span></span><br><span class="line">            Array[k] = TempArray[index1++];</span><br><span class="line">        <span class="keyword">else</span> Array[k] = TempArray[index2--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Record *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) temp = <span class="keyword">new</span> Record[n];                <span class="comment">// 申请辅助数组</span></span><br><span class="line">    ModMergeSort(<span class="built_in">array</span>, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BucketSort-h"><a href="#BucketSort-h" class="headerlink" title="BucketSort.h"></a>BucketSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 桶式排序，Array[]为待排序数组，数组长度为n，所有记录都位于区间[0,max)上</span></span><br><span class="line">    <span class="keyword">int</span> *TempArray = <span class="keyword">new</span> Record[n];        <span class="comment">// 临时数组</span></span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[max];            <span class="comment">// 小于或等于i的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)                    <span class="comment">// 把序列复制到临时数组</span></span><br><span class="line">        TempArray[i] = Array[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++)                <span class="comment">// 所有计数器初始都为0</span></span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)                    <span class="comment">// 统计每个取值出现的次数</span></span><br><span class="line">        count[Array[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; max; i++)                <span class="comment">// 统计小于等于i的元素个数</span></span><br><span class="line">        count[i] = count[i - <span class="number">1</span>] + count[i];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)                <span class="comment">// 从尾部开始按顺序输出有序序列，保证排序的稳定性</span></span><br><span class="line">        Array[--count[TempArray[i]]] = TempArray[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    BucketSort(Array, n, <span class="number">80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RadixSort-h"><a href="#RadixSort-h" class="headerlink" title="RadixSort.h"></a>RadixSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> r)</span>  </span>&#123;</span><br><span class="line">	<span class="comment">//数组实现的基数排序，n为数组长度，d为排序码个数，r为基数</span></span><br><span class="line">	Record *TempArray =<span class="keyword">new</span> Record[n];		<span class="comment">// 辅助排序的临时数组</span></span><br><span class="line">	<span class="keyword">int</span>* count = <span class="keyword">new</span> <span class="keyword">int</span>[r];				<span class="comment">// 桶容量计数器，count[i] 存储了第i个桶中的记录数</span></span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	<span class="keyword">int</span> Radix = <span class="number">1</span>;							<span class="comment">// 模保持进位，用来取Array[j]的第i位排序码</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;d; i++)  &#123;					<span class="comment">// 分别对第i个排序码进行分配</span></span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;r; j++)					<span class="comment">// 初始计数器均为0</span></span><br><span class="line">			count[j] = <span class="number">0</span>;    </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)	 &#123;				<span class="comment">// 统计每个桶中的记录数</span></span><br><span class="line">			k = (Array[j] / Radix) % r;		<span class="comment">// 取Array[j]的第i位排序码</span></span><br><span class="line">			count[k]++;						<span class="comment">// 相应计数器加1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;r; j++)					<span class="comment">// 将TempArray中的位置依次分配给r个桶</span></span><br><span class="line">			count[j] = count[j<span class="number">-1</span>] + count[j];</span><br><span class="line">		<span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;			<span class="comment">// 从数字尾部，把记录收集到相应桶 </span></span><br><span class="line">			k = (Array[j] / Radix ) % r;	<span class="comment">// 取Array[j]的第i位排序码</span></span><br><span class="line">			count[k]--;						<span class="comment">// 使用了第k个桶的一个位置，桶剩余量的计数器减1</span></span><br><span class="line">			TempArray[count[k]] = Array[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)					<span class="comment">// 将临时数组中的内容复制到Array中</span></span><br><span class="line">			Array[j] = TempArray[j];         </span><br><span class="line">		Radix *= r;							<span class="comment">// 往左进一位，修改模Radix</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StaticQueue-RadixSort-h"><a href="#StaticQueue-RadixSort-h" class="headerlink" title="StaticQueue_RadixSort.h"></a>StaticQueue_RadixSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//基于静态链的基数排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结点类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Elem int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Elem key;    <span class="comment">//结点的关键码值</span></span><br><span class="line">    <span class="keyword">int</span> next;    <span class="comment">//下一个结点在数组中的下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态队列类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链实现的基数排序，n为数组长度，d为排序码个数，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(Record *Array, <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;                        <span class="comment">// first指向静态链中第一个记录</span></span><br><span class="line">    StaticQueue *<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span> = <span class="keyword">new</span> StaticQueue[r];            <span class="comment">// 存放r个桶的静态队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)            <span class="comment">// 建链，初始为next域指向下一个记录</span></span><br><span class="line">        Array[i].next = i + <span class="number">1</span>;</span><br><span class="line">    Array[n - <span class="number">1</span>].next = <span class="number">-1</span>;                <span class="comment">// 链尾next为空</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; d; i++) &#123;            <span class="comment">// 对第i个排序码进行分配和收集，一共d趟</span></span><br><span class="line">        Distribute(Array, first, i, r, <span class="built_in">queue</span>);</span><br><span class="line">        Collect(Array, first, r, <span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">queue</span>;</span><br><span class="line"><span class="comment">//    PrintArray(Array, first);</span></span><br><span class="line">    AddrSort(Array, n, first);            <span class="comment">// 线性时间整理静态链表，使得数组按下标有序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配过程,A中存放待排序记录，first为静态链中的第一个记录,i为第i个排序码，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Distribute</span><span class="params">(Record *Array, <span class="keyword">int</span> first, <span class="keyword">int</span> i, <span class="keyword">int</span> r, StaticQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r; j++)                <span class="comment">// 初始化r个队列</span></span><br><span class="line">        <span class="built_in">queue</span>[j].head = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="number">-1</span>) &#123;                <span class="comment">// 对整个静态链进行分配	   </span></span><br><span class="line">        <span class="keyword">int</span> k = Array[first].key;        <span class="comment">// 取第i位排序码数字k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; i; a++)</span><br><span class="line">            k = k / r;</span><br><span class="line">        k = k % r;</span><br><span class="line">        <span class="comment">// 把Array[first]分配到第k个子序列中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[k].head == <span class="number">-1</span>)        <span class="comment">// 如果子序列为空，Array[first]就是第一个记录</span></span><br><span class="line">            <span class="built_in">queue</span>[k].head = first;</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">// 否则加到子序列的尾部</span></span><br><span class="line">            Array[<span class="built_in">queue</span>[k].tail].next = first;</span><br><span class="line">        <span class="built_in">queue</span>[k].tail = first;            <span class="comment">// first为子序列的尾部</span></span><br><span class="line">        first = Array[first].next;        <span class="comment">// 继续分配下一个记录 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集过程，Array中存放待排序记录，first为静态链中的第一个记录，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span><span class="params">(Record *Array, <span class="keyword">int</span> &amp;first, <span class="keyword">int</span> r, StaticQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last, k = <span class="number">0</span>;                        <span class="comment">// 已收集到的最后一个记录</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">queue</span>[k].head == <span class="number">-1</span>)        <span class="comment">// 找到第一个非空队列</span></span><br><span class="line">        k++;</span><br><span class="line">    first = <span class="built_in">queue</span>[k].head;</span><br><span class="line">    last = <span class="built_in">queue</span>[k].tail;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; r - <span class="number">1</span>) &#123;                    <span class="comment">// 继续收集下一个非空队列，若k==r-1则已是最后一个	</span></span><br><span class="line">        <span class="comment">// 找下一个非空队列</span></span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; r - <span class="number">1</span> &amp;&amp; <span class="built_in">queue</span>[k].head == <span class="number">-1</span>)    <span class="comment">// 当前队列k为空，而且k还不是最后的队列r-1</span></span><br><span class="line">            k++;                    <span class="comment">// 试探下一个队列</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[k].head != <span class="number">-1</span>) &#123;        <span class="comment">// 将这个非空序列与上一个非空序列连接起来		</span></span><br><span class="line">            Array[last].next = <span class="built_in">queue</span>[k].head;</span><br><span class="line">            last = <span class="built_in">queue</span>[k].tail;        <span class="comment">// 此时最后一个记录为这个序列的尾部记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Array[last].next = <span class="number">-1</span>;                <span class="comment">// 收集完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddrSort</span><span class="params">(Record *Array, <span class="keyword">int</span> n, <span class="keyword">int</span> first)</span> </span>&#123;    <span class="comment">// 线性时间整理静态链表，使得数组按下标有序</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    j = first;                    <span class="comment">// j待处理数据下标，第一次为first</span></span><br><span class="line">    Record TempRec;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;            <span class="comment">// 循环n-1次，每次处理第i大记录</span></span><br><span class="line">        TempRec = Array[j];        <span class="comment">// 暂存第i大的纪录</span></span><br><span class="line">        Array[j] = Array[i];            <span class="comment">// 当前下标i的数据存放到j位置</span></span><br><span class="line">        Array[i] = TempRec;        <span class="comment">// 第i大记录入位</span></span><br><span class="line">        Array[i].next = j;            <span class="comment">// 第i大的记录的next链要保留调换轨迹j</span></span><br><span class="line">        j = TempRec.next;            <span class="comment">//  j移动到下一位</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= i)            <span class="comment">// 若j比当前下标i小，则是轨迹，顺链找到数据</span></span><br><span class="line">            j = Array[j].next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="IndexSort-h"><a href="#IndexSort-h" class="headerlink" title="IndexSort.h"></a>IndexSort.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array[]为待排序数组，IndexArray[]为索引数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexSort</span><span class="params">(Record Array[], <span class="keyword">int</span> IndexArray[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) IndexArray[i] = i;    <span class="comment">// 初始化索引下标</span></span><br><span class="line">    <span class="comment">// 简单插入排序的地址排序过程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)                <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--)                <span class="comment">// 依次比较，发现逆置就交换</span></span><br><span class="line">            <span class="keyword">if</span> (Array[IndexArray[j]] &lt; Array[IndexArray[j - <span class="number">1</span>]])</span><br><span class="line">                swap(IndexArray, j, j - <span class="number">1</span>);  <span class="comment">// 交换Array[IndexArray[j]]和Array[IndexArray[j-1]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;                <span class="comment">// 此时i前面记录已排序</span></span><br><span class="line">    AdjustRecord(Array, IndexArray, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据IndexArray整理Array，IndexArray[]为索引数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustRecord</span><span class="params">(Record Array[], <span class="keyword">int</span> IndexArray[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Record TempRec;                <span class="comment">// 只需要一个临时存储空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;            <span class="comment">// 循环n-1次，每次处理数组中第i个记录</span></span><br><span class="line">        <span class="keyword">int</span> j = i;                    <span class="comment">// j为临时变量，是循环链中的当前元素</span></span><br><span class="line">        TempRec = Array[i];            <span class="comment">// 暂存i下标中目前的纪录</span></span><br><span class="line">        <span class="keyword">while</span> (IndexArray[j] != i) &#123;    <span class="comment">// 如果循环链中索引下标还不是i，则顺链循环调整</span></span><br><span class="line">            <span class="keyword">int</span> k = IndexArray[j];        <span class="comment">// k为链接j指向的下标</span></span><br><span class="line">            Array[j] = Array[k];        <span class="comment">// 把k下标中的值复制到j位置，第j大元素正确归位</span></span><br><span class="line">            IndexArray[j] = j;        <span class="comment">// 因为是正确归位，索引j就是自身</span></span><br><span class="line">            j = k;                    <span class="comment">// j换到下一个，继续处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        Array[j] = TempRec;            <span class="comment">// 最后找到的j，它的索引下标值为i，因此第i大元素正确入位</span></span><br><span class="line">        IndexArray[j] = j;                <span class="comment">// 因为是正确归位，索引j就是自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九-文件管理和外排序"><a href="#九-文件管理和外排序" class="headerlink" title="九    文件管理和外排序"></a>九    文件管理和外排序</h2><h3 id="Buffer-h"><a href="#Buffer-h" class="headerlink" title="Buffer.h"></a>Buffer.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************  Buffer.h  *****************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE  100  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T *L;        <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> nLen;    <span class="comment">// 缓冲大小</span></span><br><span class="line">    <span class="keyword">int</span> nCurr;   <span class="comment">// 当前指针，初始化为0</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Buffer() &#123;</span><br><span class="line">        L = <span class="literal">NULL</span>;</span><br><span class="line">        nLen = <span class="number">0</span>;</span><br><span class="line">        nCurr = <span class="number">0</span>;</span><br><span class="line">    &#125;;  <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                             <span class="comment">//空否</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;                              <span class="comment">//满否</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T e)</span></span>;                            <span class="comment">//插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(FILE *fp)</span></span>;                       <span class="comment">//将缓冲区写回到文件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Buffer&lt;T&gt;::isEmpty() &#123;  <span class="comment">//空否</span></span><br><span class="line">    <span class="keyword">if</span> (nCurr == nLen)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Buffer&lt;T&gt;::isFull() &#123;   <span class="comment">//满否</span></span><br><span class="line">    <span class="keyword">if</span> (nLen == BUFFER_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::insert(T e) &#123;  <span class="comment">//插入数据</span></span><br><span class="line">    <span class="keyword">if</span> (nLen &lt; BUFFER_SIZE)</span><br><span class="line">        L[nLen++] = e;</span><br><span class="line"><span class="comment">// 	cout&lt;&lt;&quot;buffer insert!&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::read(T &amp;e) &#123;     <span class="comment">//读出数据</span></span><br><span class="line">    e = L[nCurr++];</span><br><span class="line"><span class="comment">//	cout&lt;&lt; &quot;Buffer read out.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::flush(FILE *fp) &#123;  <span class="comment">//将缓冲区写回到文件</span></span><br><span class="line">    fwrite(L, <span class="keyword">sizeof</span>(T), nLen, fp);</span><br><span class="line">    nLen = <span class="number">0</span>;</span><br><span class="line">    nCurr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillBuffer</span><span class="params">(FILE *fp, Buffer&lt;T&gt; b)</span> </span>&#123;    <span class="comment">//填充数据</span></span><br><span class="line">    b.nLen = fread(b.L, <span class="keyword">sizeof</span>(T), BUFFER_SIZE, fp);</span><br><span class="line">    b.nCurr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ReplacementSelection-cpp"><a href="#ReplacementSelection-cpp" class="headerlink" title="ReplacementSelection.cpp"></a>ReplacementSelection.cpp</h3><p><a herf="MinHeap.h">#include “MinHeap.h”</a></p>
<p><a herf="Buffer.h">#include “Buffer.h”</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX   7  <span class="comment">// 堆大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************  file operation ****************//</span></span><br><span class="line"><span class="comment">// 函数功能：初始化文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initFiles</span><span class="params">(FILE *&amp;inputFile, FILE *&amp;outputFile, <span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">const</span> <span class="keyword">char</span> *out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((inputFile = fopen(in, <span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open file!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((outputFile = fopen(out, <span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open file!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化堆里的数据，从磁盘文件读n个数据置入数组A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMinHeapArry</span><span class="params">(FILE *inputFile, <span class="keyword">int</span> n, T *A)</span> </span>&#123;</span><br><span class="line">    fread(A, <span class="keyword">sizeof</span>(BYTE), n, inputFile);</span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;file read!!!&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化input buffer, 读入一部分数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;input, FILE *inputFile)</span> </span>&#123;</span><br><span class="line">    input.L = (BYTE *) <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(input.L, <span class="literal">NULL</span>, BUFFER_SIZE);</span><br><span class="line">    input.nLen = fread(input.L, <span class="keyword">sizeof</span>(BYTE), BUFFER_SIZE, inputFile);</span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;InputBuffer initialised!!&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initOutputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;output)</span> </span>&#123;</span><br><span class="line">    output.L = (BYTE *) <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：把mval输出到输出缓冲区，同时出来因缓冲区空或者满的情况</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendToOutputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;input, Buffer&lt;T&gt; &amp;output, FILE *inputFile, FILE *outputFile, T mval)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出缓冲区满，写文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output.isFull()) &#123;</span><br><span class="line">        output.flush(outputFile); <span class="comment">// 不满，写缓冲</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;out buffer is full.&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output.insert(mval);         <span class="comment">// 输入缓冲区空，读文件到缓冲</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;output.insert(mval)&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span> (input.isEmpty() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!feof(inputFile)) &#123;</span><br><span class="line">            <span class="comment">// 文件没有结束</span></span><br><span class="line">            fillBuffer(inputFile, input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：比较大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less</span><span class="params">(T r, T mval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; mval)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：算法结束，处理输入输出缓冲区</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endUp</span><span class="params">(Buffer&lt;T&gt; output, FILE *inputFile, FILE *outputFile)</span> </span>&#123;</span><br><span class="line">    fwrite(output.L, <span class="keyword">sizeof</span>(BYTE), output.nLen, outputFile);</span><br><span class="line">    fclose(inputFile);</span><br><span class="line">    fclose(outputFile);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;output file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replacementSelection</span><span class="params">(T *A, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">const</span> <span class="keyword">char</span> *out)</span> </span>&#123;</span><br><span class="line">    T mval;  <span class="comment">//存放最小值堆的最小值</span></span><br><span class="line">    T r;     <span class="comment">//存放从输入缓冲区中读入的元素	</span></span><br><span class="line">    FILE *inputFile;                   <span class="comment">//输入文件句柄</span></span><br><span class="line">    FILE *outputFile;                  <span class="comment">//输出文件句柄	</span></span><br><span class="line">    Buffer&lt;T&gt; input;                   <span class="comment">//输入buffer</span></span><br><span class="line">    Buffer&lt;T&gt; output;                  <span class="comment">//输出buffer	</span></span><br><span class="line"></span><br><span class="line">    initFiles(inputFile, outputFile, in, out);  <span class="comment">//初始化输入输出文件</span></span><br><span class="line">    <span class="comment">//初始化堆的数据，从磁盘文件读入n个数据置入数组A</span></span><br><span class="line">    initMinHeapArry(inputFile, n, A);  <span class="comment">//从磁盘文件读入n个数据到堆数组A</span></span><br><span class="line">    <span class="function">MinHeap&lt;T&gt; <span class="title">H</span><span class="params">(A, n)</span></span>;          <span class="comment">//建立最小值堆</span></span><br><span class="line">    initInputBuffer(input, inputFile);    <span class="comment">//初始化input buffer，读入一部分数据</span></span><br><span class="line">    initOutputBuffer(output);      <span class="comment">//初始化Output buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> last = (n - <span class="number">1</span>); last &gt;= <span class="number">0</span>;) &#123;   <span class="comment">//堆不为空，就做这个循环</span></span><br><span class="line">        mval = H.heapArray[<span class="number">0</span>];       <span class="comment">//堆的最小值</span></span><br><span class="line">        <span class="comment">//mval = H.RemoveMin();</span></span><br><span class="line">        <span class="comment">//把mval送到输出缓冲区，同时处理因缓冲区空或满造成的各种情形</span></span><br><span class="line"></span><br><span class="line">        sendToOutputBuffer(input, output, inputFile, outputFile, mval);</span><br><span class="line"></span><br><span class="line">        input.read(r);  <span class="comment">//从输入缓冲区读入一个记录</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!less(r, mval)) &#123;    <span class="comment">// r值大于等于刚输出值，r入堆根</span></span><br><span class="line">            H.heapArray[<span class="number">0</span>] = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// r不能入堆，暂存待处理</span></span><br><span class="line">            H.heapArray[<span class="number">0</span>] = H.heapArray[last];  <span class="comment">// 用last位置的记录代替根结点</span></span><br><span class="line">            H.heapArray[last] = r;                <span class="comment">// 把r放到last位置</span></span><br><span class="line">            H.setSize(last);                    <span class="comment">// 堆规模缩小1</span></span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="number">0</span>) &#123;       <span class="comment">//重新排列堆</span></span><br><span class="line">            H.SiftDown(<span class="number">0</span>);  <span class="comment">//把根结点记录下降到合适的位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//endfor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法结束工作：处理输出缓冲区，输入/输出文件</span></span><br><span class="line">    endUp(output, inputFile, outputFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> in[] = <span class="string">&quot;file_in.txt&quot;</span>;   <span class="comment">// 输入文件名称</span></span><br><span class="line">    <span class="keyword">char</span> out[] = <span class="string">&quot;file_out.txt&quot;</span>; <span class="comment">// 输出文件名称</span></span><br><span class="line">    <span class="keyword">int</span> n = MAX; <span class="comment">// 数组元素个数，即内存数目 </span></span><br><span class="line">    BYTE *A = <span class="keyword">new</span> BYTE[MAX];</span><br><span class="line">    replacementSelection(A, n, in, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WinnerTree-h"><a href="#WinnerTree-h" class="headerlink" title="WinnerTree.h"></a>WinnerTree.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//****************   WinnerTree.h   *****************//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 8        <span class="comment">//选手数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WinnerTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WinnerTree(<span class="keyword">int</span> TreeSize = MAX);</span><br><span class="line"></span><br><span class="line">    ~WinnerTree() &#123; <span class="keyword">delete</span>[] B; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;  <span class="comment">//初始化赢者树</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (n) ? B[<span class="number">1</span>] : <span class="number">0</span>; &#125;     <span class="comment">////返回最终胜者的索引，在赢者树中这个索引放在B[1]中</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (i &lt; n) ? B[i] : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RePlay</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>; <span class="comment">//位置i的外部选手改变后重构赢者树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Play</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> MaxSize;     <span class="comment">//允许的最大选手数</span></span><br><span class="line">    <span class="keyword">int</span> n;             <span class="comment">//当前选手数</span></span><br><span class="line">    <span class="keyword">int</span> LowExt;         <span class="comment">//最底层外部结点数</span></span><br><span class="line">    <span class="keyword">int</span> offset;         <span class="comment">//最底层外部结点之上的结点总数</span></span><br><span class="line">    <span class="keyword">int</span> *B;          <span class="comment">//赢者树数组，实际存放的是下标</span></span><br><span class="line">    T *L;            <span class="comment">//元素数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">WinnerTree&lt;T&gt;::WinnerTree(<span class="keyword">int</span> TreeSize) &#123;</span><br><span class="line">    MaxSize = TreeSize;</span><br><span class="line">    B = <span class="keyword">new</span> <span class="keyword">int</span>[MaxSize];</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化赢者树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Initialize(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MaxSize || size &lt; <span class="number">2</span>)   <span class="comment">//能否处理size个选手的数组A[]</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    n = size;                   <span class="comment">//初始化成员变量</span></span><br><span class="line">    L = A;</span><br><span class="line">    <span class="keyword">int</span> i, s;</span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">1</span>; <span class="number">2</span> * s &lt;= n - <span class="number">1</span>; s += s);  <span class="comment">//计算 s = 2^log(n-1)</span></span><br><span class="line">    LowExt = <span class="number">2</span> * (n - s);</span><br><span class="line">    offset = <span class="number">2</span> * s - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= LowExt; i += <span class="number">2</span>)     <span class="comment">//最底层外部结点的比赛</span></span><br><span class="line">        Play((offset + i) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner);</span><br><span class="line"><span class="comment">//处理其余外部结点</span></span><br><span class="line"><span class="comment">//若n为奇数，内部结点和外部结点比赛。这里用L[LowExt+1]和它的父结点比赛</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">        Play(n / <span class="number">2</span>, B[n - <span class="number">1</span>], LowExt + <span class="number">1</span>, winner);</span><br><span class="line">        i = LowExt + <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        i = LowExt + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="number">2</span>)        <span class="comment">//剩余外部结点的比赛</span></span><br><span class="line">        Play((i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从内部结点B[p]处开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Play(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    B[p] = winner(L, lc, rc);        <span class="comment">//胜者索引放在B[p]中</span></span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; p % <span class="number">2</span>) &#123;     <span class="comment">//右孩子，需要沿路径继续向上比赛</span></span><br><span class="line">        B[p / <span class="number">2</span>] = winner(L, B[p - <span class="number">1</span>], B[p]);</span><br><span class="line">        p /= <span class="number">2</span>;  <span class="comment">//父结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数RePlay负责选手i的值改变后重新开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::RePlay(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p, lc, rc;        <span class="comment">//比赛结点极其左右孩子的下标</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= LowExt) &#123;        <span class="comment">//从最底层开始</span></span><br><span class="line">        p = (offset + i) / <span class="number">2</span>;</span><br><span class="line">        lc = <span class="number">2</span> * p - offset; <span class="comment">// left child of p</span></span><br><span class="line">        rc = lc + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * p == n - <span class="number">1</span>) &#123;</span><br><span class="line">            lc = B[<span class="number">2</span> * p];</span><br><span class="line">            rc = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="number">2</span> * p - n + <span class="number">1</span> + LowExt;</span><br><span class="line">            rc = lc + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B[p] = winner(L, lc, rc);     <span class="comment">//B[p]中保存赢者的索引</span></span><br><span class="line">    <span class="comment">//完成剩下的比赛</span></span><br><span class="line">    p /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &gt;= <span class="number">1</span>; p /= <span class="number">2</span>)       <span class="comment">//沿路径向上比赛</span></span><br><span class="line">        B[p] = winner(L, B[<span class="number">2</span> * p], B[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Output() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前选手数(size) = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 最底层外部结点数(LowExt) = &quot;</span> &lt;&lt; LowExt</span><br><span class="line">         &lt;&lt; <span class="string">&quot; 最底层外部结点之上的结点总数(Offset) = &quot;</span> &lt;&lt; offset &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;赢者树B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回赢者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A[b] &lt;= A[c])</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LooserTree-h"><a href="#LooserTree-h" class="headerlink" title="LooserTree.h"></a>LooserTree.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************   LooserTree.h   ***************//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：返回赢者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[b] &lt;= A[c] ? b : c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：返回败者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loser</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[b] &gt; A[c] ? b : c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoserTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LoserTree(<span class="keyword">int</span> Treesize);</span><br><span class="line"></span><br><span class="line">    ~LoserTree() &#123; <span class="keyword">delete</span>[] B; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RePlay</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Play</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部结点从右分支向上比赛</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize; <span class="comment">// 最大选手数</span></span><br><span class="line">    <span class="keyword">int</span> n;   <span class="comment">// 当前选手数</span></span><br><span class="line">    <span class="keyword">int</span> LowExt;  <span class="comment">// 最底层外部结点数 lowest-level external nodes</span></span><br><span class="line">    <span class="keyword">int</span> offset;  <span class="comment">// 最底层外部结点之上的结点数 2^k - 1</span></span><br><span class="line">    <span class="keyword">int</span> *B;   <span class="comment">// 赢者数数组 array for winner tree</span></span><br><span class="line">    T *L;   <span class="comment">// 选手数组 element array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">LoserTree&lt;T&gt;::LoserTree(<span class="keyword">int</span> TreeSize) &#123;</span><br><span class="line">    MaxSize = TreeSize;</span><br><span class="line">    B = <span class="keyword">new</span> <span class="keyword">int</span>[MaxSize];</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Winner，返回最终胜者的索引，在败者树中这个索引存放在B[0]中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> LoserTree&lt;T&gt;::Winner() &#123;  <span class="comment">// 返回最终胜者的索引B[0]</span></span><br><span class="line">    <span class="keyword">return</span> (n) ? B[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Initilalize负责初始化败者树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Initialize(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                              <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;<span class="comment">// 初始化败者树</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MaxSize || size &lt; <span class="number">2</span>) &#123;        <span class="comment">//能否处理size个选手的数组a[]</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bad Input!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = size;                    <span class="comment">//初始化成员变量</span></span><br><span class="line">    L = A;</span><br><span class="line">    <span class="keyword">int</span> i, s;</span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">1</span>; <span class="number">2</span> * s &lt;= n - <span class="number">1</span>; s += s);    <span class="comment">//计算s = 2^log(n-1)</span></span><br><span class="line">    LowExt = <span class="number">2</span> * (n - s);</span><br><span class="line">    offset = <span class="number">2</span> * s - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最底层外部结点的比赛</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= LowExt; i += <span class="number">2</span>)     <span class="comment">// 最底层外部结点的比赛</span></span><br><span class="line">        Play((offset + i) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner, loser);</span><br><span class="line">    <span class="comment">//处理其余外部结点</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;           <span class="comment">// n为奇数，内部结点和外部结点比一次</span></span><br><span class="line">        Play(n / <span class="number">2</span>, B[(n - <span class="number">1</span>) / <span class="number">2</span>], LowExt + <span class="number">1</span>, winner, loser);<span class="comment">//暂存在父结点的左胜者与外部右子结点比</span></span><br><span class="line">        i = LowExt + <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        i = LowExt + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="number">2</span>)   <span class="comment">// 剩余外部结点的比赛</span></span><br><span class="line">        Play((i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner, loser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Play负责在内部结点B[p]处开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Play(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[],</span><br><span class="line">                                                            <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                        <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;  <span class="comment">// 在内部结点从右分支向上比赛</span></span><br><span class="line">    B[p] = loser(L, lc, rc);       <span class="comment">//败者索引放在B[p]中			</span></span><br><span class="line">    <span class="keyword">int</span> temp1, temp2;</span><br><span class="line">    temp1 = winner(L, lc, rc);    <span class="comment">//p处的胜者索引</span></span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; p % <span class="number">2</span>) &#123;       <span class="comment">// p为奇数右孩子，沿路径继续向上比赛</span></span><br><span class="line">        temp2 = winner(L, temp1, B[p / <span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//p的胜者和p的父结点比较，赢者暂存在temp2中</span></span><br><span class="line">        B[p / <span class="number">2</span>] = loser(L, temp1, B[p / <span class="number">2</span>]);                <span class="comment">//败者索引放入B[p/2]</span></span><br><span class="line">        temp1 = temp2;         <span class="comment">// 胜者放入temp1</span></span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    B[p / <span class="number">2</span>] = temp1;             <span class="comment">// B[p]是左孩子或者p=1，结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数RePlay负责选手i的值改变后重新开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::RePlay(<span class="keyword">int</span> i, <span class="keyword">int</span> (*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                          <span class="keyword">int</span> (*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;  <span class="comment">// 选手i的值改变后，重新开始比赛</span></span><br><span class="line">    <span class="keyword">int</span> p;               <span class="comment">// 用于计算父结点索引的临时变量</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Out of Bounds!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确定父结点的位置</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= LowExt)</span><br><span class="line">        p = (i + offset) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p = (i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    B[<span class="number">0</span>] = winner(L, i, B[p]);         <span class="comment">//B[0]中始终保存胜者的索引</span></span><br><span class="line">    B[p] = loser(L, i, B[p]);          <span class="comment">//B[p]中保存败者的索引</span></span><br><span class="line">    <span class="keyword">for</span> (; (p / <span class="number">2</span>) &gt;= <span class="number">1</span>; p /= <span class="number">2</span>) &#123;          <span class="comment">//沿路径向上比赛</span></span><br><span class="line">        <span class="keyword">int</span> temp;<span class="comment">//临时存放赢者的索引</span></span><br><span class="line">        temp = winner(L, B[p / <span class="number">2</span>], B[<span class="number">0</span>]);</span><br><span class="line">        B[p / <span class="number">2</span>] = loser(L, B[p / <span class="number">2</span>], B[<span class="number">0</span>]);</span><br><span class="line">        B[<span class="number">0</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Output() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前选手数(size) = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 最底层外部结点数(LowExt) = &quot;</span> &lt;&lt; LowExt</span><br><span class="line">         &lt;&lt; <span class="string">&quot; 最底层外部结点之上的结点总数(Offset) = &quot;</span> &lt;&lt; offset &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;败者树B（B0存放胜者下标）: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十-检索"><a href="#十-检索" class="headerlink" title="十    检索"></a>十    检索</h2><h3 id="Search-cpp"><a href="#Search-cpp" class="headerlink" title="Search.cpp"></a>Search.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Item(Type value) : key(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;         <span class="comment">//获取关键码值;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(Type k)</span> </span>&#123;</span><br><span class="line">        key = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type key;                           <span class="comment">//关键码域</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//其它域;                              //其它域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = length;</span><br><span class="line">    datavector[<span class="number">0</span>]-&gt;setKey(k);        <span class="comment">//将第0个元素设为待检索值</span></span><br><span class="line">    <span class="keyword">while</span> (datavector[i]-&gt;getKey() != k)</span><br><span class="line">        i--;     <span class="comment">//从后往前逐个比较</span></span><br><span class="line">    <span class="keyword">return</span> i;           <span class="comment">//返回元素位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SimpleSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (datavector[i]-&gt;getKey() != k &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">        i--;     <span class="comment">//从后往前逐个比较</span></span><br><span class="line">    <span class="keyword">return</span> i;           <span class="comment">//返回元素位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = length, mid;   <span class="comment">//low, high分别记录数组首尾位置</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; datavector[mid]-&gt;getKey())</span><br><span class="line">            high = mid - <span class="number">1</span>;               <span class="comment">//右缩检索区间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; datavector[mid]-&gt;getKey())</span><br><span class="line">            low = mid + <span class="number">1</span>;           <span class="comment">//左缩检索区间</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;                            <span class="comment">//检索成功，返回元素位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                 <span class="comment">//检索失败，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间变量与时间函数</span></span><br><span class="line"><span class="keyword">clock_t</span> tstart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Settime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tstart = clock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Gettime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) ((<span class="keyword">double</span>) clock() - (<span class="keyword">double</span>) tstart) / (<span class="keyword">double</span>) CLOCKS_PER_SEC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt; Item&lt;<span class="keyword">int</span>&gt; * &gt; datavector(<span class="number">200001</span>);</span><br><span class="line"></span><br><span class="line">    Item&lt;<span class="keyword">int</span>&gt; *darray[<span class="number">200001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200001</span>; j++)</span><br><span class="line">        darray[j] = <span class="keyword">new</span> Item&lt;<span class="keyword">int</span>&gt;(j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Item&lt;<span class="keyword">int</span>&gt; *&gt;::iterator outputIterator = datavector.begin();</span><br><span class="line">    copy(darray, darray + <span class="number">200001</span>, outputIterator);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Settime();<span class="comment">//开始计时</span></span><br><span class="line">    k = SeqSearch(datavector, datavector.size() - <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&gt;监视哨顺序检索耗时 : &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Gettime() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Settime();<span class="comment">//开始计时</span></span><br><span class="line">    k = SimpleSearch(datavector, datavector.size() - <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&gt;一般顺序检索耗时 : &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Gettime() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<h3 id="BitSet-cpp"><a href="#BitSet-cpp" class="headerlink" title="BitSet.cpp"></a>BitSet.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySet</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ulong;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        NB = <span class="number">8</span> * <span class="keyword">sizeof</span>(ulong),            <span class="comment">//unsigned long数据类型的位的数目</span></span><br><span class="line">        LI = N == <span class="number">0</span> ? <span class="number">0</span> : (N - <span class="number">1</span>) / NB        <span class="comment">//数组最后一个元素的下标</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ulong A[LI + <span class="number">1</span>];                        <span class="comment">//存放位向量的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tidy</span><span class="params">(ulong X = <span class="number">0</span>)</span></span>;                    <span class="comment">//将数组中的每个元素设成X</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trim</span><span class="params">()</span></span>;                            <span class="comment">//将不使用的位设成0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mySet();                                <span class="comment">//构造函数</span></span><br><span class="line">    mySet(ulong X);</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">set</span><span class="params">()</span></span>;                        <span class="comment">//设置元素属性</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">set</span><span class="params">(<span class="keyword">size_t</span> P, <span class="keyword">bool</span> X = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">reset</span><span class="params">()</span></span>;                        <span class="comment">//把集合设为空</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">reset</span><span class="params">(<span class="keyword">size_t</span> P)</span></span>;                <span class="comment">//删除元素P</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">at</span><span class="params">(<span class="keyword">size_t</span> P)</span> <span class="keyword">const</span></span>;                <span class="comment">//属于运算</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> P) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">flip</span><span class="params">()</span></span>;                        <span class="comment">//求反</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">flip</span><span class="params">(<span class="keyword">size_t</span> P)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ulong <span class="title">to_ulong</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;                    <span class="comment">//计算集合内元素数目</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">size_t</span> P)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span> <span class="keyword">const</span></span>;                        <span class="comment">//判断集合是否包含元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">none</span><span class="params">()</span> <span class="keyword">const</span></span>;                        <span class="comment">//判断集合是否为空</span></span><br><span class="line"></span><br><span class="line">    mySet&lt;N&gt; <span class="keyword">operator</span>~() <span class="keyword">const</span>;                    <span class="comment">//非运算</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//交等于</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>|=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//并等于</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>^=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//异或等于</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//等于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//不等</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//包含于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//真包含于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//包含</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//真包含</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//交运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) &amp;= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>|(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//并运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) |= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//差运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) &amp; ~R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>^(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//异或运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) ^= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;O, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;        <span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> P = <span class="number">0</span>; P &lt; N; P++)</span><br><span class="line">            O &lt;&lt; (R.test(P) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (O);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> mySet&lt;N&gt;::Tidy(ulong X) &#123;   <span class="comment">//将数组中的每个元素设成X</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] = X;</span><br><span class="line">    <span class="keyword">if</span> (X != <span class="number">0</span>)</span><br><span class="line">        Trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> mySet&lt;N&gt;::Trim() &#123;            <span class="comment">//将不使用的位设成0</span></span><br><span class="line">    <span class="keyword">if</span> (N % NB != <span class="number">0</span>)</span><br><span class="line">        A[LI] &amp;= ((ulong) <span class="number">1</span> &lt;&lt; N % NB) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt;::mySet() &#123;                <span class="comment">//构造函数</span></span><br><span class="line">    Tidy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt;::mySet(ulong X) &#123;</span><br><span class="line">    Tidy();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> P = <span class="number">0</span>; X != <span class="number">0</span> &amp;&amp; P &lt; N; X &gt;&gt;= <span class="number">1</span>, ++P)</span><br><span class="line">        <span class="keyword">if</span> (X &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">set</span>(P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="built_in">set</span>() &#123;        <span class="comment">//设置元素属性</span></span><br><span class="line">    Tidy(~(ulong) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;size_t N&gt;	mySet&lt;N&gt;&amp; mySet&lt;N&gt;::set(size_t P)&#123;</span></span><br><span class="line"><span class="comment">	A[P / NB] |= (ulong)1 &lt;&lt; P % NB;</span></span><br><span class="line"><span class="comment">	return (*this); </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="built_in">set</span>(<span class="keyword">size_t</span> P, <span class="keyword">bool</span> X) &#123;</span><br><span class="line">    <span class="keyword">if</span> (X)                                    <span class="comment">// X为真，位向量中相应值设为1</span></span><br><span class="line">        A[P / NB] |= (ulong) <span class="number">1</span> &lt;&lt; (P % NB);        <span class="comment">// P对应的元素进行按位或运算</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A[P / NB] &amp;= ~((ulong) <span class="number">1</span> &lt;&lt; (P % NB));    <span class="comment">// X为假，位向量中相应值设为0</span></span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::reset() &#123;                <span class="comment">//把集合设置为空</span></span><br><span class="line">    Tidy();</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::reset(<span class="keyword">size_t</span> P) &#123;        <span class="comment">//把具体元素设置为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(P, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::at(<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;        <span class="comment">//属于运算</span></span><br><span class="line">    <span class="keyword">return</span> (test(P));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (test(P));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::flip() &#123;                <span class="comment">//求非运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] = ~A[I];</span><br><span class="line">    Trim();</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::flip(<span class="keyword">size_t</span> P) &#123;      <span class="comment">// 取反</span></span><br><span class="line">    A[P / NB] ^= (ulong) <span class="number">1</span> &lt;&lt; P % NB;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mySet&lt;N&gt;::to_ulong() <span class="keyword">const</span> &#123; <span class="comment">// 转换为ulong类型</span></span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mySet&lt;N&gt;::to_string() <span class="keyword">const</span> &#123;   <span class="comment">// 用0，1形式把集合内容输出到字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> S;</span><br><span class="line">    S.reserve(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> P = N; <span class="number">0</span> &lt; P;)</span><br><span class="line">        S += test(--P) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> (S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">size_t</span> mySet&lt;N&gt;::count() <span class="keyword">const</span> &#123;      <span class="comment">//计算集合元素数目</span></span><br><span class="line">    <span class="keyword">size_t</span> V = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">for</span> (ulong X = A[I]; X != <span class="number">0</span>; X &gt;&gt;= <span class="number">4</span>)</span><br><span class="line">            V += <span class="string">&quot;\0\1\1\2\1\2\2\3&quot;</span>                        <span class="comment">//&quot;\0\1\1\2\1\2\2\3\1\2\2\3\2\3\3\4&quot;代表十六进制数0-F所包含1的数目的数组</span></span><br><span class="line">                 <span class="string">&quot;\1\2\2\3\2\3\3\4&quot;</span>[X &amp; <span class="number">0xF</span>];</span><br><span class="line">    <span class="keyword">return</span> (V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">size_t</span> mySet&lt;N&gt;::size() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::test(<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((A[P / NB] &amp; ((ulong) <span class="number">1</span> &lt;&lt; P % NB)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::any() <span class="keyword">const</span> &#123;           <span class="comment">//判断集合是否包含元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">if</span> (A[I] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::none() <span class="keyword">const</span> &#123;          <span class="comment">//判断集合是否为空</span></span><br><span class="line">    <span class="keyword">return</span> (!any());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; mySet&lt;N&gt;::<span class="keyword">operator</span>~() <span class="keyword">const</span> &#123;    <span class="comment">//非运算</span></span><br><span class="line">    <span class="keyword">return</span> (mySet&lt;N&gt;(*<span class="keyword">this</span>).flip());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123; <span class="comment">//赋值交</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)            <span class="comment">// 从低位到高位</span></span><br><span class="line">        A[I] &amp;= R.A[I];                        <span class="comment">// 以ulong元素为单位按位交</span></span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>|=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123; <span class="comment">//并等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] |= R.A[I];</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>^=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//异或等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] ^= R.A[I];</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>==(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">if</span> (A[I] != R.A[I])</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>!=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//不等运算</span></span><br><span class="line">    <span class="keyword">return</span> (!(*<span class="keyword">this</span> == R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//包含于运算</span></span><br><span class="line">    <span class="keyword">return</span> ((mySet(*<span class="keyword">this</span>) |= R) == R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;   <span class="comment">//真包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((*<span class="keyword">this</span> &lt;= R) &amp;&amp; (*<span class="keyword">this</span> != R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((mySet(*<span class="keyword">this</span>) &amp;= R) == R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;   <span class="comment">//真包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((*<span class="keyword">this</span> &gt;= R) &amp;&amp; (*<span class="keyword">this</span> != R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  &amp;运算只是friend, LI属于未定义</span></span><br><span class="line"><span class="comment">template&lt;size_t N&gt;	 mySet&lt;N&gt; operator&amp;( const mySet&lt;N&gt;&amp; L,  const mySet&lt;N&gt;&amp; R) &#123;//交运算</span></span><br><span class="line"><span class="comment">	mySet&lt;N&gt; s = L;</span></span><br><span class="line"><span class="comment">	for (int I = LI; I &gt;= 0; I--)</span></span><br><span class="line"><span class="comment">		s.A[I] &amp;= R.A[I];</span></span><br><span class="line"><span class="comment">	return s; 	</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="hashtomb-h"><a href="#hashtomb-h" class="headerlink" title="hashtomb.h"></a>hashtomb.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashdict</span> </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Elem* HT;     <span class="comment">// 散列表</span></span><br><span class="line">  <span class="keyword">int</span> M;       <span class="comment">// 散列表大小</span></span><br><span class="line">   Elem TOMB;    <span class="comment">//墓碑</span></span><br><span class="line">  <span class="keyword">int</span> currcnt;  <span class="comment">// 现有元素数目</span></span><br><span class="line">  Elem EMPTY;  <span class="comment">// 空槽</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(Key K, <span class="keyword">int</span> i)</span> <span class="keyword">const</span> <span class="comment">// 探查函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> linear(i); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x % M; &#125; <span class="comment">// 散列函数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">char</span>* x)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 字符串散列函数</span></span><br><span class="line">    <span class="keyword">int</span> i, sum;</span><br><span class="line">    <span class="keyword">for</span> (sum=<span class="number">0</span>, i=<span class="number">0</span>; x[i] != <span class="string">&#x27;\0&#x27;</span>; i++) sum += (<span class="keyword">int</span>) x[i];</span><br><span class="line">    <span class="keyword">return</span>(sum % M);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">linear</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> i;&#125;        <span class="comment">//线性探查</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;                  <span class="comment">//二次探查</span></span><br><span class="line">	  <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> -(i*i/<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">else</span>       <span class="keyword">return</span> (i+<span class="number">1</span>)*(i+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">rehash</span> <span class="params">(Key K, <span class="keyword">int</span> i)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> x )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  x % M; &#125;  <span class="comment">//除余法</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ELFhash</span> <span class="params">( <span class="keyword">char</span>*  key )</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">			  <span class="keyword">while</span>(*key) &#123; </span><br><span class="line">                      h = ( h &lt;&lt; <span class="number">4</span> ) + *key++;</span><br><span class="line">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> g = h&amp;<span class="number">0xF0000000</span>L;</span><br><span class="line">                      <span class="keyword">if</span> (g) h^= g &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                      h  = ~g;</span><br><span class="line">                        &#125;</span><br><span class="line">                  <span class="keyword">return</span> h % M;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   hashdict(<span class="keyword">int</span> sz, Elem e, Elem t)&#123;<span class="comment">// 构造函数, e用来定义空槽</span></span><br><span class="line">          M=sz; EMPTY= e; TOMB=t;</span><br><span class="line">          currcnt=<span class="number">0</span>; HT=<span class="keyword">new</span> Elem[sz];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++) HT[i]= EMPTY; </span><br><span class="line">&#125;</span><br><span class="line">  ~hashdict() &#123; <span class="keyword">delete</span> HT; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hashInsert</span><span class="params">(<span class="keyword">const</span> Elem&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hashSearch</span><span class="params">(<span class="keyword">const</span> Key&amp;, Elem&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Elem <span class="title">hashDelete</span><span class="params">(<span class="keyword">const</span> Key&amp; K)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> currcnt; &#125; <span class="comment">// 散列表中现有元素数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="hashtomb-cpp"><a href="#hashtomb-cpp" class="headerlink" title="hashtomb.cpp"></a>hashtomb.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Int.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../COMPARE.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HASHDICT.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> hashdict&lt;Key, Elem, KEComp, EEComp&gt;::</span><br><span class="line">hashSearch(<span class="keyword">const</span> Key &amp;K, Elem &amp;e) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(K);            <span class="comment">// home 保存K的基地址</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;           <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KEComp::eq(K, HT[pos])) &#123;  <span class="comment">// 发现目标</span></span><br><span class="line">            e = HT[pos];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(K, i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据元素e插入到散列表 HT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> hashdict&lt;Key, Elem, KEComp, EEComp&gt;::hashInsert(<span class="keyword">const</span> Elem &amp;e) &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(getkey(e));        <span class="comment">// home记录基位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, insplace;</span><br><span class="line">    <span class="keyword">bool</span> tomb_pos = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;                <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (EEComp::eq(e, HT[pos]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不允许重复关键码</span></span><br><span class="line">        <span class="keyword">if</span> (EEComp::eq(TOMB, HT[pos]) &amp;&amp; !tomb_pos) &#123;</span><br><span class="line">            insplace = pos;                 <span class="comment">//记录第一个墓碑的位置   </span></span><br><span class="line">            tomb_pos = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(getkey(e), i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!tomb_pos)</span><br><span class="line">        insplace = pos;      <span class="comment">//如果没有墓碑，插入空位置</span></span><br><span class="line">    HT[insplace] = e;                  <span class="comment">//插入e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除算法：在检索函数的基础上进行了修改。</span></span><br><span class="line"><span class="comment">// 若检索失败，则无值可删；检索成功则将其设为墓碑。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line">Elem hashdict&lt;Key, Elem, KEComp, EEComp&gt;::hashDelete(<span class="keyword">const</span> Key &amp;K) &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(K);<span class="comment">// home记录基位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;        <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    Elem temp;</span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KEComp::eq(K, HT[pos])) &#123;</span><br><span class="line">            temp = HT[pos];</span><br><span class="line">            HT[pos] = TOMB; <span class="comment">//设置墓碑</span></span><br><span class="line">            <span class="keyword">return</span> temp;    <span class="comment">//返回目标</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(K, i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EMPTY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getkey</span><span class="params">(Int *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;key();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getkey</span><span class="params">(<span class="keyword">char</span> *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Intkey</span><span class="params">(Int &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e.key();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">charkey</span><span class="params">(<span class="keyword">char</span> *&amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    hashdict&lt;int, Int *, intIntsCompare, IntsIntsCompare&gt; dict(100, new Int(-1), new Int(-2));</span><br><span class="line">    Int *val;</span><br><span class="line"></span><br><span class="line">    dict.hashInsert(<span class="keyword">new</span> Int(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">if</span> (dict.hashSearch(<span class="number">10</span>, val))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;发现值 &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; 匹配关键码10\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有发现匹配关键码10的元素\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="十一-索引技术"><a href="#十一-索引技术" class="headerlink" title="十一    索引技术"></a>十一    索引技术</h2><h2 id="十二-高级数据结构"><a href="#十二-高级数据结构" class="headerlink" title="十二    高级数据结构"></a>十二    高级数据结构</h2><h3 id="SMatrix-h"><a href="#SMatrix-h" class="headerlink" title="SMatrix.h"></a>SMatrix.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用十字链表实现稀疏矩阵</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxtempl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> //(行、列、元素)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先定义节点类.T是节点存储的数据类型</span></span><br><span class="line"><span class="comment">//如果是头结点则不存储任何数值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;<span class="comment">//矩阵的行和列</span></span><br><span class="line">    T element;<span class="comment">//矩阵中存储的数据</span></span><br><span class="line">    OLNode&lt;T&gt; *right, *down;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OLNode() &#123;</span><br><span class="line">        right = <span class="literal">NULL</span>;</span><br><span class="line">        down = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏矩阵</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rownum, colnum;<span class="comment">//行列数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateMatrix</span><span class="params">(CArray &lt;Element, Element&gt; &amp;Data)</span></span>;<span class="comment">//only for local use</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OLNode&lt;T&gt; **rowhead, **colhead;<span class="comment">//矩阵的第一个非零元素</span></span><br><span class="line">    SMatrix();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MallocMem</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>; <span class="comment">//为矩阵收集内存</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetRownum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetColnum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateMatrix</span><span class="params">()</span></span>;<span class="comment">//建立矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FreeMem</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SMatrix&lt;<span class="keyword">int</span>&gt; *<span class="title">MatrixMutil</span><span class="params">(SMatrix&lt;<span class="keyword">int</span>&gt; *left, SMatrix&lt;<span class="keyword">int</span>&gt; *right)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SMatrix&lt;T&gt;::SMatrix() &#123;</span><br><span class="line">    rowhead = colhead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SMatrix&lt;T&gt;::GetRownum() &#123;</span><br><span class="line">    <span class="keyword">return</span> rownum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SMatrix&lt;T&gt;::GetColnum() &#123;</span><br><span class="line">    <span class="keyword">return</span> colnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::MallocMem(<span class="keyword">int</span> row, <span class="keyword">int</span> col) &#123;</span><br><span class="line">    rownum = row;</span><br><span class="line">    colnum = col;</span><br><span class="line">    rowhead = <span class="keyword">new</span> OLNode&lt;T&gt; *[row + <span class="number">1</span>];</span><br><span class="line">    colhead = <span class="keyword">new</span> OLNode&lt;T&gt; *[col + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt;= row; count++) &#123;<span class="comment">//初始化为头结点</span></span><br><span class="line">        rowhead[count] = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        rowhead[count]-&gt;row = <span class="number">-1</span>;</span><br><span class="line">        rowhead[count]-&gt;col = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt;= col; count++) &#123;</span><br><span class="line">        colhead[count] = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        colhead[count]-&gt;row = <span class="number">-1</span>;</span><br><span class="line">        colhead[count]-&gt;col = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::CreateMatrix() &#123;</span><br><span class="line">    <span class="comment">//首先</span></span><br><span class="line">    <span class="keyword">if</span> ((rowhead != <span class="literal">NULL</span>) || (colnum != <span class="literal">NULL</span>))</span><br><span class="line">        FreeMem();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入矩阵的行数:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; rownum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入矩阵的列数:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; colnum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//为行列指针收集空间</span></span><br><span class="line">    MallocMem(rownum, colnum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入矩阵的元素，格式&lt;行，列，数据&gt;+回车,结束输入请输入-1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    T ele;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ele;</span><br><span class="line">        <span class="keyword">if</span> ((i &gt; rownum) || (j &gt; colnum) || (i &lt; <span class="number">1</span>) || (j &lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不正确的行，列号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OLNode&lt;T&gt; *temp = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        temp-&gt;row = i;</span><br><span class="line">        temp-&gt;col = j;</span><br><span class="line">        temp-&gt;element = ele;</span><br><span class="line">        <span class="comment">//处理行指针</span></span><br><span class="line">        <span class="comment">//查找位置</span></span><br><span class="line">        OLNode&lt;T&gt; *t2 = rowhead[i];</span><br><span class="line">        OLNode&lt;T&gt; *t1 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (j &gt; t2-&gt;col)) &#123;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = t2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (t2-&gt;col == j)) &#123;<span class="comment">//修改值</span></span><br><span class="line">            t2-&gt;element = temp-&gt;element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入新的指针</span></span><br><span class="line">            t1-&gt;right = temp;</span><br><span class="line">            temp-&gt;right = t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理列指针</span></span><br><span class="line">        <span class="comment">//查找位置</span></span><br><span class="line">        t2 = colhead[j];</span><br><span class="line">        t1 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (i &gt; t2-&gt;row)) &#123;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = t2-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (t2-&gt;row == i)) &#123;<span class="comment">//修改值</span></span><br><span class="line">            t2-&gt;element = temp-&gt;element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;     <span class="comment">//插入新的指针</span></span><br><span class="line">            t1-&gt;down = temp;</span><br><span class="line">            temp-&gt;down = t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//end of while</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::PrintAll() &#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= rownum; i++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *temp = rowhead[i]-&gt;right;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= colnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;col == j)) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; temp-&gt;element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                temp = temp-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 0 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::FreeMem() &#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= rownum; i++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *temp = rowhead[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= colnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;col == j)) &#123;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> rowhead;</span><br><span class="line">    <span class="keyword">delete</span> colhead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SMatrix&lt;<span class="keyword">int</span>&gt; *SMatrix&lt;T&gt;::MatrixMutil(SMatrix&lt;<span class="keyword">int</span>&gt; *left, SMatrix&lt;<span class="keyword">int</span>&gt; *right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left-&gt;GetColnum() != right-&gt;GetRownum())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//行列不匹配不能相乘</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> I = <span class="number">0</span>; <span class="comment">//第一个矩阵的行数</span></span><br><span class="line">    <span class="keyword">int</span> J = <span class="number">0</span>; <span class="comment">//第二个矩阵的列数</span></span><br><span class="line">    SMatrix&lt;T&gt; *ResultMatrix = <span class="keyword">new</span> SMatrix&lt;T&gt;();</span><br><span class="line">    ResultMatrix-&gt;MallocMem(left-&gt;GetRownum(), right-&gt;GetColnum());</span><br><span class="line">    <span class="keyword">for</span> (I = <span class="number">1</span>; I &lt;= left-&gt;GetRownum(); I++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *RowNext = ResultMatrix-&gt;rowhead[I];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (J = <span class="number">1</span>; J &lt;= right-&gt;GetColnum(); J++) &#123;</span><br><span class="line">            OLNode&lt;T&gt; *ColNext = ResultMatrix-&gt;colhead[J];</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            OLNode&lt;<span class="keyword">int</span>&gt; *rows = left-&gt;rowhead[I]-&gt;right;</span><br><span class="line">            OLNode&lt;<span class="keyword">int</span>&gt; *cols = right-&gt;colhead[J]-&gt;down;</span><br><span class="line">            <span class="keyword">if</span> ((rows == <span class="literal">NULL</span>) || (cols == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//新行没有非零元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((rows != <span class="literal">NULL</span>) &amp;&amp; (cols != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows-&gt;col &lt; cols-&gt;row) &#123;</span><br><span class="line">                    rows = rows-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rows-&gt;col &gt; cols-&gt;row) &#123;</span><br><span class="line">                    cols = cols-&gt;down;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//都有元素可以相乘</span></span><br><span class="line">                    result = result + cols-&gt;element * rows-&gt;element;</span><br><span class="line">                    cols = cols-&gt;down;</span><br><span class="line">                    rows = rows-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//插入到结果矩阵中</span></span><br><span class="line">            OLNode&lt;T&gt; *temp = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">            temp-&gt;row = I;</span><br><span class="line">            temp-&gt;col = J;</span><br><span class="line">            temp-&gt;element = result;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入一个新的元素到下一个位置</span></span><br><span class="line">            RowNext-&gt;right = temp;</span><br><span class="line">            RowNext = RowNext-&gt;right;</span><br><span class="line">            <span class="comment">//调转到合适的位置</span></span><br><span class="line">            <span class="keyword">while</span> (ColNext-&gt;down != <span class="literal">NULL</span>)</span><br><span class="line">                ColNext = ColNext-&gt;down;</span><br><span class="line">            ColNext-&gt;down = temp;</span><br><span class="line">            ColNext = ColNext-&gt;down;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//计算出一个元素，放入ResultMatrix</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/////////////////乘法做完，生成新的矩阵</span></span><br><span class="line">    <span class="keyword">return</span> ResultMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GenList-h"><a href="#GenList-h" class="headerlink" title="GenList.h"></a>GenList.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广义表的链表实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM 0  <span class="comment">//表中存储的是原子元素</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST 1  <span class="comment">//表中存储的是子表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD -1  <span class="comment">//是否是表头结点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1  <span class="comment">//已经访问过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0  <span class="comment">//未访问过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKTRACE 1  <span class="comment">//需要回溯</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTBACKTRACE 0  <span class="comment">//不需要回溯</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxName 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广义表的结点类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> type;   <span class="comment">//表示该结点是ATOM or LIST</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> ref;   <span class="comment">//如果是表头结点则，存储该结点被几个结点所指向</span></span><br><span class="line">            <span class="keyword">char</span> *Name;  <span class="comment">// 表头名称</span></span><br><span class="line">            <span class="keyword">int</span> mark;   <span class="comment">// 本子表是否被访问过</span></span><br><span class="line">        &#125; headNode;</span><br><span class="line">        GenListNode&lt;T&gt; *child;<span class="comment">//如果是LIST ,则指向它的元素的首结点</span></span><br><span class="line">        T element; <span class="comment">//如果是ATOM，则存储它的值</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    GenListNode&lt;T&gt; *next;<span class="comment">//指向下一个结点</span></span><br><span class="line">    GenListNode(T element);<span class="comment">//构造函数</span></span><br><span class="line">    GenListNode();</span><br><span class="line"></span><br><span class="line">    GenListNode(GenListNode&lt;T&gt; *<span class="built_in">list</span>);<span class="comment">//</span></span><br><span class="line">    ~GenListNode();<span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destory</span><span class="params">(GenListNode&lt;T&gt; *node)</span></span>;<span class="comment">//释放所有内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ViewAll</span><span class="params">()</span></span>;<span class="comment">//遍历该结点的子孙和兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenListTraversal</span><span class="params">()</span></span>;<span class="comment">//遍历该结点的子孙和兄弟，张铭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(GenListNode&lt;T&gt; *node, GenListNode&lt;T&gt; *prenode, <span class="keyword">int</span> &amp;flag)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenListTraversalHelp</span><span class="params">(GenListNode&lt;T&gt; *node)</span></span>;  <span class="comment">// 张铭</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//GenList是一个原子元素类型为T的广义表</span></span><br><span class="line"><span class="comment">//如果要实现能够存储多种数据类型的广义</span></span><br><span class="line"><span class="comment">//表，只需要嵌套的使用它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GenListNode&lt;T&gt; *head;<span class="comment">//整个广义表的头结点,不存储任何信息</span></span><br><span class="line">    GenListNode&lt;T&gt; *current;<span class="comment">//当前指针的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    GenList(<span class="keyword">char</span> *Name);</span><br><span class="line"></span><br><span class="line">    ~GenList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T element)</span></span>;<span class="comment">//在尾部加入一个元素结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(GenList&lt;T&gt; *gl)</span></span>;<span class="comment">//在尾部插入一个子表</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetHead</span><span class="params">()</span></span>;<span class="comment">//得到头结点的指针</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetNext</span><span class="params">()</span></span>;<span class="comment">//得到当前结点的下一个结点</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetPrev</span><span class="params">()</span></span>;<span class="comment">//得到当前结点的前一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveToFirst</span><span class="params">()</span></span>;<span class="comment">//当前指针指向head</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Remove</span><span class="params">()</span></span>;<span class="comment">//删除当前结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">View</span><span class="params">()</span></span>;<span class="comment">//遍历广义表，伍赛</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ViewList</span><span class="params">()</span></span>;<span class="comment">//遍历广义表, 张铭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="GenListFunction-h"><a href="#GenListFunction-h" class="headerlink" title="GenListFunction.h"></a>GenListFunction.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广义表的类实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GenList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//GenListNode的构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">GenListNode&lt;T&gt;::GenListNode(GenListNode&lt;T&gt; *list)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	//</span></span><br><span class="line"><span class="comment">	type=LIST;</span></span><br><span class="line"><span class="comment">    child=list;</span></span><br><span class="line"><span class="comment">	next=NULL;</span></span><br><span class="line"><span class="comment">	mark=0;</span></span><br><span class="line"><span class="comment">	ref=0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">GenListNode&lt;T&gt;::GenListNode(T element)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	    type=ATOM;</span></span><br><span class="line"><span class="comment">		child=NULL;</span></span><br><span class="line"><span class="comment">		this-&gt;element=element;</span></span><br><span class="line"><span class="comment">		next=NULL;</span></span><br><span class="line"><span class="comment">		mark=0;</span></span><br><span class="line"><span class="comment">		ref=0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt;::GenListNode() &#123;</span><br><span class="line">    type = LIST;</span><br><span class="line">    child = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GenListNode的析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt;::~GenListNode() &#123;</span><br><span class="line">    <span class="comment">//free all the memery </span></span><br><span class="line">    Destroy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::Destory(GenListNode&lt;T&gt; *node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        Destroy(node-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;child != <span class="literal">NULL</span>)</span><br><span class="line">        Destroy(node-&gt;child);</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">void GenListNode&lt;T&gt;::Search(GenListNode&lt;T&gt; *node,GenListNode&lt;T&gt; *prenode,int &amp;flag) </span></span><br><span class="line"><span class="comment">&#123;   //flag 为回溯标志</span></span><br><span class="line"><span class="comment">	if (node-&gt;type==HEAD)	&#123;//进入一个表头结点，准备访问它的子表</span></span><br><span class="line"><span class="comment">		node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		Search(node-&gt;next,node,flag);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	else	&#123;//非表头结点，访问每一个element结点</span></span><br><span class="line"><span class="comment">      if (node-&gt;type==ATOM) &#123;</span></span><br><span class="line"><span class="comment">		cout&lt;&lt;node-&gt;element;</span></span><br><span class="line"><span class="comment">		node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">	    &#125; </span></span><br><span class="line"><span class="comment">      else if(node-&gt;type==LIST) &#123;</span></span><br><span class="line"><span class="comment">			node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">			cout&lt;&lt;&quot;(&quot;;</span></span><br><span class="line"><span class="comment">			Search(node-&gt;child,node,flag);</span></span><br><span class="line"><span class="comment">			cout&lt;&lt;&quot;)&quot;;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">      if((node-&gt;next!=NULL)&amp;&amp;(node-&gt;next-&gt;mark!=VISITED)) &#123;//没有访问过，则继续访问</span></span><br><span class="line"><span class="comment">		  cout&lt;&lt;&quot;,&quot;;</span></span><br><span class="line"><span class="comment">		  node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		  Search(node-&gt;next,node,flag);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	  else if((node-&gt;next!=NULL)&amp;&amp;(node-&gt;type==ATOM))  //否则访问过，回溯</span></span><br><span class="line"><span class="comment">		      flag=BACKTRACE; //mark==VISITED，需要进行回溯</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	  if(flag==BACKTRACE)	&#123;//回溯操作</span></span><br><span class="line"><span class="comment">		  node-&gt;mark=UNVISITED;</span></span><br><span class="line"><span class="comment">		  if(prenode==NULL) 	&#123;//回溯到第一个结点，结束</span></span><br><span class="line"><span class="comment">			 flag=NOTBACKTRACE;</span></span><br><span class="line"><span class="comment">			 return;</span></span><br><span class="line"><span class="comment">		  &#125;</span></span><br><span class="line"><span class="comment">		  if((prenode-&gt;child=node)&amp;&amp;(prenode-&gt;next!=NULL)&amp;&amp;(prenode-&gt;next-&gt;mark==0)) &#123;//回溯到可以进入其他子链的地方</span></span><br><span class="line"><span class="comment">			 flag=NOTBACKTRACE;</span></span><br><span class="line"><span class="comment">			 return;</span></span><br><span class="line"><span class="comment">		  &#125;</span></span><br><span class="line"><span class="comment">	   &#125;	</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	//将刚才进入子链的mark值重新置为UNVISITED</span></span><br><span class="line"><span class="comment">	GenListNode&lt;T&gt;*temp=node;</span></span><br><span class="line"><span class="comment">	while(temp!=NULL)	&#123;</span></span><br><span class="line"><span class="comment">		temp-&gt;mark=UNVISITED;</span></span><br><span class="line"><span class="comment">		temp=temp-&gt;next;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::GenListTraversalHelp(GenListNode&lt;T&gt; *node) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *p;</span><br><span class="line">    node-&gt;headNode.mark = VISITED;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = node-&gt;next; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//p-&gt;mark=VISITED;</span></span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;type == LIST) &amp;&amp; (p-&gt;child != <span class="literal">NULL</span>)) &#123;    <span class="comment">//进入一个表头结点，准备访问它的子表</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;child-&gt;headNode.Name;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;child-&gt;headNode.mark == UNVISITED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;child-&gt;headNode.Name[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">                GenListTraversalHelp(p-&gt;child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;type == ATOM)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;element;</span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;next-&gt;type != HEAD))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">void GenListNode&lt;T&gt;::GenListTraversalHelp(GenListNode&lt;T&gt; *node) </span></span><br><span class="line"><span class="comment">&#123;   //flag 为回溯标志</span></span><br><span class="line"><span class="comment">	GenListNode&lt;T&gt; *p;</span></span><br><span class="line"><span class="comment">	node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;(&quot;;</span></span><br><span class="line"><span class="comment">	for (p = node-&gt;next; (p!=NULL)&amp;&amp;(p-&gt;type!=HEAD); p=p-&gt;next) &#123;</span></span><br><span class="line"><span class="comment">		p-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		if ((p-&gt;type==LIST)&amp;&amp;(p-&gt;child!=NULL)) &#123;	//进入一个表头结点，准备访问它的子表</span></span><br><span class="line"><span class="comment">			   cout &lt;&lt; p-&gt;child-&gt;headNode.Name;</span></span><br><span class="line"><span class="comment">			   if (p-&gt;child-&gt;mark == UNVISITED)  &#123;</span></span><br><span class="line"><span class="comment">				  if (p-&gt;child-&gt;headNode.Name[0]!=&#x27;\0&#x27;)</span></span><br><span class="line"><span class="comment">				  cout &lt;&lt;&quot;:&quot;;	</span></span><br><span class="line"><span class="comment">			      GenListTraversalHelp(p-&gt;child);</span></span><br><span class="line"><span class="comment">			   &#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else if (p-&gt;type==ATOM) </span></span><br><span class="line"><span class="comment">		    cout&lt;&lt;p-&gt;element;</span></span><br><span class="line"><span class="comment">		if ((p-&gt;next!=NULL)&amp;&amp;(p-&gt;next-&gt;type!=HEAD))</span></span><br><span class="line"><span class="comment">		    cout &lt;&lt; &quot;, &quot;;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;)&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::ViewAll() &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = NOTBACKTRACE;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    GenListTraversal(<span class="keyword">this</span>, <span class="literal">NULL</span>, flag);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广义表的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenList&lt;T&gt;::GenList(<span class="keyword">char</span> *Name) &#123;</span><br><span class="line">    head = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;type = HEAD;</span><br><span class="line">    head-&gt;headNode.ref = <span class="number">0</span>;</span><br><span class="line">    head-&gt;headNode.Name = Name;</span><br><span class="line">    current = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//广义表的插入函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::Insert(T element) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    current = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    current-&gt;type = ATOM;</span><br><span class="line">    current-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;element = element;</span><br><span class="line">    temp-&gt;next = current;</span><br><span class="line">    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::Insert(GenList&lt;T&gt; *genlist) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    GenListNode&lt;T&gt; *n = genlist-&gt;GetHead();</span><br><span class="line">    n-&gt;headNode.mark = UNVISITED;</span><br><span class="line">    n-&gt;headNode.ref++;</span><br><span class="line">    current = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    current-&gt;child = n;</span><br><span class="line">    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;type = LIST;</span><br><span class="line">    temp-&gt;next = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到头指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetHead() &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到下一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetNext() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到当前结点的前一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetPrev() &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == current)</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除当前结点,当前结点指针指向下一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> GenList&lt;T&gt;::Remove() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (current == head)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    GenListNode&lt;T&gt; *prev = GetPrev();</span><br><span class="line">    GenListNode&lt;T&gt; *next = GetNext();</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>)</span><br><span class="line">        current = prev;</span><br><span class="line">    <span class="keyword">else</span> current = next;</span><br><span class="line">    temp-&gt;Destory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move current point to head point</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::MoveToFirst() &#123;</span><br><span class="line">    current = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenList&lt;T&gt;::~GenList() &#123;</span><br><span class="line">    current = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (current != head)</span><br><span class="line">        Remove();</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::View() &#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;(&quot;;</span></span><br><span class="line">    MoveToFirst();</span><br><span class="line"><span class="comment">//	GenListNode&lt;T&gt; *temp=GetNext();</span></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    current-&gt;ViewAll();</span><br><span class="line">    <span class="comment">//temp=GetNext();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;)&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::ViewList() &#123;</span><br><span class="line">    MoveToFirst();</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    current-&gt;GenListTraversal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::GenListTraversal() &#123;</span><br><span class="line">    GenListTraversalHelp(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVLTreeNode-h"><a href="#AVLTreeNode-h" class="headerlink" title="AVLTreeNode.h"></a>AVLTreeNode.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//this is avl tree node </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">avlNode</span>//平衡二叉树结点类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    avlNode(T val);<span class="comment">//构造函数</span></span><br><span class="line">    avlNode(T val, avlNode&lt;T&gt; *left, avlNode&lt;T&gt; *right, <span class="keyword">int</span> bf);</span><br><span class="line"></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">copy</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//复制以当前结点为根的二叉树 ：(写多了，没用上)                           </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;<span class="comment">//删除以当前结点为根的左右子树									</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">(avlNode *)</span></span>;<span class="comment">//把当前结点的左指针修改为函数的参数</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">left</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//左子结点访问，返回左结点的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">(avlNode *v)</span></span>;<span class="comment">//把当前结点的右指针修改为函数的参数</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">right</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//右子结点访问，返回右结点的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(avlNode&lt;T&gt; *&amp;p, T val)</span></span>;<span class="comment">//插入一个值；返回新的avl树的根结点的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorderview</span><span class="params">(avlNode&lt;T&gt; *current, <span class="keyword">int</span> i = <span class="number">-1</span>)</span></span>;<span class="comment">//前序周游</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">remove</span><span class="params">(T val, avlNode&lt;T&gt; *&amp;waste, <span class="keyword">int</span> &amp;flag)</span></span>;<span class="comment">//删除以当前结点的为根的avl树中的val结点</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">findNodeValue</span><span class="params">(T val)</span></span>;<span class="comment">//查找val结点</span></span><br><span class="line">    T value;<span class="comment">//码值</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> bf;<span class="comment">// balance factor</span></span><br><span class="line">    avlNode&lt;T&gt; *leftptr;<span class="comment">//左右指针</span></span><br><span class="line">    avlNode&lt;T&gt; *rightptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//avlNode&lt;T&gt;* restoreLeftBalance(int oldbf);//删除时左子树失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="comment">//avlNode&lt;T&gt;* restoreRightBalance(int oldbf);//删除时右子树失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">removeLeftmostElement</span><span class="params">(avlNode&lt;T&gt; *&amp;childptr, <span class="keyword">int</span> &amp;flag)</span></span>;<span class="comment">//找到最左的结点</span></span><br><span class="line">    <span class="comment">//avlNode&lt;T&gt;* removeBalanceLeft();//从左子树删除的时候判断层数的改变</span></span><br><span class="line">    <span class="comment">//avlNode&lt;T&gt;* removeBalanceRight();//从右子树删除的时候判断层数的改变</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">LL_singleRotation</span><span class="params">()</span></span>;<span class="comment">//在插入时候左子树LL失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">RR_singleRotation</span><span class="params">()</span></span>;<span class="comment">//在插入时候右子树RR失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">LR_doubleRotation</span><span class="params">()</span></span>;<span class="comment">//在插入时候左子树LR失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">RL_doubleRotation</span><span class="params">()</span></span>;<span class="comment">//在插入时候右子树RL失衡的时候调整，返回新的树根的指针</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt;::avlNode(T val) &#123;</span><br><span class="line">    value = val;</span><br><span class="line">    leftptr = <span class="literal">NULL</span>;</span><br><span class="line">    rightptr = <span class="literal">NULL</span>;</span><br><span class="line">    bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt;::avlNode(T val, avlNode&lt;T&gt; *left, avlNode&lt;T&gt; *right, <span class="keyword">int</span> bf = <span class="number">0</span>) &#123;</span><br><span class="line">    value = val;</span><br><span class="line">    leftptr = left;</span><br><span class="line">    rightptr = right;</span><br><span class="line">    bf = bf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::copy() <span class="keyword">const</span> &#123;</span><br><span class="line">    avlNode&lt;T&gt; *nl, *nr;</span><br><span class="line">    nl = (leftptr == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : leftptr-&gt;copy());<span class="comment">//递归调用复制左子树</span></span><br><span class="line">    nr = (rightptr == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : rightptr-&gt;copy());<span class="comment">//递归调用复制右子树</span></span><br><span class="line">    avlNode&lt;T&gt; *node = <span class="keyword">new</span> avlNode&lt;T&gt;(value, nl, nr, bf);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)   <span class="comment">//?? ==NULL</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlNode&lt;T&gt;::release() &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftptr) &#123;<span class="comment">//删除左子树中的结点</span></span><br><span class="line">        leftptr-&gt;release();<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">delete</span> leftptr;</span><br><span class="line">        leftptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightptr) &#123;<span class="comment">//删除右子树中的结点</span></span><br><span class="line">        rightptr-&gt;release();<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">delete</span> rightptr;</span><br><span class="line">        rightptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::left() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlNode&lt;T&gt;::left(avlNode&lt;T&gt; *v) &#123;</span><br><span class="line">    leftptr = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::right() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rightptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlNode&lt;T&gt;::right(avlNode&lt;T&gt; *v) &#123;</span><br><span class="line">    rightptr = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> avlNode&lt;T&gt;::add(avlNode&lt;T&gt; *&amp;rp, T val) &#123;<span class="comment">//返回值表明以当前结点为根的树是否再插入之后增高，0:非增高，非0:增高</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; value) &#123;<span class="comment">//左子树插入</span></span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;left() == <span class="literal">NULL</span>)</span><br><span class="line">            rp-&gt;left(<span class="keyword">new</span> avlNode&lt;T&gt;(val));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;left()-&gt;add(rp-&gt;leftptr, val) == <span class="number">0</span>)<span class="comment">//插入后子树没有增高</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;bf == <span class="number">-1</span>) &#123;<span class="comment">//原来已经倾斜，左边失衡，需要做平衡处理</span></span><br><span class="line">            <span class="keyword">if</span> (rp-&gt;left()-&gt;bf &lt; <span class="number">0</span>)  <span class="comment">//插入在左侧，单旋转</span></span><br><span class="line">                rp = LL_singleRotation();</span><br><span class="line">            <span class="keyword">else</span> rp = LR_doubleRotation();    <span class="comment">//插入在右侧，双旋转</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> --bf;   <span class="comment">// bf=(0, +1)的情况，不需要调整树，只要修改bf</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;right() == <span class="literal">NULL</span>)</span><br><span class="line">            rp-&gt;right(<span class="keyword">new</span> avlNode&lt;T&gt;(val));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;right()-&gt;add(rp-&gt;rightptr, val) == <span class="number">0</span>)<span class="comment">//插入后子树没有增高 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;bf == <span class="number">1</span>) &#123;<span class="comment">//原来已经倾斜，需要做平衡处理</span></span><br><span class="line">            <span class="keyword">if</span> (rp-&gt;right()-&gt;bf &gt; <span class="number">0</span>)    <span class="comment">//插入在右侧，单旋转</span></span><br><span class="line">                rp = RR_singleRotation();</span><br><span class="line">            <span class="keyword">else</span> rp = RL_doubleRotation();  <span class="comment">//插入点在右侧.双旋转</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++bf; <span class="comment">// bf=(0, -1)的情况，不需要调整树，只要修改bf</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::remove(T val, avlNode&lt;T&gt; *&amp;waste, <span class="keyword">int</span> &amp;flag) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val == value) &#123;</span><br><span class="line">        waste = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//当没有右子树的时候返回左子树</span></span><br><span class="line">        <span class="keyword">if</span> (right() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> left();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除右子树中的最小结点</span></span><br><span class="line">        <span class="keyword">int</span> oldbf = right()-&gt;bf;</span><br><span class="line">        avlNode *newroot;</span><br><span class="line">        right(right()-&gt;removeLeftmostElement(newroot, flag));<span class="comment">//找到后返回已经平衡的avl树的根指针</span></span><br><span class="line">        newroot-&gt;left(left());</span><br><span class="line">        newroot-&gt;right(right());</span><br><span class="line">        <span class="keyword">if</span> ((flag == <span class="number">1</span>) &amp;&amp; (bf == <span class="number">1</span>))</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            newroot-&gt;bf = bf--;</span><br><span class="line">        &#125; <span class="keyword">else</span> newroot-&gt;bf = bf;</span><br><span class="line">        <span class="comment">//左树的平衡</span></span><br><span class="line">        avlNode&lt;T&gt; *rightchild = newroot-&gt;right();</span><br><span class="line">        <span class="keyword">if</span> (rightchild == <span class="literal">NULL</span>)</span><br><span class="line">            bf--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rightchild-&gt;bf != oldbf) &amp;&amp; (rightchild-&gt;bf == <span class="number">0</span>))</span><br><span class="line">            bf--;</span><br><span class="line">        <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> newoldbf = newroot-&gt;left()-&gt;bf;</span><br><span class="line">            <span class="keyword">if</span> (newoldbf &gt; <span class="number">0</span>) &#123;<span class="comment">//双旋转</span></span><br><span class="line">                <span class="keyword">return</span> newroot-&gt;LR_doubleRotation();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//单旋转</span></span><br><span class="line">                <span class="keyword">return</span> newroot-&gt;LL_singleRotation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newroot;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; value) &#123;<span class="comment">//从左子树中删除</span></span><br><span class="line">        <span class="keyword">if</span> (left() == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//执行删除</span></span><br><span class="line">        <span class="keyword">int</span> oldbf = left()-&gt;bf;</span><br><span class="line">        left(left()-&gt;remove(val, waste, flag));<span class="comment">//递归调用</span></span><br><span class="line">        <span class="comment">//调整左子树</span></span><br><span class="line">        avlNode&lt;T&gt; *leftchild = left();</span><br><span class="line">        <span class="comment">//	if(flag==1)</span></span><br><span class="line">        <span class="comment">//		bf++;</span></span><br><span class="line">        <span class="comment">//计算删除后的子树对当前的根结点的平衡因子的影响</span></span><br><span class="line">        <span class="keyword">if</span> (leftchild == <span class="literal">NULL</span>)</span><br><span class="line">            bf++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((leftchild-&gt;bf != oldbf) &amp;&amp; (leftchild-&gt;bf == <span class="number">0</span>))</span><br><span class="line">            bf++;</span><br><span class="line">        <span class="keyword">if</span> (bf &gt; <span class="number">1</span>)<span class="comment">//失衡</span></span><br><span class="line">        &#123;<span class="comment">//调整</span></span><br><span class="line">            <span class="keyword">int</span> newoldbf = right()-&gt;bf;</span><br><span class="line">            <span class="keyword">if</span> (newoldbf &lt; <span class="number">0</span>)<span class="comment">//双旋转</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> RL_doubleRotation();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//单旋转</span></span><br><span class="line">                avlNode *temp = RR_singleRotation();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                    bf++;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//从右子树中删除</span></span><br><span class="line">        <span class="keyword">if</span> (right() == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//执行删除</span></span><br><span class="line">        <span class="keyword">int</span> oldbf = right()-&gt;bf;</span><br><span class="line">        right(right()-&gt;remove(val, waste, flag));<span class="comment">//递归调用</span></span><br><span class="line">        <span class="comment">//调整右子树</span></span><br><span class="line">        avlNode&lt;T&gt; *rightchild = right();</span><br><span class="line">        <span class="keyword">if</span> (rightchild == <span class="literal">NULL</span>)</span><br><span class="line">            bf--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rightchild-&gt;bf != oldbf) &amp;&amp; (rightchild-&gt;bf == <span class="number">0</span>))</span><br><span class="line">            bf--;</span><br><span class="line">        <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> newoldbf = left()-&gt;bf;</span><br><span class="line">            <span class="keyword">if</span> (newoldbf &gt; <span class="number">0</span>) &#123;<span class="comment">//双旋转</span></span><br><span class="line">                <span class="keyword">return</span> LR_doubleRotation();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//单旋转</span></span><br><span class="line">                avlNode *temp = LL_singleRotation();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                    bf--;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::removeLeftmostElement(avlNode&lt;T&gt; *&amp;childptr, <span class="keyword">int</span> &amp;flag) &#123;<span class="comment">//flag 表示子树高度是否变化</span></span><br><span class="line">    avlNode *leftchild = left();</span><br><span class="line">    <span class="comment">//找到最小的值，返回，否则递归调用</span></span><br><span class="line">    <span class="keyword">if</span> (leftchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        childptr = <span class="keyword">this</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> oldbf = leftchild-&gt;bf;</span><br><span class="line">    left(leftchild-&gt;removeLeftmostElement(childptr, flag));<span class="comment">//递归调用</span></span><br><span class="line">    <span class="comment">//调整左子树平衡</span></span><br><span class="line">    avlNode&lt;T&gt; *newleftchild = left();</span><br><span class="line">    <span class="comment">//计算删除后的子树的高度变化</span></span><br><span class="line">    <span class="keyword">if</span> ((newleftchild == <span class="literal">NULL</span>) &amp;&amp; (right() == <span class="literal">NULL</span>))</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算删除后的子树对当前的根结点的平衡因子的影响</span></span><br><span class="line">    <span class="keyword">if</span> (newleftchild == <span class="literal">NULL</span>)</span><br><span class="line">        bf++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newleftchild-&gt;bf != oldbf) &amp;&amp; (newleftchild-&gt;bf == <span class="number">0</span>))</span><br><span class="line">        bf++;</span><br><span class="line">    <span class="keyword">if</span> (bf &gt; <span class="number">1</span>)<span class="comment">//失衡</span></span><br><span class="line">    &#123;<span class="comment">//调整</span></span><br><span class="line">        <span class="keyword">int</span> newoldbf = right()-&gt;bf;</span><br><span class="line">        <span class="keyword">if</span> (newoldbf &lt; <span class="number">0</span>)<span class="comment">//双旋转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> RL_doubleRotation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//单旋转</span></span><br><span class="line">            <span class="keyword">return</span> RR_singleRotation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::findNodeValue(T val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; value) &#123;<span class="comment">//大于的话在右子树中查找</span></span><br><span class="line">        <span class="keyword">if</span> (right() != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> right()-&gt;findNodeValue(val);<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//小于的话在左子树中查找</span></span><br><span class="line">        <span class="keyword">if</span> (left() != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> left()-&gt;findNodeValue(val);<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlNode&lt;T&gt;::preorderview(avlNode&lt;T&gt; *current, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    i++;<span class="comment">//层计数器</span></span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">8</span>) &lt;&lt; current-&gt;value &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; current-&gt;bf &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        preorderview(current-&gt;left(), i);<span class="comment">//递归调用</span></span><br><span class="line">        preorderview(current-&gt;right(), i);<span class="comment">//递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::LL_singleRotation() &#123;</span><br><span class="line">    avlNode&lt;T&gt; *p;</span><br><span class="line">    p = left();</span><br><span class="line">    left(p-&gt;right());</span><br><span class="line">    bf = <span class="number">0</span>;</span><br><span class="line">    p-&gt;right(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">0</span>)</span><br><span class="line">        p-&gt;bf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::LR_doubleRotation() &#123;</span><br><span class="line">    avlNode&lt;T&gt; *p, *q;</span><br><span class="line">    q = left();</span><br><span class="line">    p = q-&gt;right();</span><br><span class="line">    q-&gt;right(p-&gt;left());</span><br><span class="line">    left(p-&gt;right());</span><br><span class="line">    p-&gt;left(q);</span><br><span class="line">    bf = q-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">-1</span>) bf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">1</span>) q-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">    p-&gt;right(<span class="keyword">this</span>);</span><br><span class="line">    p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::RR_singleRotation() &#123;</span><br><span class="line">    avlNode&lt;T&gt; *p;</span><br><span class="line">    p = right();</span><br><span class="line">    right(p-&gt;left());</span><br><span class="line">    bf = <span class="number">0</span>;</span><br><span class="line">    p-&gt;left(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">0</span>)</span><br><span class="line">        p-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::RL_doubleRotation() &#123;</span><br><span class="line">    avlNode&lt;T&gt; *p, *q;</span><br><span class="line">    q = right();</span><br><span class="line">    p = q-&gt;left();</span><br><span class="line">    q-&gt;left(p-&gt;right());</span><br><span class="line">    right(p-&gt;left());</span><br><span class="line">    p-&gt;right(q);</span><br><span class="line">    bf = q-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">-1</span>) q-&gt;bf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">1</span>) bf = <span class="number">-1</span>;</span><br><span class="line">    p-&gt;left(<span class="keyword">this</span>);</span><br><span class="line">    p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVLTree-h"><a href="#AVLTree-h" class="headerlink" title="AVLTree.h"></a>AVLTree.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//this is avl tree class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AVLNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">avlTree</span>//平衡二叉树类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    avlTree();<span class="comment">//构造函数</span></span><br><span class="line">    avlTree(<span class="keyword">const</span> avlTree&lt;T&gt; &amp;source);</span><br><span class="line"></span><br><span class="line">    ~avlTree();<span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAllValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(avlNode&lt;T&gt; *found)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">findValue</span><span class="params">(T val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    avlNode&lt;T&gt; *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlTree&lt;T&gt;::avlTree():root(<span class="number">0</span>) &#123;&#125;<span class="comment">//建立空树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlTree&lt;T&gt;::avlTree(<span class="keyword">const</span> avlTree&lt;T&gt; &amp;source) &#123;<span class="comment">//复制构造函数</span></span><br><span class="line">    root = (source.root == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : source.root-&gt;copy());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlTree&lt;T&gt;::~avlTree() &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) deleteAllValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::add(T value) &#123;<span class="comment">//向平衡的avl树添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        root = <span class="keyword">new</span> avlNode&lt;T&gt;(value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;add(root, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::remove(T val) &#123;<span class="comment">//从avl树中删除一个元素</span></span><br><span class="line">    avlNode&lt;T&gt; *eNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">        root = root-&gt;remove(val, eNode, flag);</span><br><span class="line">    <span class="keyword">if</span> (eNode)</span><br><span class="line">        <span class="keyword">delete</span> eNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The avlTree doesn&#x27;t contain the value&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::deleteAllValue() &#123;<span class="comment">//删除avl树的全部元素</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;release();</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::display() &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;节点值&quot;</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;平衡因子&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; <span class="string">&quot;层数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        root-&gt;preorderview(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前树空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlTree&lt;T&gt;::findValue(T val) &#123;<span class="comment">//查找val的节点值</span></span><br><span class="line">    avlNode&lt;T&gt; *found = root-&gt;findNodeValue(val);</span><br><span class="line">    <span class="keyword">if</span> (found == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::display(avlNode&lt;T&gt; *found) &#123;<span class="comment">//显示指针的指向的码值</span></span><br><span class="line">    <span class="keyword">if</span> (found == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorry,没找到 :(&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; found-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OptimalBST-cpp"><a href="#OptimalBST-cpp" class="headerlink" title="OptimalBST.cpp"></a>OptimalBST.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 动态规划算法求解最优二叉搜索树问题</span></span><br><span class="line"><span class="comment">//输入参数:a[]内部结点的权,b[]外部结点的权,n结点数</span></span><br><span class="line"><span class="comment">//输出参数:**w权的总和,**r结果二叉树,**c构造树的代价</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OptimalBST</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n, <span class="keyword">int</span> c[N + <span class="number">1</span>][N + <span class="number">1</span>], <span class="keyword">int</span> r[N + <span class="number">1</span>][N + <span class="number">1</span>], <span class="keyword">int</span> w[N + <span class="number">1</span>][N + <span class="number">1</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, d;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)                        <span class="comment">// 数组下三角清零</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            c[i][j] = <span class="number">0</span>;</span><br><span class="line">            r[i][j] = <span class="number">0</span>;</span><br><span class="line">            w[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 初始化，确定每一个总权和w[i,j]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        w[i][i] = b[i];</span><br><span class="line">        <span class="comment">//求出权和w[i.j]</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            w[i][j] = w[i][j - <span class="number">1</span>] + a[j] + b[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定一个结点的最佳二叉搜索树，一个结点的c[j-1, j]就是对应的w[j-1, j]</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        c[j - <span class="number">1</span>][j] = w[j - <span class="number">1</span>][j];</span><br><span class="line">        r[j - <span class="number">1</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定d个结点的最佳二叉树</span></span><br><span class="line">    <span class="keyword">int</span> m, k0, k;</span><br><span class="line">    <span class="keyword">for</span> (d = <span class="number">2</span>; d &lt;= n; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = d; j &lt;= n; j++) &#123;</span><br><span class="line">            i = j - d;</span><br><span class="line">            m = c[i + <span class="number">1</span>][j];</span><br><span class="line">            k0 = i + <span class="number">1</span>;                            <span class="comment">// 以Ki+1为根</span></span><br><span class="line">            <span class="keyword">for</span> (k = i + <span class="number">2</span>; k &lt;= j; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[i][k - <span class="number">1</span>] + c[k][j] &lt; m) &#123;        <span class="comment">// 动态规划的核心步骤</span></span><br><span class="line">                    m = c[i][k - <span class="number">1</span>] + c[k][j];        <span class="comment">// 把当前最小记录下来</span></span><br><span class="line">                    k0 = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            c[i][j] = w[i][j] + m;                <span class="comment">// 记录最小权</span></span><br><span class="line">            r[i][j] = k0;                            <span class="comment">// 记录树根</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造新教材图12.27最佳二叉树</span></span><br><span class="line">    <span class="keyword">int</span> a[N + <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N + <span class="number">1</span>] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> r[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> w[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> n = N;</span><br><span class="line">    <span class="comment">//计算最佳二叉树</span></span><br><span class="line">    OptimalBST(a, b, n, c, r, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0 &quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SplayTree-h"><a href="#SplayTree-h" class="headerlink" title="SplayTree.h"></a>SplayTree.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//****************************  genSplay.h  ****************************</span></span><br><span class="line"><span class="comment">//伸展树类模版</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPLAYING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPLAYING</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayingNode</span> &#123;</span><span class="comment">//伸展树的结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SplayingNode *left, *right, *parent;<span class="comment">//结点的左右儿子和父亲结点</span></span><br><span class="line">    T info;                     <span class="comment">//存储的数据</span></span><br><span class="line">    SplayingNode() &#123;<span class="comment">//构造函数</span></span><br><span class="line">        left = right = parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SplayingNode(<span class="keyword">const</span> T &amp;el, SplayingNode *l = <span class="number">0</span>, SplayingNode *r = <span class="number">0</span>,</span><br><span class="line">                 SplayingNode *p = <span class="number">0</span>) &#123;<span class="comment">//构造函数</span></span><br><span class="line">        info = el;</span><br><span class="line">        left = l;</span><br><span class="line">        right = r;</span><br><span class="line">        parent = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span> &#123;</span><span class="comment">//伸展树类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SplayTree() &#123;</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;<span class="comment">//排序</span></span><br><span class="line">        inorder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">search</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;<span class="comment">//搜索元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;<span class="comment">//插入元素</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    SplayingNode&lt;T&gt; *root; <span class="comment">//根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotateR</span><span class="params">(SplayingNode&lt;T&gt; *)</span></span>;  <span class="comment">//右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotateL</span><span class="params">(SplayingNode&lt;T&gt; *)</span></span>;  <span class="comment">//左旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">continueRotation</span><span class="params">(SplayingNode&lt;T&gt; *gr, SplayingNode&lt;T&gt; *par,</span></span></span><br><span class="line"><span class="function"><span class="params">                          SplayingNode&lt;T&gt; *ch, SplayingNode&lt;T&gt; *desc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行“之“型或者“一“型旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(SplayingNode&lt;T&gt; *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(SplayingNode&lt;T&gt; *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">visit</span><span class="params">(SplayingNode&lt;T&gt; *)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::continueRotation(SplayingNode&lt;T&gt; *gr, SplayingNode&lt;T&gt; *par,</span><br><span class="line">                                    SplayingNode&lt;T&gt; *ch, SplayingNode&lt;T&gt; *desc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (gr != <span class="number">0</span>) &#123; <span class="comment">// 结点是否有祖父结点</span></span><br><span class="line">        <span class="keyword">if</span> (gr-&gt;right == ch-&gt;parent)</span><br><span class="line">            gr-&gt;right = ch;</span><br><span class="line">        <span class="keyword">else</span> gr-&gt;left = ch;</span><br><span class="line">    &#125; <span class="keyword">else</span> root = ch;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="number">0</span>)</span><br><span class="line">        desc-&gt;parent = par;</span><br><span class="line">    par-&gt;parent = ch;</span><br><span class="line">    ch-&gt;parent = gr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::rotateR(SplayingNode&lt;T&gt; *p) &#123;</span><br><span class="line">    p-&gt;parent-&gt;left = p-&gt;right;</span><br><span class="line">    p-&gt;right = p-&gt;parent;</span><br><span class="line">    continueRotation(p-&gt;parent-&gt;parent, p-&gt;right, p, p-&gt;right-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::rotateL(SplayingNode&lt;T&gt; *p) &#123;</span><br><span class="line">    p-&gt;parent-&gt;right = p-&gt;left;</span><br><span class="line">    p-&gt;left = p-&gt;parent;</span><br><span class="line">    continueRotation(p-&gt;parent-&gt;parent, p-&gt;left, p, p-&gt;left-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::splay(SplayingNode&lt;T&gt; *p) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p != root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parent-&gt;parent == <span class="number">0</span>)    <span class="comment">// 如果结点的父亲是根结点</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent-&gt;left == p)</span><br><span class="line">                rotateR(p);</span><br><span class="line">            <span class="keyword">else</span> rotateL(p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;parent-&gt;left == p) <span class="comment">// 如果结点是左子女</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent-&gt;parent-&gt;left == p-&gt;parent) &#123;</span><br><span class="line">                rotateR(p-&gt;parent);</span><br><span class="line">                rotateR(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rotateR(p); <span class="comment">// 旋转p和它的父亲</span></span><br><span class="line">                rotateL(p); <span class="comment">// 旋转p和他的新父亲</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>                          <span class="comment">// 如果结点是右子女</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parent-&gt;parent-&gt;right == p-&gt;parent) &#123;</span><br><span class="line">            rotateL(p-&gt;parent);</span><br><span class="line">            rotateL(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rotateL(p); <span class="comment">// 旋转p和它的父亲</span></span><br><span class="line">            rotateR(p); <span class="comment">// 旋转p和他的新父亲</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>)              <span class="comment">// 更新根结点</span></span><br><span class="line">            root = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T *SplayTree&lt;T&gt;::search(<span class="keyword">const</span> T &amp;el) &#123;</span><br><span class="line">    SplayingNode&lt;T&gt; *p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;info == el) &#123;        <span class="comment">// el元素是否在树中</span></span><br><span class="line">            splay(p);</span><br><span class="line">            <span class="keyword">return</span> &amp;p-&gt;info;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el &lt; p-&gt;info)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> p = p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::insert(<span class="keyword">const</span> T &amp;el) &#123;</span><br><span class="line">    SplayingNode&lt;T&gt; *p = root, *prev = <span class="number">0</span>, *newNode;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>) &#123;  <span class="comment">// 插入一个新的元素</span></span><br><span class="line">        prev = p;</span><br><span class="line">        <span class="keyword">if</span> (el &lt; p-&gt;info)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((newNode = <span class="keyword">new</span> SplayingNode&lt;T&gt;(el, <span class="number">0</span>, <span class="number">0</span>, prev)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;No room for new nodes\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>)    <span class="comment">// 树是空的</span></span><br><span class="line">        root = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (el &lt; prev-&gt;info)</span><br><span class="line">        prev-&gt;left = newNode;</span><br><span class="line">    <span class="keyword">else</span> prev-&gt;right = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::inorder(SplayingNode&lt;T&gt; *p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        inorder(p-&gt;left);</span><br><span class="line">        visit(p);</span><br><span class="line">        inorder(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C++程序设计</title>
    <url>/2020/12/28/fundamentals-of-Cpp-programming/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/12/28/fundamentals-of-Cpp-programming/IMG_20201223_235334.jpg">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">如果时光可以倒流，我还是会选择认识你。<br>虽然会伤痕累累，但是心中的温暖记忆是谁都无法给与的。<br>谢谢你来过我的世界。</div>
</center>






<a id="more"></a>
<h2 id="一-从C到C"><a href="#一-从C到C" class="headerlink" title="一    从C到C++"></a>一    从C到C++</h2><h3 id="1-1-C-语言的历史"><a href="#1-1-C-语言的历史" class="headerlink" title="1.1    C++语言的历史"></a>1.1    C++语言的历史</h3><p>1983年诞生的C++对C语言的改进包括面向对象、虚函数、函数和运算符重载、引用等。1989年推出的C++2.0实现了多重继承、抽象类、静态成员、常量成员函数等功能。1990年加入了模板、异常处理、命名空间等机制。1998年诞生的C++98加入了标准模板库（STL），C++从此实现了泛型程序设计。2011年发布的C++11标准支持正则表达式、哈希表以及其他一系列重要的功能。当前最新的C++标准是C++20。</p>
<h3 id="1-2-输入输出"><a href="#1-2-输入输出" class="headerlink" title="1.2    输入输出"></a>1.2    输入输出</h3><p>C++使用<code>cin</code>和<code>cout</code>实现输入输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-头文件"><a href="#1-3-头文件" class="headerlink" title="1.3    头文件"></a>1.3    头文件</h3><p>C++头文件不再以”.h”结尾，常用的C++头文件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;		//标准输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;		//STL 通用算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;		//参数化输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;			//定义数学函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;		//字符串处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;			//定义关于时间的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;		//STL 动态数组容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;			//STL 队列容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;			//STL 堆栈容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;		//字符串类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;		//文件输入／输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;			//STL 集合容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;			//STL 映射容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;		//定义杂项函数及内存分配函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;		//STL 通用模板类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;		//基于字符串的流</span></span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-强制类型转换"><a href="#1-4-强制类型转换" class="headerlink" title="1.4    强制类型转换"></a>1.4    强制类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="number">3.5</span>);	<span class="comment">//C++通常写成类似函数调用的格式</span></span><br><span class="line"><span class="keyword">double</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span>(a);</span><br><span class="line">(<span class="keyword">int</span>)<span class="number">3.5</span>;	<span class="comment">//传统的C格式</span></span><br><span class="line">(<span class="keyword">double</span>)<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-函数参数的默认值"><a href="#1-5-函数参数的默认值" class="headerlink" title="1.5    函数参数的默认值"></a>1.5    函数参数的默认值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">(<span class="keyword">int</span> x=<span class="number">20</span>)</span></span>;	<span class="comment">//函数声明，x默认为20</span></span><br><span class="line">Function1();				<span class="comment">//函数调用，等效于Function(20);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用表达式作为函数的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y=Max(a,b),<span class="keyword">int</span> z=a*b)</span><span class="comment">//函数定义处也可以写参数的默认值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Function2(<span class="number">4</span>);		<span class="comment">//Function2(4,Max(a,b),a*b)</span></span><br><span class="line">Function2(<span class="number">4</span>,<span class="number">9</span>);		<span class="comment">//Function2(4,9,a*b);</span></span><br><span class="line">Function2(<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Function2(<span class="number">4</span>,,<span class="number">3</span>);	<span class="comment">//报错，省略的参数一定是最右边连续的几个</span></span><br></pre></td></tr></table></figure>
<h3 id="1-6-引用和函数参数的传递"><a href="#1-6-引用和函数参数的传递" class="headerlink" title="1.6    引用和函数参数的传递"></a>1.6    引用和函数参数的传递</h3><h4 id="1-6-1-引用"><a href="#1-6-1-引用" class="headerlink" title="1.6.1    引用"></a>1.6.1    引用</h4><p>引用某个变量相当于某个变量的别名。<strong>定义引用时必须初始化，通常用某个变量初始化引用。</strong>引用初始化后会一直引用该变量，不会引用别的变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>&amp; r=n;</span><br></pre></td></tr></table></figure>
<p>修改变量的值，引用的值也会修改。修改引用的值，变量的值也会修改。多个不同的引用可以引用同一变量。</p>
<h4 id="1-6-2-引用作为函数返回值"><a href="#1-6-2-引用作为函数返回值" class="headerlink" title="1.6.2    引用作为函数返回值"></a>1.6.2    引用作为函数返回值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">SetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetValue()=<span class="number">40</span>;		<span class="comment">//返回引用的函数表达式可作为左值使用，等效于n=40;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; r=SetValue();	<span class="comment">//r为n的引用，r=40；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-3-值传递和引用传递"><a href="#1-6-3-值传递和引用传递" class="headerlink" title="1.6.3    值传递和引用传递"></a>1.6.3    值传递和引用传递</h4><p>函数传参的形式有两种，一是值传递，二是引用传递。值传递形参是实参的拷贝，形参改变不影响实参。在函数调用过程中，实参的值会被复制到栈中，函数执行过程中对形参的改变只是修改了实参的拷贝，不修改实参。如果函数的形参是引用，那么形参的改变会影响实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//错误</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span><span class="comment">//正确</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-4-常引用"><a href="#1-6-4-常引用" class="headerlink" title="1.6.4    常引用"></a>1.6.4    常引用</h4><p>加上<code>const</code>关键字的引用称为常引用。<strong>不能通过常引用修改其引用的内容。</strong>常引用的类型为<code>const T&amp;</code>。引用和变量可以初始化常引用，但常变量和常引用不能初始化引用，除非进行强制类型转换。</p>
<h3 id="1-7-内联函数"><a href="#1-7-内联函数" class="headerlink" title="1.7    内联函数"></a>1.7    内联函数</h3><p>进行函数调用时，首先要在栈中开辟形参和局部变量的存储空间，接着把实参的值复制给形参，然后把函数返回地址放入栈中，最后跳转至函数内部执行。函数调用结束时，需要从栈中回收形参和局部变量的空间，取出返回地址才能跳转到该地址继续执行。如果一个函数语句很简单，执行时间很短，又经常被调用，函数调用带来的时间开销就非常大。因此在返回值前加上<code>inline</code>关键字，成为内联函数，编译器编译时就不会将该语句编译成调用指令，而是直接插入代码。这样既可以实现代码复用，又不会造成函数调用的额外开销。调用内联函数前必须出现内联函数的定义而不仅是其声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-函数重载"><a href="#1-8-函数重载" class="headerlink" title="1.8    函数重载"></a>1.8    函数重载</h3><p>多个函数名字相同但参数表不同称为函数重载。编译器可以通过函数调用语句中实参的个数和类型确定应该调用哪个函数。常见的一种重载编译出错是二义性错误。仅返回值不同的函数是重复定义，不是重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Max 1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Max 2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sum 1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sum 2&quot;</span>&lt;&lt;end</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Max(<span class="number">3</span>,<span class="number">1.5</span>);		<span class="comment">//二义性错误</span></span><br><span class="line">    Sum(<span class="number">1</span>,<span class="number">2</span>);		<span class="comment">//二义性错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-9-指针和动态内存分配"><a href="#1-9-指针和动态内存分配" class="headerlink" title="1.9    指针和动态内存分配"></a>1.9    指针和动态内存分配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[n];	<span class="comment">//编译出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>;	<span class="comment">//动态分配4byte的内存空间</span></span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>* pn=<span class="keyword">new</span> <span class="keyword">int</span>[i*<span class="number">20</span>];	<span class="comment">//动态分配i*20*sizeof(int)byte的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> p;	<span class="comment">//动态分配的内存空间使用完后应当释放，但不能重复delete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> []p;		<span class="comment">//释放动态分配的数组内存</span></span><br></pre></td></tr></table></figure>
<h3 id="1-10-string对象"><a href="#1-10-string对象" class="headerlink" title="1.10    string对象"></a>1.10    string对象</h3><p><code>string</code>是标准模板库中的一个类，需要包含头文件<code>string</code>。处理字符串优先考虑使用<code>string</code>类。<code>string</code>对象只存放字符串地址而不直接存放字符串。</p>
<h4 id="1-10-1-string对象的定义、输入输出和赋值"><a href="#1-10-1-string对象的定义、输入输出和赋值" class="headerlink" title="1.10.1    string对象的定义、输入输出和赋值"></a>1.10.1    string对象的定义、输入输出和赋值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> str1;			<span class="comment">//没有初始化的值为空串&quot;&quot;</span></span><br><span class="line"><span class="built_in">string</span> city=<span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> as[]=&#123;<span class="string">&quot;Beijing&quot;</span>,<span class="string">&quot;Shanghai&quot;</span>,<span class="string">&quot;Chengdu&quot;</span>&#125;;	<span class="comment">//string数组</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;as[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><code>string</code>可以互相赋值，也可以用<code>char[]</code>赋值。</p>
<h4 id="1-10-2-string的运算"><a href="#1-10-2-string的运算" class="headerlink" title="1.10.2    string的运算"></a>1.10.2    string的运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;abc&quot;</span>,s3;	<span class="comment">//s3==&quot;&quot;</span></span><br><span class="line">s3=s1+s2;						<span class="comment">//s3==&quot;123abc&quot;</span></span><br><span class="line">s3+=<span class="string">&quot;de&quot;</span>;						<span class="comment">//s3==&quot;123abcde&quot;</span></span><br><span class="line"><span class="keyword">bool</span> b=s1&lt;s3;					<span class="comment">//b==true</span></span><br><span class="line"><span class="keyword">char</span> c=s1[<span class="number">2</span>];					<span class="comment">//c==&#x27;3&#x27;</span></span><br><span class="line">s1[<span class="number">2</span>]=<span class="string">&#x27;5&#x27;</span>;						<span class="comment">//s1=&quot;125&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-10-3-string类的使用"><a href="#1-10-3-string类的使用" class="headerlink" title="1.10.3    string类的使用"></a>1.10.3    string类的使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;abcdef&quot;</span>,s3;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1.size()&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2.substr(<span class="number">1</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//bcd</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">s3=s1+s2;</span><br><span class="line"><span class="built_in">strcpy</span>(str,s3.c_str());			<span class="comment">//123abcdef</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="二-类和对象初步"><a href="#二-类和对象初步" class="headerlink" title="二    类和对象初步"></a>二    类和对象初步</h2><h3 id="2-1-结构化程序设计的不足"><a href="#2-1-结构化程序设计的不足" class="headerlink" title="2.1    结构化程序设计的不足"></a>2.1    结构化程序设计的不足</h3><p>结构化程序设计也称为面向过程的程序设计，过程用函数实现，因此设计时就要考虑如何把功能分割成一个个函数，不同函数互相调用，每个函数实现各自的功能。结构化程序设计难免会使用一些全局变量，这些变量往往被很多函数访问或修改，这样的程序在规模庞大的情况下就难以进行理解和维护。随着软件规模不断扩大，结构化程序设计已经难以适应开发大型软件的需要，面向对象的程序设计便应运而生。</p>
<h3 id="2-2-面向对象程序设计的概念和特点"><a href="#2-2-面向对象程序设计的概念和特点" class="headerlink" title="2.2    面向对象程序设计的概念和特点"></a>2.2    面向对象程序设计的概念和特点</h3><p><strong>面向对象的程序设计的基本特点是抽象、封装、继承、多态。</strong></p>
<p>抽象指把同一类事物的共同特点概括出来。对象的特点包括属性和方法。属性指对象的静态特征，可以用变量表示。方法指对象的行为，可以用函数表示。方法可以对属性进行操作。完成抽象后将数据和操作数据的算法组合在一起，形成形式上的整体，叫做“类”，这个过程称为封装。封装可以把对象的一部分属性和方法隐藏起来，对外界不可见，这样可以减少程序不同部分的耦合度，提高代码扩充修改和复用的效率。继承机制就是在编写一个类时以现有的类作为基础，利用派生达到代码复用的目的 。多态则指的是不同种类的对象具有相同名称的行为，但实现方式有所不同。</p>
<h3 id="2-3-类的定义和使用"><a href="#2-3-类的定义和使用" class="headerlink" title="2.3    类的定义和使用"></a>2.3    类的定义和使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>							//类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:								<span class="comment">//访问范围说明符</span></span><br><span class="line">    <span class="keyword">int</span> a;								<span class="comment">//成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func1</span><span class="params">()</span>							<span class="comment">//成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;								<span class="comment">//成员变量和成员函数的先后次序没有规定</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> b)</span>						<span class="comment">//成员函数可以互相调用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b=Func1();</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>;			<span class="comment">//成员函数可以重载，也可以设定参数默认值</span></span><br><span class="line">&#125;;										<span class="comment">//以“；”结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Myclass::Func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>;	<span class="comment">//成员函数实现可位于类定义以外</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">Myclass m;									<span class="comment">//定义某个类的对象</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-类的示例"><a href="#2-4-类的示例" class="headerlink" title="2.4    类的示例"></a>2.4    类的示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">perimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRectangle::init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w=w_;</span><br><span class="line">    h=h_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRectangle::area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Crectangle::perimeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    return2*(w+h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    CRectangle r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;w&gt;&gt;h;</span><br><span class="line">    r.init(w,h);									<span class="comment">//访问成员函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;It&#x27;s area is &quot;</span>&lt;&lt;r.area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;It&#x27;s perimeter is &quot;</span>&lt;&lt;r.perimeter()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(CRectangle)&lt;&lt;<span class="built_in">endl</span>;						<span class="comment">//对象占用内存空间大小等于各成员变量占用内存空间大小之和，输出8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-访问对象的成员"><a href="#2-5-访问对象的成员" class="headerlink" title="2.5    访问对象的成员"></a>2.5    访问对象的成员</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r1.r2;</span><br><span class="line">CRectangle* p1=&amp;r1;</span><br><span class="line">CRectangle* p2=&amp;r2;</span><br><span class="line">p1-&gt;w=<span class="number">5</span>;</span><br><span class="line">p2-&gt;init(<span class="number">5</span>,<span class="number">4</span>);			<span class="comment">//使用指针-&gt;成员名访问成员</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRectangle&amp; rr=r2;</span><br><span class="line">rr.w=<span class="number">5</span>;</span><br><span class="line">rr.init(<span class="number">5</span>,<span class="number">4</span>);			<span class="comment">//使用引用名.成员名访问对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CRectangle</span>		//用<span class="keyword">struct</span>表示类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没有成员函数的<code>struct</code>还是称为结构。对象可以使用”=“赋值，但不能进行比较运算。</p>
<h3 id="2-6-类成员的可访问范围"><a href="#2-6-类成员的可访问范围" class="headerlink" title="2.6    类成员的可访问范围"></a>2.6    类成员的可访问范围</h3><h4 id="2-6-1-private和public访问范围说明符"><a href="#2-6-1-private和public访问范围说明符" class="headerlink" title="2.6.1    private和public访问范围说明符"></a>2.6.1    private和public访问范围说明符</h4><p>private用来指定私有成员，私有成员只有在该类的成员函数内部才能访问。public用来指定公有成员，公有成员可以在任何地方访问。protected用来指定保护成员。三种关键字次数和顺序没有限制。若成员没有访问范围说明符，对于class类默认为私有成员，对于struct类默认为公有成员。</p>
<h4 id="2-6-2-“隐藏”的作用"><a href="#2-6-2-“隐藏”的作用" class="headerlink" title="2.6.2    “隐藏”的作用"></a>2.6.2    “隐藏”的作用</h4><p>隐藏强制对成员变量的访问通过成员函数进行，如果未来修改了成员变量类型等属性，只需修改成员函数即可。隐藏还可以避免对对象的不正确操作。</p>
<h2 id="三-类和对象进阶"><a href="#三-类和对象进阶" class="headerlink" title="三    类和对象进阶"></a>三    类和对象进阶</h2><h3 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1    构造函数"></a>3.1    构造函数</h3><h4 id="3-1-1-构造函数的概念和作用"><a href="#3-1-1-构造函数的概念和作用" class="headerlink" title="3.1.1    构造函数的概念和作用"></a>3.1.1    构造函数的概念和作用</h4><p>面向对象的程序设计语言倾向于对象一定要经过初始化后使用起来才比较安全。因此引入构造函数的概念，用于对对象进行初始化。一个类可以有多个构造函数，如果没有写构造函数，编译器会自动生成一个默认的无参构造函数，该函数什么都不做。如果编写了构造函数，就不会再生成默认构造函数。对象生成时一定会调用某个构造函数进行初始化，一旦生成就再也不会执行构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c;						<span class="comment">//无参构造函数</span></span><br><span class="line">Complex* p=<span class="keyword">new</span> Complex;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i=<span class="number">0</span>);			<span class="comment">//构造函数是特殊的成员函数，名字和类名一样，不写返回值，可以重载</span></span><br><span class="line">&#125;;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)				<span class="comment">//构造函数1</span></span><br><span class="line">&#123;</span><br><span class="line">    real=r;</span><br><span class="line">    imag=i;</span><br><span class="line">&#125;</span><br><span class="line">Complex::Complex(Complex c1,Complex c2)			<span class="comment">//构造函数2</span></span><br><span class="line">&#123;</span><br><span class="line">    real=c1.real+c2.real;</span><br><span class="line">    imag=c1.imag+c2.imag;</span><br><span class="line">&#125;</span><br><span class="line">Complex c1;									<span class="comment">//错误，没有无参构造函数</span></span><br><span class="line">Complex* pc=<span class="keyword">new</span> Complex;					<span class="comment">//错误</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2</span>)</span></span>;								<span class="comment">//正确，相当于Complex c2(2,0);</span></span><br><span class="line">Complex c3(2,4),c4(3,5);					//正确</span><br><span class="line">Complex* pc2=<span class="keyword">new</span> Complex(<span class="number">3</span>,<span class="number">4</span>);					<span class="comment">//正确</span></span><br><span class="line"><span class="function">Complex <span class="title">c5</span><span class="params">(c3,c4)</span></span>;							<span class="comment">//正确，使用构造函数2</span></span><br><span class="line">Complex c6=<span class="number">5</span>;								<span class="comment">//正确，使用构造函数1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-构造函数在数组中的使用"><a href="#3-1-2-构造函数在数组中的使用" class="headerlink" title="3.1.2    构造函数在数组中的使用"></a>3.1.2    构造函数在数组中的使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest(<span class="keyword">int</span> n)&#123;&#125;			<span class="comment">//构造函数1</span></span><br><span class="line">    CTest(<span class="keyword">int</span> n,<span class="keyword">int</span> m)&#123;&#125;	<span class="comment">//构造函数2</span></span><br><span class="line">    CTest()&#123;&#125;				<span class="comment">//构造函数3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest array1[<span class="number">3</span>]=&#123;<span class="number">1</span>,CTest(<span class="number">1</span>,<span class="number">2</span>)&#125;;					<span class="comment">//1，2，3</span></span><br><span class="line">    CTest array2[<span class="number">3</span>]=&#123;CTest(<span class="number">2</span>,<span class="number">3</span>),CTest(<span class="number">1</span>,<span class="number">2</span>),<span class="number">1</span>&#125;;		<span class="comment">//2，2，1</span></span><br><span class="line">    CTest* pArray[<span class="number">3</span>]=&#123;<span class="keyword">new</span> CTest(<span class="number">4</span>),<span class="keyword">new</span> CTest(<span class="number">1</span>,<span class="number">2</span>)&#125;;		<span class="comment">//1，2，只生成了两个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-复制构造函数"><a href="#3-1-3-复制构造函数" class="headerlink" title="3.1.3    复制构造函数"></a>3.1.3    复制构造函数</h4><h5 id="1-复制构造函数的概念"><a href="#1-复制构造函数的概念" class="headerlink" title="1.复制构造函数的概念"></a>1.复制构造函数的概念</h5><p>复制构造函数是构造函数的一种，它只有一个该类的引用作为参数。引用可以是const引用，也可以是非const引用，一般使用前者。默认构造函数不一定存在，但复制构造函数总是存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;		<span class="comment">//用复制构造函数初始化c2</span></span><br></pre></td></tr></table></figure>
<p>构造函数不能以本类的对象作为唯一参数。</p>
<h5 id="2-复制构造函数被调用的三种情况"><a href="#2-复制构造函数被调用的三种情况" class="headerlink" title="2.复制构造函数被调用的三种情况"></a>2.复制构造函数被调用的三种情况</h5><ul>
<li>用一个对象初始化同类的另一个对象</li>
<li>作为形参的对象用复制构造函数初始化，复制构造函数的参数就是调用函数时的实参。</li>
<li>作为函数返回值的对象用复制构造函数初始化，复制构造函数的参数就是return语句返回的对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2=c1;		<span class="comment">//只有初始化语句才能调用复制构造函数</span></span><br><span class="line">c2=c1;				<span class="comment">//赋值语句不能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(A&amp; a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">(A a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function">A <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    Func1(a);		<span class="comment">//调用复制构造函数</span></span><br><span class="line">    Func2();		<span class="comment">//调用复制构造函数</span></span><br><span class="line">    Func3(a);		<span class="comment">//通过引用避免了复制构造函数，同时保证实参的值不会改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-4-类型转换构造函数"><a href="#3-1-4-类型转换构造函数" class="headerlink" title="3.1.4    类型转换构造函数"></a>3.1.4    类型转换构造函数</h4><p>除复制构造函数外，只有一个参数的构造函数称为类型转换构造函数，这样的构造函数能起到自动类型转换的作用。类型转换构造函数可以在初始化语句和赋值语句被调用。处理赋值语句时，编译器往往会把在等号右侧生成一个临时对象，再赋值给等号左侧。</p>
<h3 id="3-2-析构函数"><a href="#3-2-析构函数" class="headerlink" title="3.2    析构函数"></a>3.2    析构函数</h3><p>析构函数用于对象消亡前的善后工作，在对象消亡时自动调用。例如在析构函数中调用delete语句即可确保对象运行时动态分配的内存空间被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~Cdemo()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDemo <span class="built_in">array</span>[<span class="number">2</span>];			<span class="comment">//构造函数调用2次</span></span><br><span class="line">    CDemo* pTest=<span class="keyword">new</span> CDemo;	<span class="comment">//构造函数调用</span></span><br><span class="line">    <span class="keyword">delete</span> pTest;			<span class="comment">//析构函数调用</span></span><br><span class="line">    pTest=<span class="keyword">new</span> CDemo[<span class="number">2</span>];		<span class="comment">//构造函数调用2次</span></span><br><span class="line">    <span class="keyword">delete</span> []pTest;			<span class="comment">//析构函数调用2次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;				<span class="comment">//析构函数调用2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数对象和作为函数返回值的对象消亡时也会引发析构函数调用。</p>
<h3 id="3-3-构造函数、析构函数和变量的生存期"><a href="#3-3-构造函数、析构函数和变量的生存期" class="headerlink" title="3.3    构造函数、析构函数和变量的生存期"></a>3.3    构造函数、析构函数和变量的生存期</h3><p>全局对象在进入main函数前形成，直到程序结束消亡。临时对象在语句执行完毕后消亡，局部对象在初始化时生成，在最近的大括号处消亡。含static关键字的静态局部对象相当于全局对象。</p>
<h3 id="3-4-静态成员变量和静态成员函数"><a href="#3-4-静态成员变量和静态成员函数" class="headerlink" title="3.4    静态成员变量和静态成员函数"></a>3.4    静态成员变量和静态成员函数</h3><p>静态成员变量和静态成员函数加了<code>static</code>关键字，静态成员变量被所有同类对象共享，静态成员函数并不具体作用在某个对象上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> w, h;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> totalArea;			<span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> totalNumber;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span>		<span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;								<span class="comment">//静态成员函数不能访问非静态成员变量，也不能调用非静态成员函数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; totalNumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; totalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CRectangle(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span><br><span class="line">	&#123;</span><br><span class="line">		w = w_;</span><br><span class="line">		h = h_;</span><br><span class="line">		totalNumber++;</span><br><span class="line">		totalArea += w * h;</span><br><span class="line">	&#125;</span><br><span class="line">	CRectangle(CRectangle&amp; r)		<span class="comment">//有些对象用复制构造函数初始化，需要编写专门的复制构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		totalNumber++;</span><br><span class="line">		totalArea += r.w * r.h;</span><br><span class="line">		w = r.w;</span><br><span class="line">		h = r.h;</span><br><span class="line">	&#125;</span><br><span class="line">	~CRectangle()</span><br><span class="line">	&#123;</span><br><span class="line">		totalNumber--;</span><br><span class="line">		totalArea -= w * h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> CRectangle::totalArea = <span class="number">0</span>;			<span class="comment">//必须对静态成员变量做声明或初始化</span></span><br><span class="line"><span class="keyword">int</span> CRectangle::totalNumber = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRectangle r1(3, 3), r2(2, 2);</span><br><span class="line">	CRectangle::PrintTotal();</span><br><span class="line">	r1.PrintTotal();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-常量对象和常量成员函数"><a href="#3-5-常量对象和常量成员函数" class="headerlink" title="3.5    常量对象和常量成员函数"></a>3.5    常量对象和常量成员函数</h3><p>定义时加<code>const</code> 的对象和成员函数称为常量对象和常量成员函数，常量对象初始化后就再也不被改变，常量对象不能调用普通成员函数，但可以调用常量成员函数，常量成员函数不会修改任何非静态成员变量的值，也不允许调用其他非常量成员函数，但静态成员函数除外。两个名字和参数表不同的一个带const一个不带的函数算重载。如果一个成员函数没有调用非常量成员函数也没有修改成员变量，那么应写成常量成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest()&#123;n=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> n;&#125;			<span class="comment">//常量成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*n;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CTest o1;							<span class="comment">//常量对象</span></span><br><span class="line">    CTest o2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;o1.GetValue()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;o2.GetValue();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-成员对象和封闭类"><a href="#3-6-成员对象和封闭类" class="headerlink" title="3.6    成员对象和封闭类"></a>3.6    成员对象和封闭类</h3><h4 id="3-6-1-封闭类构造函数的初始化列表"><a href="#3-6-1-封闭类构造函数的初始化列表" class="headerlink" title="3.6.1    封闭类构造函数的初始化列表"></a>3.6.1    封闭类构造函数的初始化列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTyre(<span class="keyword">int</span> r,<span class="keyword">int</span> w):radius(r),width(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>			//包含成员对象的类称为封闭类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    Ctyre tyre;		<span class="comment">//成员对象</span></span><br><span class="line">    CEngine engine;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar(<span class="keyword">int</span> p,<span class="keyword">int</span> tr,<span class="keyword">int</span> tw):price(p),tyre(tr,tw)&#123;&#125;	<span class="comment">//使用初始化列表编写构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封闭类对象生成时先执行所有成员对象的构造函数，在执行封闭类构造函数。封闭类对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数。</p>
<h4 id="3-6-2-封闭类的复制构造函数"><a href="#3-6-2-封闭类的复制构造函数" class="headerlink" title="3.6.2    封闭类的复制构造函数"></a>3.6.2    封闭类的复制构造函数</h4><p>封闭类对象如果使用默认复制构造函数初始化，其成员对象也会用复制构造函数初始化。</p>
<h3 id="3-7-const成员和引用成员"><a href="#3-7-const成员和引用成员" class="headerlink" title="3.7    const成员和引用成员"></a>3.7    const成员和引用成员</h3><p>常量成员变量和引用成员变量必须在构造函数初始化列表进行初始化，常量成员变量的值一旦初始化就不能改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> num; <span class="comment">//常量型成员变量</span></span><br><span class="line">		<span class="keyword">int</span> &amp; ref;     <span class="comment">//引用型成员变量</span></span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		CDemo( <span class="keyword">int</span> n):num(n),ref(f),value(<span class="number">4</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(CDemo) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-友元"><a href="#3-8-友元" class="headerlink" title="3.8    友元"></a>3.8    友元</h3><h4 id="3-8-1-友元函数"><a href="#3-8-1-友元函数" class="headerlink" title="3.8.1    友元函数"></a>3.8.1    友元函数</h4><p>定义类时可以把一些函数（包括全局函数和其他类的成员函数）声明为友元，友元函数可以访问该类的私有成员。不能把其他类的私有成员函数声明为友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span>							<span class="comment">//提前声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[],<span class="keyword">int</span> total)</span></span>;		<span class="comment">//全局函数为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;				<span class="comment">//其他类成员函数为友元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[],<span class="keyword">int</span> total)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-2-友元类"><a href="#3-8-2-友元类" class="headerlink" title="3.8.2    友元类"></a>3.8.2    友元类</h4><p>定义类时将某个其他类声明为自己的友元，该类的所有成员函数就能访问自己对象的私有成员。友元关系不能传递。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	nt price;</span><br><span class="line">	riend <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span> <span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	CCar myCar;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span>  <span class="comment">//改装汽车</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		myCar.price += <span class="number">1000</span>;<span class="comment">//因CDriver是CCar的友元类，故此处可以访问其私有成员</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-this指针"><a href="#3-9-this指针" class="headerlink" title="3.9    this指针"></a>3.9    this指针</h3><h4 id="3-9-1-C-程序到C程序的翻译"><a href="#3-9-1-C-程序到C程序的翻译" class="headerlink" title="3.9.1    C++程序到C程序的翻译"></a>3.9.1    C++程序到C程序的翻译</h4><p>类被翻译成结构体，对象被翻译成结构变量，成员函数被翻译成全局函数，全局函数比成员函数多一个参数，即指向结构变量的this指针。</p>
<h4 id="3-9-2-this指针的作用"><a href="#3-9-2-this指针的作用" class="headerlink" title="3.9.2    this指针的作用"></a>3.9.2    this指针的作用</h4><p>静态成员函数内部不能使用this指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line">	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) :real(r), imag(i) &#123; &#125;</span><br><span class="line">	<span class="function">Complex <span class="title">AddOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;real++;	<span class="comment">//相当于real++;</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-在多个文件中使用类"><a href="#3-10-在多个文件中使用类" class="headerlink" title="3.10    在多个文件中使用类"></a>3.10    在多个文件中使用类</h3><p>类的定义可以写在一个头文件中。非内联成员函数函数体只能出现在某一.cpp文件中，不能放在头文件。内联成员函数应当写在头文件中。</p>
<h2 id="四-运算符重载"><a href="#四-运算符重载" class="headerlink" title="四    运算符重载"></a>四    运算符重载</h2><h3 id="4-1-运算符重载的概念和原理"><a href="#4-1-运算符重载的概念和原理" class="headerlink" title="4.1    运算符重载的概念和原理"></a>4.1    运算符重载的概念和原理</h3><p>运算符重载即对已有运算符赋予多重含义，使其用于不同类型的数据时产生不同行为。这样运算符可以操作各种类的对象。运算符重载的实质是编写以运算符为名称的函数，包含运算符的表达式会被编译成对运算符函数的调用，操作数成为函数调用的实参，运算的结果是函数的返回值。运算符可以多次重载，可以重载为全局函数，也可以重载为成员函数。一般重载为成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; a,comst Complex&amp; b)</span><br><span class="line">&#123;<span class="comment">//全局函数</span></span><br><span class="line">    <span class="keyword">return</span> Complex(a.real+b.real,a.imag+b.imag);	<span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(comst Complex&amp; c)</span><br><span class="line">&#123;<span class="comment">//成员函数</span></span><br><span class="line">    <span class="keyword">return</span> Complex(real-c.real,imag-c.imag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex a(4,4),b(1,1),c;</span><br><span class="line">    c=a+b;						<span class="comment">//c=operator+(a,b);</span></span><br><span class="line">    c=a-b;						<span class="comment">//c=a.operator-(b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-重载赋值运算符“-”"><a href="#4-2-重载赋值运算符“-”" class="headerlink" title="4.2    重载赋值运算符“=”"></a>4.2    重载赋值运算符“=”</h3><p>赋值运算符只能重载为成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	String() :str(<span class="literal">NULL</span>) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> str; &#125;;<span class="comment">//返回值为const的常量成员函数，成员变量不会在函数内部修改，也不允许调用函数后修改指针指向的内容</span></span><br><span class="line">	String&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line">	~String();</span><br><span class="line">&#125;;</span><br><span class="line">String&amp; String::<span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br><span class="line"><span class="comment">//重载&quot;=&quot;以使得 obj = &quot;hello&quot;能够成立</span></span><br><span class="line">&#123;<span class="comment">//返回值类型为T&amp;能够保留赋值运算符原本的特性</span></span><br><span class="line">	<span class="keyword">if</span> (str)</span><br><span class="line">		<span class="keyword">delete</span>[] str;</span><br><span class="line">	<span class="keyword">if</span> (s) &#123;  <span class="comment">//s不为NULL才会执行拷贝</span></span><br><span class="line">		str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];<span class="comment">//&#x27;\0&#x27;</span></span><br><span class="line">		<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		str = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (str)<span class="comment">//防止错误delete</span></span><br><span class="line">		<span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	String s;</span><br><span class="line">	s = <span class="string">&quot;Good Luck,&quot;</span>; <span class="comment">//等价于 s.operator=(&quot;Good Luck,&quot;);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// String s2 = &quot;hello!&quot;;   //这条语句要是不注释掉就会出错，此语句是初始化语句</span></span><br><span class="line">	s = <span class="string">&quot;Shenzhou 8!&quot;</span>; <span class="comment">//等价于 s.operator=(&quot;Shenzhou 8!&quot;);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-浅拷贝和深拷贝"><a href="#4-3-浅拷贝和深拷贝" class="headerlink" title="4.3    浅拷贝和深拷贝"></a>4.3    浅拷贝和深拷贝</h3><p>执行逐个字节的拷贝称为浅拷贝，将一个对象中指针成员变量指向的内容复制到另一个对象中指针成员变量指向的地方的拷贝称为深拷贝。浅拷贝会导致存储空间不被释放或重复释放，引发严重的内存错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==s.str)<span class="comment">//防止自己复制自己时开辟存储空间</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(str)</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">    <span class="keyword">if</span>(s.str)</span><br><span class="line">    &#123;</span><br><span class="line">        str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">String::String(String&amp; s)</span><br><span class="line">&#123;<span class="comment">//复制构造函数同样需要深拷贝</span></span><br><span class="line">   <span class="keyword">if</span>(s.str)</span><br><span class="line">    &#123;</span><br><span class="line">        str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-运算符重载为友元函数"><a href="#4-4-运算符重载为友元函数" class="headerlink" title="4.4    运算符重载为友元函数"></a>4.4    运算符重载为友元函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r);<span class="comment">//复数加实数</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r,<span class="keyword">const</span> Complex&amp; c);<span class="comment">//实数加复数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-长度可变的整型数组类"><a href="#4-5-长度可变的整型数组类" class="headerlink" title="4.5    长度可变的整型数组类"></a>4.5    长度可变的整型数组类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span>* pit;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CArray(<span class="keyword">int</span> s=<span class="number">0</span>);					<span class="comment">//s为0时指向NULL，否则动态分配</span></span><br><span class="line">    CArray(CArray&amp; s);					<span class="comment">//使用memcpy()</span></span><br><span class="line">    ~CArray();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> v)</span></span>;				<span class="comment">//重新分配空间并复制原数组内容和加入新元素</span></span><br><span class="line">    CArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CArray&amp; a);		<span class="comment">//考虑a=a，a数组为空，原有空间够大等情况</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)				<span class="comment">//重载[]运算符，能作为左值使用的函数应返回引用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-重载流插入运算符和流提取运算符"><a href="#4-6-重载流插入运算符和流提取运算符" class="headerlink" title="4.6    重载流插入运算符和流提取运算符"></a>4.6    重载流插入运算符和流提取运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) :real(r), imag(i) &#123; &#125;;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Complex&amp; c);</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Complex&amp; c)<span class="comment">//ostream类复制构造函数是私有的，因此os只能是引用</span></span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; c.real &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i&quot;</span>; <span class="comment">//以&quot;a+bi&quot;的形式输出</span></span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	is &gt;&gt; s;  <span class="comment">//将&quot;a+bi&quot;作为字符串读入, &quot;a+bi&quot; 中间不能有空格</span></span><br><span class="line">	<span class="keyword">int</span> pos = s.find(<span class="string">&quot;+&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">string</span> sTmp = s.substr(<span class="number">0</span>, pos); <span class="comment">//分离出代表实部的字符串</span></span><br><span class="line">	c.real = atof(sTmp.c_str());<span class="comment">//atof库函数能将const char*指针指向的内容转换成 float</span></span><br><span class="line">	sTmp = s.substr(pos + <span class="number">1</span>, s.length() - pos - <span class="number">2</span>);   <span class="comment">//分离出代表虚部的字符串</span></span><br><span class="line">	c.imag = atof(sTmp.c_str());</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Complex c;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; c &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; n;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-重载强制类型转换运算符"><a href="#4-7-重载强制类型转换运算符" class="headerlink" title="4.7    重载强制类型转换运算符"></a>4.7    重载强制类型转换运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r=<span class="number">0</span>;<span class="keyword">double</span> i=<span class="number">0</span>):real(r),imag(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> real;&#125;					<span class="comment">//强制类型转换运算符只能重载为成员函数，且无需指定返回值类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-重载自增自减运算符"><a href="#4-8-重载自增自减运算符" class="headerlink" title="4.8    重载自增自减运算符"></a>4.8    重载自增自减运算符</h3><p>自增自减运算符有前置后置之分，为了区分两种表达式，重载前置时使用正常的重载函数，重载后置时使用增加一个无用int类型形参的重载函数。前置运算符返回值是操作数的引用，后置运算符的返回值是操作数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CDemo(<span class="keyword">int</span> i = <span class="number">0</span>) :n(i) &#123; &#125;</span><br><span class="line">	CDemo&amp; <span class="keyword">operator</span>++();      <span class="comment">//用于前置形式</span></span><br><span class="line">	CDemo <span class="keyword">operator</span>++(<span class="keyword">int</span>);   <span class="comment">//用于后置形式</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">	<span class="keyword">friend</span> CDemo&amp; <span class="keyword">operator</span>--(CDemo&amp;);</span><br><span class="line">	<span class="keyword">friend</span> CDemo <span class="keyword">operator</span>--(CDemo&amp;, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CDemo&amp; CDemo::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;<span class="comment">//前置 ++</span></span><br><span class="line">	n++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span>++(<span class="keyword">int</span> k)</span><br><span class="line">&#123; <span class="comment">//后置 ++</span></span><br><span class="line">	<span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//记录修改前的对象</span></span><br><span class="line">	n++;</span><br><span class="line">	<span class="keyword">return</span> tmp; <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br><span class="line">CDemo&amp; <span class="keyword">operator</span>--(CDemo&amp; d)</span><br><span class="line">&#123;<span class="comment">//前置--</span></span><br><span class="line">	d.n--;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">CDemo <span class="keyword">operator</span>--(CDemo&amp; d, <span class="keyword">int</span>)</span><br><span class="line">&#123;<span class="comment">//后置--</span></span><br><span class="line">	<span class="function">CDemo <span class="title">tmp</span><span class="params">(d)</span></span>;</span><br><span class="line">	d.n--;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CDemo <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (d++) &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="comment">//等价于 d.operator++(0);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (++d) &lt;&lt; <span class="string">&quot;,&quot;</span>;   <span class="comment">//等价于 d.operator++();</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (d--) &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="comment">//等价于 operator-(d,0);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (--d) &lt;&lt; <span class="string">&quot;,&quot;</span>;   <span class="comment">//等价于 operator-(d);</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-9-运算符重载的注意事项"><a href="#4-9-运算符重载的注意事项" class="headerlink" title="4.9    运算符重载的注意事项"></a>4.9    运算符重载的注意事项</h3><ul>
<li>重载后运算符的含义要符合原有习惯。</li>
<li>重载不改变运算符优先级。</li>
<li><code>.</code>、<code>*</code>、<code>::</code>、<code>?:</code>、<code>sizeof</code>不能被重载。</li>
<li><code>()</code>、<code>[]</code>、<code>-&gt;</code>、<code>=</code>只能重载为成员函数。</li>
</ul>
<h2 id="五-继承和派生"><a href="#五-继承和派生" class="headerlink" title="五    继承和派生"></a>五    继承和派生</h2><h3 id="5-1-继承和派生的概念"><a href="#5-1-继承和派生的概念" class="headerlink" title="5.1    继承和派生的概念"></a>5.1    继承和派生的概念</h3><h4 id="5-1-1-基本概念"><a href="#5-1-1-基本概念" class="headerlink" title="5.1.1    基本概念"></a>5.1.1    基本概念</h4><p>当定义某个新类时，如果这个类和拥有某个已有类的全部特点，此外还有这个类没有的特点，那么可以把原有类作为基类，新类作为原有类的派生类。即基类派生了派生类，派生类继承了基类。基类的所有成员自动成为派生类的成员。派生类的成员函数不能访问基类的私有成员。继承方式可以是公有继承、私有继承和保护继承。一般使用公有继承。派生类对象占用内存大小等于基类对象占用内存空间大小加上派生类全体成员变量占用内存大小之和。派生类对象包含基类对象，而且基类对象存储位置在派生类对象新增的成员变量之前。</p>
<h4 id="5-1-2-程序实例"><a href="#5-1-2-程序实例" class="headerlink" title="5.1.2    程序实例"></a>5.1.2    程序实例</h4><p>在基类和派生类有同名成员的情况下，在派生类的函数中或通过派生类对象访问同名成员，默认访问派生类成员。如需访问基类同名成员则使用<code>基类名::函数名()</code>。一般不在派生类中定义和基类同名的成员变量。</p>
<h3 id="5-2-正确处理类的复合关系和继承关系"><a href="#5-2-正确处理类的复合关系和继承关系" class="headerlink" title="5.2    正确处理类的复合关系和继承关系"></a>5.2    正确处理类的复合关系和继承关系</h3><p>复合关系表现为封闭类，数学上可以称为属于。继承关系表现为派生类，数学上可以称为包含。一个类中有另一个类的指针的情况可以称为知道关系。</p>
<h3 id="5-3-protected访问范围说明符"><a href="#5-3-protected访问范围说明符" class="headerlink" title="5.3    protected访问范围说明符"></a>5.3    protected访问范围说明符</h3><p>基类的保护成员可以在派生类的成员函数中被访问。派生类的成员函数只能访问所作用的那个对象的基类保护成员，不能访问其他对象的基类保护成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nPrivate;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> nPublic;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> nProtected;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span><span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AccessBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nPublic=<span class="number">1</span>;</span><br><span class="line">        nPrivate=<span class="number">1</span>;			<span class="comment">//不能访问私有成员</span></span><br><span class="line">        nProtected=<span class="number">1</span>;</span><br><span class="line">        CBase f;</span><br><span class="line">        f.nProtected=<span class="number">1</span>;		<span class="comment">//不能访问其他对象的保护成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-派生类的构造函数和析构函数"><a href="#5-4-派生类的构造函数和析构函数" class="headerlink" title="5.4    派生类的构造函数和析构函数"></a>5.4    派生类的构造函数和析构函数</h3><p>任何生成派生类对象的语句都要说明其包含的基类对象是如何初始化的，默认使用无参构造函数初始化，如果基类没有无参构造函数，则编译错误。派生类对象生成时总是先执行基类的构造函数再执行派生类的构造函数，派生类对象消亡时总是先执行派生类的析构函数再执行基类的析构函数。如果一个派生类对象使用默认复制构造函数初始化，那么它的基类对象也要使用基类的复制构造函数初始化。</p>
<h3 id="5-5-多层次的派生"><a href="#5-5-多层次的派生" class="headerlink" title="5.5    多层次的派生"></a>5.5    多层次的派生</h3><p>对于派生的派生，有直接基类和间接基类之分。定义派生类时只写直接基类，派生类自动继承所有间接基类。派生类的成员包括自己定义的成员、直接基类定义的成员以及所有间接基类的全部成员。</p>
<h3 id="5-6-包含成员对象的派生类"><a href="#5-6-包含成员对象的派生类" class="headerlink" title="5.6    包含成员对象的派生类"></a>5.6    包含成员对象的派生类</h3><p>在派生类也是封闭类的情况下，构造函数调用顺序为自上至下所有基类、成员对象、自身，析构函数调用顺序为自身、成员对象、自下至上所有基类。</p>
<h3 id="5-7-公有派生的赋值兼容规则"><a href="#5-7-公有派生的赋值兼容规则" class="headerlink" title="5.7    公有派生的赋值兼容规则"></a>5.7    公有派生的赋值兼容规则</h3><ul>
<li>派生类对象可以赋值给基类对象</li>
<li>派生类对象可以初始化基类引用</li>
<li>派生类指针可以赋值给基类指针</li>
</ul>
<p>此规则只有public派生才成立，private和protected派生不成立。</p>
<h3 id="5-8-基类和派生类指针的互相转换"><a href="#5-8-基类和派生类指针的互相转换" class="headerlink" title="5.8    基类和派生类指针的互相转换"></a>5.8    基类和派生类指针的互相转换</h3><p>即使基类指针指向派生类对象，也不能通过基类指针访问基类没有而派生类有的成员。基类指针指向派生类对象时仍然调用基类同名成员函数。基类指针不能赋值给派生类指针，除非经过强制类型转换。基类引用也可以强制转换为派生类引用。强制类型转换会导致不可预测的安全隐患。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CBase(<span class="keyword">int</span> i) :n(i) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CBase:n=&quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span><span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	CDerived(<span class="keyword">int</span> i) :CBase(i), v(<span class="number">2</span> * i) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CDerived:n=&quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CDerived:v=&quot;</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CDerived <span class="title">objDerived</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="function">CBase <span class="title">objBase</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	CBase* pBase = &amp;objDerived; <span class="comment">// 使得基类指针指向派生类对象</span></span><br><span class="line">	<span class="comment">//pBase-&gt;Func(); //错, CBase类没有Func()成员函数</span></span><br><span class="line">	<span class="comment">//pBase-&gt;v = 5;  //错 CBase类没有v成员变量</span></span><br><span class="line">	pBase-&gt;Print();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//CDerived * pDerived = &amp; objBase; //错，不能将基类指针赋值给派生类指针</span></span><br><span class="line">	CDerived* pDerived = (CDerived*)(&amp;objBase);</span><br><span class="line">	pDerived-&gt;Print();  <span class="comment">//慎用，可能出现不可预期的错误</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	objDerived.Print();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	pDerived-&gt;v = <span class="number">128</span>;  <span class="comment">//往别人的空间里写入数据，会有问题</span></span><br><span class="line">	objDerived.Print();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-9-私有派生和保护派生"><a href="#5-9-私有派生和保护派生" class="headerlink" title="5.9    私有派生和保护派生"></a>5.9    私有派生和保护派生</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>公有派生</th>
<th>私有派生</th>
<th>保护派生</th>
</tr>
</thead>
<tbody>
<tr>
<td>私有成员</td>
<td>不可访问</td>
<td>不可访问</td>
<td>不可访问</td>
</tr>
<tr>
<td>保护成员</td>
<td>保护</td>
<td>私有</td>
<td>保护</td>
</tr>
<tr>
<td>公有成员</td>
<td>公有</td>
<td>私有</td>
<td>保护</td>
</tr>
</tbody>
</table>
</div>
<p>一般情况下都应使用公有派生。</p>
<h3 id="5-10-派生类和赋值运算符"><a href="#5-10-派生类和赋值运算符" class="headerlink" title="5.10    派生类和赋值运算符"></a>5.10    派生类和赋值运算符</h3><p>如果基类重载了赋值运算符而派生类没有，那么派生类互相赋值或是给基类对象赋值时基类部分调用被基类重载的赋值运算符。</p>
<h2 id="六-多态与虚函数"><a href="#六-多态与虚函数" class="headerlink" title="六    多态与虚函数"></a>六    多态与虚函数</h2><h3 id="6-1-多态的基本概念"><a href="#6-1-多态的基本概念" class="headerlink" title="6.1    多态的基本概念"></a>6.1    多态的基本概念</h3><h4 id="6-1-1-通过基类指针实现多态"><a href="#6-1-1-通过基类指针实现多态" class="headerlink" title="6.1.1    通过基类指针实现多态"></a>6.1.1    通过基类指针实现多态</h4><p>多态指的是同一名字的事物可以完成不同的功能，包括编译时的多态和运行时的多态。编译时的多态指函数的重载，运行时的多态则和虚函数有关。虚函数在通过基类指针调用时并不确定执行基类或派生类的同名函数，而是以运行时所指向的对象来判断。虚函数在声明时添加<code>virtual</code>关键字，且只能在声明时使用。静态成员函数不能是虚函数。包含虚函数的类称为多态类。</p>
<h4 id="6-1-2-通过基类引用实现多态"><a href="#6-1-2-通过基类引用实现多态" class="headerlink" title="6.1.2    通过基类引用实现多态"></a>6.1.2    通过基类引用实现多态</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;D&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">(A&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r.Print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;B b;C c;D d;</span><br><span class="line">    A* pa=&amp;a;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;b;			<span class="comment">//指针的多态</span></span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;c;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;d;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    PrintInfo(a);		<span class="comment">//引用的多态</span></span><br><span class="line">    PrintInfo(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-多态的作用"><a href="#6-2-多态的作用" class="headerlink" title="6.2    多态的作用"></a>6.2    多态的作用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShape</span>  //基类：形体类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span> </span>&#123; &#125;;  <span class="comment">//求面积</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span> </span>&#123; &#125;; <span class="comment">//显示信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span> :</span><span class="keyword">public</span> CShape  <span class="comment">//派生类：矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> w, h;     <span class="comment">//宽和高</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCircle</span> :</span><span class="keyword">public</span> CShape  <span class="comment">//派生类：圆类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> r;      <span class="comment">//半径</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTriangle</span> :</span><span class="keyword">public</span> CShape <span class="comment">//派生类：三角形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a, b, c;      <span class="comment">//三边长</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CRectangle::Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRectangle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CCircle::Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CCircle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CTriangle::Area</span><span class="params">()</span> </span>&#123;   <span class="comment">//根据海伦公式计算三角形面积</span></span><br><span class="line">	<span class="keyword">double</span> p = (a + b + c) / <span class="number">2.0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(p * (p - a) * (p - b) * (p - c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTriangle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Triangle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">CShape* pShapes[<span class="number">100</span>]; <span class="comment">//用来存放各种几何形体，假设不超过100个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* s1, <span class="keyword">const</span> <span class="keyword">void</span>* s2)</span>  <span class="comment">//定义排序规则的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CShape** p1 = (CShape**)s1; <span class="comment">//s1是指向指针的指针,其指向的指针为CShape* 类型</span></span><br><span class="line">	CShape** p2 = (CShape**)s2;</span><br><span class="line">	<span class="keyword">double</span> a1 = (*p1)-&gt;Area(); <span class="comment">//p1指向几何形体对象的指针, *p1才指向几何形体对象</span></span><br><span class="line">	<span class="keyword">double</span> a2 = (*p2)-&gt;Area();</span><br><span class="line">	<span class="keyword">if</span> (a1 &lt; a2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//面积小的排前面</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a2 &lt; a1)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i; <span class="keyword">int</span> n;</span><br><span class="line">	CRectangle* pr; CCircle* pc; CTriangle* pt;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">		<span class="keyword">switch</span> (c) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="comment">//矩形</span></span><br><span class="line">			pr = <span class="keyword">new</span> CRectangle();</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; pr-&gt;w &gt;&gt; pr-&gt;h;</span><br><span class="line">			pShapes[i] = pr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">//圆</span></span><br><span class="line">			pc = <span class="keyword">new</span> CCircle();</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; pc-&gt;r;</span><br><span class="line">			pShapes[i] = pc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">//三角形</span></span><br><span class="line">			pt = <span class="keyword">new</span> CTriangle();</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; pt-&gt;a &gt;&gt; pt-&gt;b &gt;&gt; pt-&gt;c;</span><br><span class="line">			pShapes[i] = pt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	qsort(pShapes, n, <span class="keyword">sizeof</span>(Cshape*), MyCompare);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		pShapes[i]-&gt;PrintInfo();</span><br><span class="line">		<span class="keyword">delete</span> pShapes[i]; <span class="comment">//释放空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-多态的实现原理"><a href="#6-3-多态的实现原理" class="headerlink" title="6.3    多态的实现原理"></a>6.3    多态的实现原理</h3><p>有虚函数的类占用的存储空间比没有虚函数的多8个字节，位于存储空间的最前端，存放了虚函数表的地址。编译时不会确定要调用哪个函数，运行时先取出指针所指位置的虚函数表的地址，再通过虚函数表的地址找到虚函数表，在虚函数表中查找对应的虚函数的地址，最后根据找到的虚函数的地址调用虚函数。多态能够提高程序的开发效率，但也增加了程序运行时的开销。</p>
<h3 id="6-4-关于多态的注意事项"><a href="#6-4-关于多态的注意事项" class="headerlink" title="6.4    关于多态的注意事项"></a>6.4    关于多态的注意事项</h3><h4 id="6-4-1-在成员函数中调用虚函数"><a href="#6-4-1-在成员函数中调用虚函数" class="headerlink" title="6.4.1    在成员函数中调用虚函数"></a>6.4.1    在成员函数中调用虚函数</h4><p>在成员函数（静态成员函数、构造函数和析构函数除外）中调用其它成员虚函数的语句是多态的。</p>
<h4 id="6-4-2-在构造函数和析构函数中调用虚函数"><a href="#6-4-2-在构造函数和析构函数中调用虚函数" class="headerlink" title="6.4.2    在构造函数和析构函数中调用虚函数"></a>6.4.2    在构造函数和析构函数中调用虚函数</h4><p>在构造函数和析构函数中调用虚函数不是多态，如果本类有该函数则调用本类函数，否则依次看直接基类和间接基类的函数。</p>
<h4 id="6-4-3-注意区分多态和非多态的情况"><a href="#6-4-3-注意区分多态和非多态的情况" class="headerlink" title="6.4.3    注意区分多态和非多态的情况"></a>6.4.3    注意区分多态和非多态的情况</h4><p>只有成员函数是虚函数时才是多态。只要基类中某个函数被声明为虚函数，则派生类中同名同参数表的成员函数也自动成为虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;  <span class="comment">//func2自动成为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B  <span class="comment">// C以A为间接基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;; <span class="comment">//func1自动成为虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;; <span class="comment">//func2自动成为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C obj;</span><br><span class="line">	A* pa = &amp;obj;</span><br><span class="line">	B* pb = &amp;obj;</span><br><span class="line">	pa-&gt;func2();  <span class="comment">//多态</span></span><br><span class="line">	pa-&gt;func1();  <span class="comment">//不是多态</span></span><br><span class="line">	pb-&gt;func1();  <span class="comment">//多态</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-虚析构函数"><a href="#6-5-虚析构函数" class="headerlink" title="6.5    虚析构函数"></a>6.5    虚析构函数</h3><p>为了让动态分配的内存释放时能够根据指针指向的对象调用对应的析构函数，需要将基类的析构函数声明为虚函数。一个类如果定义了虚函数，则最好将析构函数也定义成虚函数。基类析构函数是虚函数，派生类析构函数自动成为虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShape</span>  //基类：形体类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~CShape()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-纯虚函数和抽象类"><a href="#6-6-纯虚函数和抽象类" class="headerlink" title="6.6    纯虚函数和抽象类"></a>6.6    纯虚函数和抽象类</h3><p>纯虚函数是没有函数体的函数，包含纯虚函数的类称为抽象类。抽象类不能生成独立的对象，但可以定义抽象类的指针和引用。抽象类的派生类当且仅当实现了所有纯虚函数才成为非抽象类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>=<span class="number">0</span>;		<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七-输入输出流"><a href="#七-输入输出流" class="headerlink" title="七    输入输出流"></a>七    输入输出流</h2><h3 id="7-1-流类"><a href="#7-1-流类" class="headerlink" title="7.1    流类"></a>7.1    流类</h3><p>流是数据从一个地方传送到另一个地方的抽象。C++把用于数据输入输出的类称为流类。<code>ios</code>是抽象的基类，派生出<code>istream</code>和<code>ostream</code>，这两个类又共同派生出<code>iostream</code>。为避免多继承的二义性，从<code>ios</code>派生出<code>istream</code>和<code>ostream</code>时使用了虚继承。</p>
<h3 id="7-2-标准流对象"><a href="#7-2-标准流对象" class="headerlink" title="7.2    标准流对象"></a>7.2    标准流对象</h3><p><code>cin</code>对应标准输入流，用于从键盘读取数据，可重定向为从文件读取数据。</p>
<p><code>cout</code>对应标准输出流，用于向屏幕输出数据，可重定向为从文件写入数据。</p>
<p><code>cerr</code>对应标准错误输出流，不使用缓冲区，不能被重定向。 </p>
<p><code>clog</code>对应标准错误输出流，使用缓冲区，不能被重定向。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	freopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);  <span class="comment">//将标准输出重定向到 test.txt文件</span></span><br><span class="line">	<span class="keyword">if</span> (y == <span class="number">0</span>)  <span class="comment">//除数为0则输出错误信息</span></span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x / y;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-使用流操纵算子控制输出格式"><a href="#7-3-使用流操纵算子控制输出格式" class="headerlink" title="7.3    使用流操纵算子控制输出格式"></a>7.3    使用流操纵算子控制输出格式</h3><p>使用流操纵算子（又叫格式控制符）需要包含<code>iomanip</code>头文件。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>流操纵算子</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hex</code></td>
<td>十六进制输出整数</td>
</tr>
<tr>
<td><code>oct</code></td>
<td>八进制输出整数</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>普通小数形式输出浮点数</td>
</tr>
<tr>
<td><code>scientific</code></td>
<td>科学计数法输出浮点数</td>
</tr>
<tr>
<td><code>left</code></td>
<td>左对齐，宽度不足时填充字符添加到左边</td>
</tr>
<tr>
<td><code>setbase(b)</code></td>
<td>设置输出整数时的进制，为8、10或16</td>
</tr>
<tr>
<td><code>setw(w)</code></td>
<td>输出宽度或读入w个字符</td>
</tr>
<tr>
<td><code>setfill(c)</code></td>
<td>输出宽度不足时用c填充</td>
</tr>
<tr>
<td><code>setprecision(n)</code></td>
<td>设置浮点数输出精度为n</td>
</tr>
<tr>
<td><code>setiosflags(格式)</code></td>
<td>将某个格式标志置为1</td>
</tr>
<tr>
<td><code>reseriosflags(格式)</code></td>
<td>将某个格式标志置为0</td>
</tr>
<tr>
<td><code>boolapha</code></td>
<td>true和false输出为字符串</td>
</tr>
<tr>
<td><code>showbase</code></td>
<td>输出进制前缀</td>
</tr>
<tr>
<td><code>showpoint</code></td>
<td>总是输出小数点</td>
</tr>
<tr>
<td><code>showpos</code></td>
<td>非负数显示+</td>
</tr>
<tr>
<td><code>noskipws</code></td>
<td>输入时不跳过空白字符</td>
</tr>
<tr>
<td><code>uppercase</code></td>
<td>使用大写字母输出十六进制、前缀和科学计数法</td>
</tr>
<tr>
<td><code>internal</code></td>
<td>符号左对齐，数值右对齐</td>
</tr>
</tbody>
</table>
</div>
<p>流操纵算子影响整个语句，但setw算子只影响下一次输出或输入。</p>
<h3 id="7-4-调用cout的成员函数"><a href="#7-4-调用cout的成员函数" class="headerlink" title="7.4    调用cout的成员函数"></a>7.4    调用cout的成员函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::scientific);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">12.23</span>&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//cout&lt;&lt;setiosflags(ios::scientific)&lt;&lt;setprecision(8)&lt;&lt;12.23&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.put(<span class="number">98</span>).put(<span class="string">&#x27;c&#x27;</span>).put(<span class="string">&#x27;z&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="7-5-cin的高级用法"><a href="#7-5-cin的高级用法" class="headerlink" title="7.5    cin的高级用法"></a>7.5    cin的高级用法</h3><h4 id="7-5-1-判断输入结束"><a href="#7-5-1-判断输入结束" class="headerlink" title="7.5.1    判断输入结束"></a>7.5.1    判断输入结束</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxN=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;<span class="comment">//istream类重载了bool运算符，读取到输入结尾或输入错误返回false</span></span><br><span class="line">        <span class="keyword">if</span>(maxN&lt;n)</span><br><span class="line">            maxN=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-5-2-istream类的成员函数"><a href="#7-5-2-istream类的成员函数" class="headerlink" title="7.5.2    istream类的成员函数"></a>7.5.2    istream类的成员函数</h4><h5 id="1-get"><a href="#1-get" class="headerlink" title="1.get"></a>1.get</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;							<span class="comment">//注意c的类型为int，若为char则读入ASCII码为0xFF的字符会导致输入终止</span></span><br><span class="line">    freopen(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(c=<span class="built_in">cin</span>.get()!=EOF)				<span class="comment">//get函数可以正常读入所有字符，EOF是iostream类定义的整型常量，值为-1，表示输入终止</span></span><br><span class="line">        <span class="built_in">cout</span>.put(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-getline"><a href="#2-getline" class="headerlink" title="2.getline"></a>2.getline</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">120</span>;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">cin</span>.getline(szBuf, <span class="number">6</span>))  <span class="comment">//如果输入流中一行字符超过5个，就会出错</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">	<span class="built_in">cin</span>.clear(); <span class="comment">//clear能够清除cin内部的错误标记，使之恢复正常</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-eof"><a href="#3-eof" class="headerlink" title="3.eof"></a>3.eof</h5><p><code>bool eof()</code>判断输入流是否结束，若结束返回<code>true</code>。</p>
<h5 id="4-ignore"><a href="#4-ignore" class="headerlink" title="4.ignore"></a>4.ignore</h5><p><code>istream&amp; ignore(int n=1,int delim=EOF)</code>用于跳过n个字符或delim前所有字符。</p>
<h5 id="5-peek"><a href="#5-peek" class="headerlink" title="5.peek"></a>5.peek</h5><p>此函数返回下一个字符，但不会将该字符从输入流中取走。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> Months[<span class="number">12</span>] = &#123; <span class="string">&quot;Jan&quot;</span>,<span class="string">&quot;Feb&quot;</span>,<span class="string">&quot;Mar&quot;</span>,<span class="string">&quot;Apr&quot;</span>,<span class="string">&quot;May&quot;</span>,<span class="string">&quot;Jun&quot;</span>,<span class="string">&quot;Jul&quot;</span>,<span class="string">&quot;Aug&quot;</span>,</span><br><span class="line">					  <span class="string">&quot;Sep&quot;</span>,<span class="string">&quot;Oct&quot;</span>,<span class="string">&quot;Nov&quot;</span>,<span class="string">&quot;Dec&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = <span class="built_in">cin</span>.peek()) != EOF) &#123; <span class="comment">//取输入流中的第一个字符进行查看</span></span><br><span class="line">		<span class="keyword">int</span> year, month, day;</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123; <span class="comment">//美国日期格式</span></span><br><span class="line">			<span class="built_in">string</span> sMonth;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; sMonth &gt;&gt; day &gt;&gt; year;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)  <span class="comment">//查找月份</span></span><br><span class="line">				<span class="keyword">if</span> (sMonth == Months[i]) &#123;</span><br><span class="line">					month = i + <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//中国日期格式</span></span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; year;</span><br><span class="line">			<span class="built_in">cin</span>.ignore() &gt;&gt; month; <span class="comment">//用ignore跳过 &quot;2011.12.3&quot;中的&#x27;.&#x27;</span></span><br><span class="line">			<span class="built_in">cin</span>.ignore() &gt;&gt; day;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cin</span>.ignore();   <span class="comment">//跳过行末 &#x27;\n&#x27;</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; month;<span class="comment">//设置填充字符&#x27;\0&#x27;，输出宽度2</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; day &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用get和putback配合达到同样的效果。</p>
<h2 id="八-文件操作"><a href="#八-文件操作" class="headerlink" title="八 文件操作"></a>八 文件操作</h2><h3 id="8-1-文件的概念"><a href="#8-1-文件的概念" class="headerlink" title="8.1    文件的概念"></a>8.1    文件的概念</h3><p>所有的文件本质上都是0和1的比特串，这些比特串代表什么内容取决于用怎样的格式读取它们。</p>
<h3 id="8-2-C-文件流类"><a href="#8-2-C-文件流类" class="headerlink" title="8.2    C++文件流类"></a>8.2    C++文件流类</h3><p>C++标准类库中，ifstream、ofstream和fstream类可用于文件操作，称为文件流类。使用这三个类需要包含fstream头文件。ifstream和fstream由istream派生来，拥有istream的全部成员函数，同样ofstream和fstream拥有ostream的全部成员函数。要使用一个文件要先打开才能读写，读写完后要关闭。</p>
<h3 id="8-3-文件的打开和关闭"><a href="#8-3-文件的打开和关闭" class="headerlink" title="8.3    文件的打开和关闭"></a>8.3    文件的打开和关闭</h3><div class="table-container">
<table>
<thead>
<tr>
<th>模式标记</th>
<th>适用对象</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ios::in</code></td>
<td>ifstream fstream</td>
<td>打开文件用于读取数据。如果文件不存在。则打开出错</td>
</tr>
<tr>
<td><code>ios::out</code></td>
<td>ofstream fstream</td>
<td>打开文件用于写入数据。如果文件不存在，则新建该文件果文件原来就存在，则打开时清除原来的内容</td>
</tr>
<tr>
<td><code>ios::app</code></td>
<td>ofstream fstream</td>
<td>打开文件，用于在其尾部添加数据。如果文件不存在，则新建该文件</td>
</tr>
<tr>
<td><code>ios::ate</code></td>
<td>ifstream</td>
<td>打开一个已有的文件，并将文件读指针指向文件末尾（读写指针的概念后面解释)。如果文件不存在，则打开出错</td>
</tr>
<tr>
<td><code>ios::trunc</code></td>
<td>ofstream</td>
<td>单独使用时与ios::out相同</td>
</tr>
<tr>
<td><code>ios::binary</code></td>
<td>ifstream ofstream fstream</td>
<td>以二进制方式打开文件。若不指定此模式，则以文本模式打开</td>
</tr>
<tr>
<td>`ios::in\</td>
<td>ios::out`</td>
<td>fstream</td>
<td>打开已存在的文件，既可读取其内容，也可向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错</td>
</tr>
<tr>
<td>`ios::in\</td>
<td>ios::out`</td>
<td>ofstream</td>
<td>打开已存在的文件，可以向其写入数据。文件刚打开时，原有内容保持不变。如果文件不存在，则打开出错</td>
</tr>
<tr>
<td>`ios::in\</td>
<td>ios::out\</td>
<td>ios::trunc`</td>
<td>fstream</td>
<td>打开文件，既可读取其内容，也可向其写入数据。如果文件本来就存在，则打开时清除原来的内容；如果文件不存在，则新建该文件</td>
</tr>
</tbody>
</table>
</div>
<p><code>void open(const char* szFileName,int mode)</code>调用该成员函数时，给出的文件名可以是全路径的，也可以给出相对路径。</p>
<p><code>ifstream(const char* szFileName,int mode=ios::in,int)</code>构造函数也可以打开文件。</p>
<h3 id="8-4-文件的读写"><a href="#8-4-文件的读写" class="headerlink" title="8.4    文件的读写"></a>8.4    文件的读写</h3><h4 id="8-4-1-文本文件的读写"><a href="#8-4-1-文本文件的读写" class="headerlink" title="8.4.1    文本文件的读写"></a>8.4.1    文本文件的读写</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //qsort在此头文件中声明</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX_NUM]; <span class="comment">//存放文件中读入的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* e1, <span class="keyword">const</span> <span class="keyword">void</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//用于qsort的比较函数</span></span><br><span class="line">	<span class="keyword">return</span> *((<span class="keyword">int</span>*)e1) - *((<span class="keyword">int</span>*)e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> total = <span class="number">0</span>;<span class="comment">//读入的整数个数</span></span><br><span class="line">	<span class="function">ifstream <span class="title">srcFile</span><span class="params">(<span class="string">&quot;in.txt&quot;</span>, ios::in)</span></span>; <span class="comment">//以文本模式打开in.txt备读</span></span><br><span class="line">	<span class="keyword">if</span> (!srcFile) &#123; <span class="comment">//打开失败</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error opening source file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ofstream <span class="title">destFile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>, ios::out)</span></span>; <span class="comment">//以文本模式打开out.txt备写</span></span><br><span class="line">	<span class="keyword">if</span> (!destFile) &#123;</span><br><span class="line">		srcFile.close(); <span class="comment">//程序结束前不能忘记关闭以前打开过的文件</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error opening destination file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">while</span> (srcFile &gt;&gt; x) <span class="comment">//可以像用cin那样用ifstream对象</span></span><br><span class="line">		a[total++] = x;</span><br><span class="line">	qsort(a, total, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), MyCompare); <span class="comment">//排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span><br><span class="line">		destFile &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//可以像用cout那样用ofstream对象</span></span><br><span class="line">	destFile.close();</span><br><span class="line">	srcFile.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-2-二进制文件的读写"><a href="#8-4-2-二进制文件的读写" class="headerlink" title="8.4.2    二进制文件的读写"></a>8.4.2    二进制文件的读写</h4><p>使用二进制文件可以节约空间，提升文件查找效率。读写二进制文件不能使用流读写，需要使用read和write成员函数。写函数从写指针指向的位置开始写入，读函数从读指针指向的位置开始读取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CStudent s;</span><br><span class="line">	<span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;students.dat&quot;</span>, ios::in | ios::binary)</span></span>; <span class="comment">//二进制读方式打开</span></span><br><span class="line">	<span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (inFile.read((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s))) &#123; <span class="comment">//一直读到文件结束</span></span><br><span class="line">		<span class="keyword">int</span> readedBytes = inFile.gcount(); <span class="comment">//看刚才读了多少字节</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s.szName &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inFile.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用put和get成员函数读写文件。</p>
<h4 id="8-4-3-操作文件读写指针"><a href="#8-4-3-操作文件读写指针" class="headerlink" title="8.4.3    操作文件读写指针"></a>8.4.3    操作文件读写指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">seekp</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> mode)</span></span>;<span class="comment">//ios::beg		ios::cur	ios::end</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">seekg</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> mode)</span></span>;<span class="comment">//文件开始向后	当前位置	文件结尾向前</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tellg</span><span class="params">()</span></span>;<span class="comment">//返回读指针的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tellp</span><span class="params">()</span></span>;<span class="comment">//返回写指针的位置</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CStudent s;</span><br><span class="line">	<span class="function">fstream <span class="title">ioFile</span><span class="params">(<span class="string">&quot;students.dat&quot;</span>, ios::in | ios::out)</span></span>;<span class="comment">//用既读又写的方式打开</span></span><br><span class="line">	<span class="keyword">if</span> (!ioFile) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ioFile.seekg(<span class="number">0</span>, ios::end); <span class="comment">//定位读指针到文件尾部，</span></span><br><span class="line">							  <span class="comment">//以便用以后tellg 获取文件长度</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">0</span>, R; <span class="comment">// L是折半查找范围内第一个记录的序号</span></span><br><span class="line">				  <span class="comment">// R是折半查找范围内最后一个记录的序号</span></span><br><span class="line">	R = ioFile.tellg() / <span class="keyword">sizeof</span>(CStudent) - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//首次查找范围的最后一个记录的序号就是: 记录总数- 1</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>; <span class="comment">//要用查找范围正中的记录和待查找的名字比对</span></span><br><span class="line">		ioFile.seekg(mid * <span class="keyword">sizeof</span>(CStudent), ios::beg); <span class="comment">//定位到正中的记录</span></span><br><span class="line">		ioFile.read((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">strcmp</span>(s.szName, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123; <span class="comment">//找到了</span></span><br><span class="line">			s.age = <span class="number">20</span>;</span><br><span class="line">			ioFile.seekp(mid * <span class="keyword">sizeof</span>(CStudent), ios::beg);</span><br><span class="line">			ioFile.write((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) <span class="comment">//继续到前一半查找</span></span><br><span class="line">			R = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>  <span class="comment">//继续到后一半查找</span></span><br><span class="line">			L = mid + <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (L &lt;= R);</span><br><span class="line">	ioFile.close();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-文本方式打开文件与二进制方式打开文件的区别"><a href="#8-5-文本方式打开文件与二进制方式打开文件的区别" class="headerlink" title="8.5    文本方式打开文件与二进制方式打开文件的区别"></a>8.5    文本方式打开文件与二进制方式打开文件的区别</h3><p>UNIX/Linux中文本方式和二进制方式打开文件没有任何区别。Windows中用文本方式打开二进制文件读写的内容可能与文件内容有出入。</p>
<h2 id="九-泛型程序设计与模板"><a href="#九-泛型程序设计与模板" class="headerlink" title="九    泛型程序设计与模板"></a>九    泛型程序设计与模板</h2><h3 id="9-1-函数模板"><a href="#9-1-函数模板" class="headerlink" title="9.1    函数模板"></a>9.1    函数模板</h3><h4 id="9-1-1-函数模板的作用"><a href="#9-1-1-函数模板的作用" class="headerlink" title="9.1.1    函数模板的作用"></a>9.1.1    函数模板的作用</h4><p>泛型程序设计指的是算法在实现时不指定具体操作的数据类型的程序设计方法。有了函数模板，编译器就能在需要时根据模板自动生成程序代码。</p>
<h4 id="9-1-2-函数模板的原理"><a href="#9-1-2-函数模板的原理" class="headerlink" title="9.1.2    函数模板的原理"></a>9.1.2    函数模板的原理</h4><p>编译器由模板自动生成函数时会用具体的类型名对模板中所有的类型参数进行替换， 其他部分则原封不动地保留。编译器由模板自动生成函数的过程叫做模板的实例化。模板调用语句可以显式地指明要把类型参数实例化为那种类型。</p>
<h4 id="9-1-3-一个求数组中最大元素的函数模板"><a href="#9-1-3-一个求数组中最大元素的函数模板" class="headerlink" title="9.1.3    一个求数组中最大元素的函数模板"></a>9.1.3    一个求数组中最大元素的函数模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">MaxElement</span><span class="params">(T a[], <span class="keyword">int</span> size)</span> <span class="comment">//size是数组元素个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T tmpMax = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i)</span><br><span class="line">		<span class="keyword">if</span> (tmpMax &lt; a[i])</span><br><span class="line">			tmpMax = a[i];</span><br><span class="line">	<span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFraction</span> //分数类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> numerator;   <span class="comment">//分子</span></span><br><span class="line">	<span class="keyword">int</span> denominator; <span class="comment">//分母</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CFraction(<span class="keyword">int</span> n, <span class="keyword">int</span> d) :numerator(n), denominator(d) &#123; &#125;;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> CFraction&amp; f) <span class="keyword">const</span></span><br><span class="line">	&#123;<span class="comment">//为避免除法产生的浮点误差，用乘法判断两个分数的大小关系</span></span><br><span class="line">		<span class="keyword">if</span> (denominator * f.denominator &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> numerator * f.denominator &lt; denominator* f.numerator;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> numerator * f.denominator &gt; denominator * f.numerator;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> CFraction&amp; f) <span class="keyword">const</span></span><br><span class="line">	&#123;<span class="comment">//为避免除法产生的浮点误差，用乘法判断两个分数是否相等</span></span><br><span class="line">		<span class="keyword">return</span> numerator * f.denominator == denominator * f.numerator;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; o, <span class="keyword">const</span> CFraction&amp; f);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; o, <span class="keyword">const</span> CFraction&amp; f)</span><br><span class="line">&#123;<span class="comment">//重载 &lt;&lt; 使得分数对象可以通过cout输出</span></span><br><span class="line">	o &lt;&lt; f.numerator &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; f.denominator; <span class="comment">//输出&quot;分子/分母&quot; 形式</span></span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	CFraction f[<span class="number">4</span>] = &#123; CFraction(<span class="number">8</span>,<span class="number">6</span>),CFraction(<span class="number">-8</span>,<span class="number">4</span>),</span><br><span class="line">					   CFraction(<span class="number">3</span>,<span class="number">2</span>), CFraction(<span class="number">5</span>,<span class="number">6</span>) &#125;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; MaxElement(a, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; MaxElement(f, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-1-4-函数或函数模板调用语句的匹配顺序"><a href="#9-1-4-函数或函数模板调用语句的匹配顺序" class="headerlink" title="9.1.4    函数或函数模板调用语句的匹配顺序"></a>9.1.4    函数或函数模板调用语句的匹配顺序</h4><p>C++编译器按照如下顺序匹配同名函数：先找参数完全匹配的普通函数，再找参数完全匹配的模板函数，再找实参经过自动类型转换后能够匹配的普通函数，如果都找不到则报错。</p>
<h3 id="9-2-类模板"><a href="#9-2-类模板" class="headerlink" title="9.2    类模板"></a>9.2    类模板</h3><h4 id="9-2-1-类模板的原理"><a href="#9-2-1-类模板的原理" class="headerlink" title="9.2.1    类模板的原理"></a>9.2.1    类模板的原理</h4><p>编译器由类模板生成类的过程叫做类模板的实例化，由类模板实例化的类叫模板类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 key;  <span class="comment">//关键字</span></span><br><span class="line">	T2 value;  <span class="comment">//值</span></span><br><span class="line">	Pair(T1 k, T2 v) :key(k), value(v) &#123; &#125;;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pair&lt;T1, T2&gt;&amp; p) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Pair&lt;T1, T2&gt;::<span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Pair&lt;T1, T2&gt;&amp; p) <span class="keyword">const</span></span><br><span class="line">	<span class="comment">//Pair的成员函数 operator &lt;</span></span><br><span class="line">&#123; <span class="comment">//&quot;小&quot;的意思就是关键字小</span></span><br><span class="line">	<span class="keyword">return</span> key &lt; p.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pair&lt;string, int&gt; student(&quot;Tom&quot;, 19); //实例化出一个类 Pair&lt;string,int&gt;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; student.key &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; student.value;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-2-函数模板作为类模板成员"><a href="#9-2-2-函数模板作为类模板成员" class="headerlink" title="9.2.2    函数模板作为类模板成员"></a>9.2.2    函数模板作为类模板成员</h4><p>类模板的成员函数可以是一个函数模板，成员函数模板在被调用时才会被实例化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(T2 t)</span></span>&#123;&#125;	<span class="comment">//成员函数模板</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-3-类模板实例：可变长数组类模板"><a href="#9-2-3-类模板实例：可变长数组类模板" class="headerlink" title="9.2.3    类模板实例：可变长数组类模板"></a>9.2.3    类模板实例：可变长数组类模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size; <span class="comment">//数组元素的个数</span></span><br><span class="line">	T* ptr; <span class="comment">//指向动态分配的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CArray(<span class="keyword">int</span> s = <span class="number">0</span>);  <span class="comment">//s代表数组元素的个数</span></span><br><span class="line">	CArray(CArray&amp; a);</span><br><span class="line">	~CArray();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span></span>; <span class="comment">//用于在数组尾部添加一个元素v</span></span><br><span class="line">	CArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CArray&amp; a); <span class="comment">//用于数组对象间的赋值</span></span><br><span class="line">	<span class="function">T <span class="title">length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)</span><br><span class="line">	&#123;<span class="comment">//用以支持根据下标访问数组元素，如a[i] = 4;和n = a[i]这样的语句</span></span><br><span class="line">		<span class="keyword">return</span> ptr[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">CArray&lt;T&gt;::CArray(<span class="keyword">int</span> s) :size(s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">		ptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ptr = <span class="keyword">new</span> T[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">CArray&lt;T&gt;::CArray(CArray&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!a.ptr) &#123;</span><br><span class="line">		ptr = <span class="literal">NULL</span>;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ptr = <span class="keyword">new</span> T[a.size];</span><br><span class="line">	<span class="built_in">memcpy</span>(ptr, a.ptr, <span class="keyword">sizeof</span>(T) * a.size);</span><br><span class="line">	size = a.size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">CArray&lt;T&gt;::~CArray()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptr) <span class="keyword">delete</span>[] ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">CArray&lt;T&gt;&amp; CArray&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> CArray&amp; a)</span><br><span class="line">&#123; <span class="comment">//赋值号的作用是使&quot;=&quot;左边对象里存放的数组，大小和内容都和右边的对象一样</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="comment">//防止a=a这样的赋值导致出错</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">if</span> (a.ptr == <span class="literal">NULL</span>) &#123;  <span class="comment">//如果a里面的数组是空的</span></span><br><span class="line">		<span class="keyword">if</span> (ptr)</span><br><span class="line">			<span class="keyword">delete</span>[] ptr;</span><br><span class="line">		ptr = <span class="literal">NULL</span>;</span><br><span class="line">		size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (size &lt; a.size) &#123; <span class="comment">//如果原有空间够大，就不用分配新的空间</span></span><br><span class="line">		<span class="keyword">if</span> (ptr)</span><br><span class="line">			<span class="keyword">delete</span>[] ptr;</span><br><span class="line">		ptr = <span class="keyword">new</span> T[a.size];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(ptr, a.ptr, <span class="keyword">sizeof</span>(T) * a.size);</span><br><span class="line">	size = a.size;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> CArray&lt;T&gt;::push_back(<span class="keyword">const</span> T&amp; v)</span><br><span class="line">&#123;  <span class="comment">//在数组尾部添加一个元素</span></span><br><span class="line">	<span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		T* tmpPtr = <span class="keyword">new</span> T[size + <span class="number">1</span>]; <span class="comment">//重新分配空间</span></span><br><span class="line">		<span class="built_in">memcpy</span>(tmpPtr, ptr, <span class="keyword">sizeof</span>(T) * size); <span class="comment">//拷贝原数组内容</span></span><br><span class="line">		<span class="keyword">delete</span>[]ptr;</span><br><span class="line">		ptr = tmpPtr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="comment">//数组本来是空的</span></span><br><span class="line">		ptr = <span class="keyword">new</span> T[<span class="number">1</span>];</span><br><span class="line">	ptr[size++] = v; <span class="comment">//加入新的数组元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CArray&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		a.push_back(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-类模板中的非类型参数"><a href="#9-3-类模板中的非类型参数" class="headerlink" title="9.3    类模板中的非类型参数"></a>9.3    类模板中的非类型参数</h3><p>类模板的类型参数表中可以出现非类型参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T <span class="built_in">array</span>[size];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CArray&lt;<span class="keyword">int</span>,<span class="number">40</span>&gt; a;</span><br><span class="line">CArray&lt;<span class="keyword">int</span>,<span class="number">50</span>&gt; b;	<span class="comment">//a和b是两个不同类</span></span><br></pre></td></tr></table></figure>
<h3 id="9-4-类模板与继承"><a href="#9-4-类模板与继承" class="headerlink" title="9.4    类模板与继承"></a>9.4    类模板与继承</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>				<span class="comment">//类模板从类模板派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&lt;T&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>				<span class="comment">//类模板从模板类派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;						<span class="comment">//类模板从普通类派生</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>				<span class="comment">//普通类从模板类派生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="9-5-类模板和友元"><a href="#9-5-类模板和友元" class="headerlink" title="9.5    类模板和友元"></a>9.5    类模板和友元</h3><h4 id="9-5-1-函数、类、类的成员函数作为类模板的友元"><a href="#9-5-1-函数、类、类的成员函数作为类模板的友元" class="headerlink" title="9.5.1    函数、类、类的成员函数作为类模板的友元"></a>9.5.1    函数、类、类的成员函数作为类模板的友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">B::Func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tmpl&lt;<span class="keyword">int</span>&gt; i;</span><br><span class="line">	Tmpl&lt;<span class="keyword">double</span>&gt; f;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-5-2-函数模板作为类模板的友元"><a href="#9-5-2-函数模板作为类模板的友元" class="headerlink" title="9.5.2    函数模板作为类模板的友元"></a>9.5.2    函数模板作为类模板的友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T1 key;</span><br><span class="line">    T2 value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>,<span class="keyword">class</span> <span class="title">T4</span>&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Pair&lt;T3,T4&gt;&amp; p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; o,<span class="keyword">const</span> Pair&lt;T1,T2&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-5-3-函数模板作为类的友元"><a href="#9-5-3-函数模板作为类的友元" class="headerlink" title="9.5.3    函数模板作为类的友元"></a>9.5.3    函数模板作为类的友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> n) :v(n) &#123; &#125;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> T&amp; p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> T&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	Print(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-5-4-类模板作为类模板的友元"><a href="#9-5-4-类模板作为类模板的友元" class="headerlink" title="9.5.4    类模板作为类模板的友元"></a>9.5.4    类模板作为类模板的友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    A&lt;B&lt;<span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6-类模板中的静态成员"><a href="#9-6-类模板中的静态成员" class="headerlink" title="9.6    类模板中的静态成员"></a>9.6    类模板中的静态成员</h3><p>类模板中可以定义静态成员，从该类模板实例化得到的所有类都包含同样的静态成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A() &#123; count++; &#125;</span><br><span class="line">	~A() &#123; count--; &#125;;</span><br><span class="line">	A(A&amp;) &#123; count++; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintCount</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> A&lt;<span class="keyword">int</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> A&lt;<span class="keyword">double</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A&lt;<span class="keyword">int</span>&gt; ia;</span><br><span class="line">	A&lt;<span class="keyword">double</span>&gt; da;</span><br><span class="line">	ia.PrintCount();</span><br><span class="line">	da.PrintCount();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-7-在多个文件中使用模板"><a href="#9-7-在多个文件中使用模板" class="headerlink" title="9.7    在多个文件中使用模板"></a>9.7    在多个文件中使用模板</h3><p>如果多个.cpp文件要用到同一个模板，则可将该模板全部内容（包括成员函数体）写在一个头文件中，不会发生重复定义的错误。</p>
<h2 id="十-标准模板库STL"><a href="#十-标准模板库STL" class="headerlink" title="十    标准模板库STL"></a>十    标准模板库STL</h2><h3 id="10-1-STL中的基本概念"><a href="#10-1-STL中的基本概念" class="headerlink" title="10.1    STL中的基本概念"></a>10.1    STL中的基本概念</h3><p>STL指标准模板库，是一些常用数据结构和算法的模板的集合，程序员在使用常用的数据结构和算法时可以直接使用其中的模板。容器是存放数据的类模板，可变长数组、链表、平衡二叉树等数据结构在STL中都被实现为容器。迭代器用于存取容器中存放的元素，作用类似于指针。算法是用来操作容器中元素的函数模板。</p>
<h4 id="10-1-1-容器模板"><a href="#10-1-1-容器模板" class="headerlink" title="10.1.1    容器模板"></a>10.1.1    容器模板</h4><p>容器分为顺序容器和关联容器。顺序容器包括可变长动态数组vector、双端队列deque、双向链表list。元素在顺序容器中的位置同元素的值无关。将元素插入容器时指定在什么位置插入，元素就会位于什么位置。关联容器包括set、multiset、map、multimap。插入元素时，容器会按一定的排序规则把元素放到适当的位置上，插入元素时不能指定位置。关联容器中的元素默认从小到大排序，因此查找时具有很好的性能。此外STL还有三种容器适配器：栈stack、队列queue、优先级队列priority_queue。容器都是类模板，实例化后成为容器类，定义的对象称为容器对象。任何两个容器对象只要类型相同就可以进行大小比较，比较规则按照词典顺序。</p>
<p>所有容器都有这两个成员函数：<code>int size()</code>返回容器对象元素个数，<code>bool empty()</code>判断容器对象是否为空。</p>
<p>顺序容器和关联容器还有以下函数：<code>begin()</code>返回指向容器中第一个元素的迭代器，<code>end()</code>返回指向容器中最后一个元素后面的位置的迭代器，<code>rbegin()</code>返回最后一个元素的反向迭代器，<code>rend()</code>返回第一个元素前面位置的反向迭代器，<code>erase()</code>删除一个或几个元素，<code>clear()</code>删除所有元素。</p>
<p>顺序容器还有以下成员函数：<code>front()</code>返回第一个元素的引用，<code>back()</code>返回最后一个元素的引用，<code>push_back()</code>在容器末尾增加新元素，<code>pop_back()</code>删除容器末尾的元素，<code>insert()</code>插入一个或多个元素。</p>
<h4 id="10-1-2-迭代器"><a href="#10-1-2-迭代器" class="headerlink" title="10.1.2    迭代器"></a>10.1.2    迭代器</h4><p>访问顺容器中的元素需要通过迭代器。迭代器按照定义分为正向迭代器、常量正向迭代器、反向迭代器、反向常量迭代器。常量迭代器不能修改指向的元素。正向和反向的区别在于++时指向后一个元素还是前一个元素。STL重载迭代器++运算符时，后置++比前置++运行速度慢，因此循环控制变量要写前置++。三种容器适配器没有迭代器。迭代器按照功能强弱分为输入、输出、正向、双向、随机访问五种。</p>
<p>正向迭代器p支持++p、p++、*p，两个正向迭代器可以互相赋值，支持==、!=运算符比较。双向迭代器除了支持正向迭代器的全部功能还支持—p、p—。随机访问迭代器除了支持双向迭代器的全部功能还支持p+=i、p-=i、p+i、p-i、p[i]，还支持大小比较，对于两个随机访问迭代器p1和p2表达式p2-p1也有定义。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th>迭代器功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>随机访问</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问</td>
</tr>
<tr>
<td>list</td>
<td>双向</td>
</tr>
<tr>
<td>set/multiset</td>
<td>双向</td>
</tr>
<tr>
<td>map/multimap</td>
<td>双向</td>
</tr>
<tr>
<td>stack</td>
<td>不支持</td>
</tr>
<tr>
<td>queue</td>
<td>不支持</td>
</tr>
<tr>
<td>priority_queue</td>
<td>不支持</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">	<span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i;</span><br><span class="line">	<span class="keyword">for</span> (i = v.begin(); i &lt; v.end(); ++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i;</span><br><span class="line">	i = v.begin();</span><br><span class="line">	<span class="keyword">while</span> (i &lt; v.end()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i;</span><br><span class="line">		i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STL中迭代器的辅助函数有<code>advance(p,n)</code>使迭代器p向前或向后移动n个元素，<code>distance(p,q)</code>计算两个迭代器之间的距离，<code>iter_swap(p,q)</code>交换两个迭代器p、q指向的值。</p>
<h4 id="10-1-3-算法"><a href="#10-1-3-算法" class="headerlink" title="10.1.3    算法"></a>10.1.3    算法</h4><p>算法就是函数模板。例如find算法在容器区间起点和终点间查找一个元素，并返回一个指向该元素的迭代器。大部分常用算法在algorithm头文件定义，部分算法在numeric头文件定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.push_back(<span class="number">1</span>);	v.push_back(<span class="number">2</span>);</span><br><span class="line">	v.push_back(<span class="number">3</span>);	v.push_back(<span class="number">4</span>); <span class="comment">//此后v里放着4个元素：1,2,3,4</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line">	p = find(v.begin(), v.end(), <span class="number">3</span>); <span class="comment">//在v中查找3</span></span><br><span class="line">	<span class="keyword">if</span> (p != v.end()) <span class="comment">//若找不到,find返回 v.end()</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//找到了</span></span><br><span class="line">	p = find(v.begin(), v.end(), <span class="number">9</span>);</span><br><span class="line">	<span class="keyword">if</span> (p == v.end())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found &quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//没找到</span></span><br><span class="line">	p = find(v.begin() + <span class="number">1</span>, v.end() - <span class="number">1</span>, <span class="number">4</span>); <span class="comment">//在,3 这两个元素中查找4</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span>* pp = find(a, a + <span class="number">4</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="keyword">if</span> (pp == a + <span class="number">4</span>)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt; *pp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>copy将一个容器的内容复制到另一个容器，remove删除容器的一个元素，random_shuffle随机打乱容器元素，fill用某个值填充容器，count_if统计容器中符合某条件的元素个数，sort对容器从小到大排序。</p>
<h4 id="10-1-4-STL中“大”、“小”和“相等”的概念"><a href="#10-1-4-STL中“大”、“小”和“相等”的概念" class="headerlink" title="10.1.4    STL中“大”、“小”和“相等”的概念"></a>10.1.4    STL中“大”、“小”和“相等”的概念</h4><p>默认情况下比较大小通过&lt;运算符进行。对在排好序的区间上进行查找合并等算法来说，x和y相等指的是x&lt;y和y&lt;x同时为假，与x==y为真无关。在重载&lt;运算符时最好重载为全局函数，重载为成员函数可能会导致编译错误。</p>
<h3 id="10-2-顺序容器"><a href="#10-2-顺序容器" class="headerlink" title="10.2    顺序容器"></a>10.2    顺序容器</h3><h4 id="10-2-1-动态数组vector"><a href="#10-2-1-动态数组vector" class="headerlink" title="10.2.1    动态数组vector"></a>10.2.1    动态数组vector</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">	<span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i;</span><br><span class="line">	<span class="keyword">for</span> (i = v.begin(); i &lt; v.end(); ++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i;</span><br><span class="line">	i = v.begin();</span><br><span class="line">	<span class="keyword">while</span> (i &lt; v.end()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i;</span><br><span class="line">		i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-2-2-双向链表list"><a href="#10-2-2-双向链表list" class="headerlink" title="10.2.2    双向链表list"></a>10.2.2    双向链表list</h4><p>有 n 只猴子，按顺时针方向围成一圈选大王（编号为 1~n），从第 1 号开始报数，一直数到 m，数到 m 的猴子退到圈外，剩下的猴子再接着从 1 开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王。编程求输入 n、m 后,输出最后猴王的编号。</p>
<p>输入数据：每行是用空格分开的两个整数，第一个是 n，第二个是 m（0&lt;m, n&lt;=1 000 000）。最后一行是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p>输出要求：对于每行输入数据（最后一行除外），输出数据也是一行，即最后猴王的编号。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 2</span><br><span class="line">12 4</span><br><span class="line">8 3</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; monkeys;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		monkeys.clear(); <span class="comment">//清空list容器</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//将猴子的编号放入list</span></span><br><span class="line">			monkeys.push_back(i);</span><br><span class="line">		<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = monkeys.begin();</span><br><span class="line">		<span class="keyword">while</span> (monkeys.size() &gt; <span class="number">1</span>) &#123; <span class="comment">//只要还有不止一只猴子，就要找一只猴子让其出列</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123; <span class="comment">//报数</span></span><br><span class="line">				++it;</span><br><span class="line">				<span class="keyword">if</span> (it == monkeys.end())</span><br><span class="line">					it = monkeys.begin();</span><br><span class="line">			&#125;</span><br><span class="line">			it = monkeys.erase(it); <span class="comment">//删除元素后，迭代器失效，</span></span><br><span class="line">			<span class="comment">//要重新让迭代器指向被删元素的后面</span></span><br><span class="line">			<span class="keyword">if</span> (it == monkeys.end())</span><br><span class="line">				it = monkeys.begin();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; monkeys.front() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//front返回第一个元素的引用</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序也可以用 vector 实现，但是执行速度要慢很多。因为 vector 的 erase 操作牵涉元素的移动，不能在常数时间内完成，所花费的时间和容器中的元素个数有关；而 list 的 erase 操作只是修改几个指针而已，可以在常数时间内完成。当 n 很大（数十万）时，两种写法在速度上会有明显区别。</p>
<h4 id="10-2-3-双向队列deque"><a href="#10-2-3-双向队列deque" class="headerlink" title="10.2.3    双向队列deque"></a>10.2.3    双向队列deque</h4><p>deque包含所有vector的操作，还有两个vector没有的成员函数。<code>void push_front(const T&amp; val)</code>将val插入容器头部，<code>void pop_front()</code>删除容器头部元素。</p>
<h3 id="10-3-函数对象"><a href="#10-3-函数对象" class="headerlink" title="10.3    函数对象"></a>10.3    函数对象</h3><h4 id="10-3-1-函数对象的概念"><a href="#10-3-1-函数对象的概念" class="headerlink" title="10.3.1    函数对象的概念"></a>10.3.1    函数对象的概念</h4><p>如果一个类将()运算符重载为成员函数，这个类就被称为函数对象类，这个类的对象就是函数对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CAverage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(a1+a2+a3)/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CAverage average;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;average(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-3-2-函数对象应用实例1：在accumulate算法中的应用"><a href="#10-3-2-函数对象应用实例1：在accumulate算法中的应用" class="headerlink" title="10.3.2    函数对象应用实例1：在accumulate算法中的应用"></a>10.3.2    函数对象应用实例1：在accumulate算法中的应用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; //accumulate 在此头文件定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInterval</span><span class="params">(T first, T last)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//输出区间[first,last)中的元素</span></span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumSquares</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> total + value * value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumPowers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> power;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SumPowers(<span class="keyword">int</span> p) :power(p) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; total, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="comment">//计算 value的power次方，加到total上</span></span><br><span class="line">		T v = value;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; power - <span class="number">1</span>; ++i)</span><br><span class="line">			v = v * value;</span><br><span class="line">		<span class="keyword">return</span> total + v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> a1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(a1, a1 + SIZE)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span>; PrintInterval(v.begin(), v.end());</span><br><span class="line">	<span class="keyword">int</span> result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumSquares);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) 平方和：&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumPowers&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) 立方和：&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumPowers&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) 4次方和：&quot;</span> &lt;&lt; result;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-3-3-函数对象应用实例2：在sort算法中的应用"><a href="#10-3-3-函数对象应用实例2：在sort算法中的应用" class="headerlink" title="10.3.3    函数对象应用实例2：在sort算法中的应用"></a>10.3.3    函数对象应用实例2：在sort算法中的应用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //sort算法在此头文件中定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printlnterva1</span><span class="params">(T first, T last)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//用以输出 [first, last) 区间中的元素</span></span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	A(<span class="keyword">int</span> n) : v(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A&amp; a1, <span class="keyword">const</span> A&amp; a2)</span><br><span class="line">&#123; <span class="comment">//重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错</span></span><br><span class="line">	<span class="keyword">return</span> a1.v &lt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterA</span><span class="params">(<span class="keyword">const</span> A&amp; a1, <span class="keyword">const</span> A&amp; a2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//v值大的元素作为较小的数</span></span><br><span class="line">	<span class="keyword">return</span> a1.v &gt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LessA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> A&amp; a1, <span class="keyword">const</span> A&amp; a2)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="comment">//v的个位数小的元素就作为较小的数</span></span><br><span class="line">		<span class="keyword">return</span> (a1.v % <span class="number">10</span>) &lt; (a2.v % <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; o, <span class="keyword">const</span> A&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">	o &lt;&lt; a.v;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a1[<span class="number">4</span>] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	A a2[<span class="number">5</span>] = &#123; <span class="number">13</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">16</span> &#125;;</span><br><span class="line">	sort(a1, a1 + <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span>; Printlnterva1(a1, a1 + <span class="number">4</span>); <span class="comment">//输出 1)1 2 4 5</span></span><br><span class="line">	sort(a2, a2 + <span class="number">5</span>); <span class="comment">//按v的值从小到大排序</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>); <span class="comment">//输出 2)8 9 12 13 16</span></span><br><span class="line">	sort(a2, a2 + <span class="number">5</span>, GreaterA); <span class="comment">//按v的值从大到小排序</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>); <span class="comment">//输出 3)16 13 12 9 8</span></span><br><span class="line">	sort(a2, a2 + <span class="number">5</span>, LessA()); <span class="comment">//按v的个位数从小到大排序</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>); <span class="comment">//输出 4)12 13 16 8 9</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-3-4-STL中的函数对象模板"><a href="#10-3-4-STL中的函数对象模板" class="headerlink" title="10.3.4    STL中的函数对象模板"></a>10.3.4    STL中的函数对象模板</h4><p>STL中的函数对象模板位于头文件functional中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>]=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">34</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    sort(a,a+<span class="number">4</span>,less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-3-5-引入函数对象后STL的“大”、“小”和“相等”的概念"><a href="#10-3-5-引入函数对象后STL的“大”、“小”和“相等”的概念" class="headerlink" title="10.3.5    引入函数对象后STL的“大”、“小”和“相等”的概念"></a>10.3.5    引入函数对象后STL的“大”、“小”和“相等”的概念</h4><p>在自定义比较器的情况下，x小于y等价于op(x,y)返回true等价于y大于x。</p>
<h3 id="10-4-关联容器"><a href="#10-4-关联容器" class="headerlink" title="10.4    关联容器"></a>10.4    关联容器</h3><p>set是排好序的集合，不允许有相同元素。multiset是排好序的集合，允许有相同元素。map是由关键字和值两部分组成的映射的集合，容器中元素按关键字排序，不允许多个元素关键字相同。multimap允许元素关键字相同。不能修改set和multiset容器元素的值，不能修改map和multimap容器元素关键字。正确的做法是先删除该元素再插入新元素。在关联容器中查找和插入元素时间复杂度为$O(\log n)$。关联容器一般用平衡二叉树实现。</p>
<p>关联容器还具有以下成员函数：<code>find()</code>查找某个值，<code>lower_bound()</code>查找某个下界，<code>upper_bound()</code>查找某个上界，<code>equal_range()</code>查找上界和下界，<code>count()</code>计算等于某个值的元素个数，<code>insert()</code>插入一个元素或一个区间。</p>
<h4 id="10-4-1-pair类模板"><a href="#10-4-1-pair类模板" class="headerlink" title="10.4.1    pair类模板"></a>10.4.1    pair类模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; p1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p1.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p1.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  0,0	</span></span><br><span class="line">	pair&lt;string, int&gt; p2(&quot;this&quot;, 20);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  this,20</span></span><br><span class="line">	pair&lt;int, int&gt; p3(pair&lt;char, char&gt;(&#x27;a&#x27;, &#x27;b&#x27;));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p3.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p3.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  97,98</span></span><br><span class="line">	<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; p4 = <span class="built_in">make_pair</span>(<span class="number">200</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p4.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p4.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  200,hello</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-2-multiset"><a href="#10-4-2-multiset" class="headerlink" title="10.4.2    multiset"></a>10.4.2    multiset</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //使用multiset须包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T first, T last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> n_) &#123; n = n_; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">    &#123; <span class="keyword">return</span> a1.n &lt; a2.n; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">    &#123; o &lt;&lt; a2.n; <span class="keyword">return</span> o; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLess</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span>  <span class="comment">//按个位数比较大小</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (a1.n % <span class="number">10</span>) &lt; (a2.n % <span class="number">10</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;A&gt; MSET1;  <span class="comment">//MSET1 用“&lt;”运算符比较大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;A, MyLess&gt; MSET2;  <span class="comment">//MSET2 用 MyLess::operator() 比较大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">6</span>;</span><br><span class="line">    A a[SIZE] = &#123; <span class="number">4</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">33</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    MSET1 m1;</span><br><span class="line">    m1.insert(a, a + SIZE);</span><br><span class="line">    m1.insert(<span class="number">22</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; m1.count(<span class="number">22</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1)2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; Print(m1.begin(), m1.end());  <span class="comment">//输出 2)4 8 19 22 22 33 40</span></span><br><span class="line">    MSET1::iterator pp = m1.find(<span class="number">19</span>);</span><br><span class="line">    <span class="keyword">if</span> (pp != m1.end())  <span class="comment">//条件为真说明找到</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//本行会被执行，输出 found</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; <span class="built_in">cout</span> &lt;&lt; *m1.lower_bound(<span class="number">22</span>)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; *m1.upper_bound(<span class="number">22</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3)22,33</span></span><br><span class="line">    pp = m1.erase(m1.lower_bound(<span class="number">22</span>), m1.upper_bound(<span class="number">22</span>));</span><br><span class="line">    <span class="comment">//pp指向被删元素的下一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; Print(m1.begin(), m1.end());  <span class="comment">//输出 4)4 8 19 33 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5)&quot;</span>; <span class="built_in">cout</span> &lt;&lt; *pp &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5)33</span></span><br><span class="line">    MSET2 m2;  <span class="comment">//m2中的元素按n的个位数从小到大排序</span></span><br><span class="line">    m2.insert(a, a + SIZE);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6)&quot;</span>; Print(m2.begin(), m2.end());  <span class="comment">//输出 6)40 22 33 4 8 19</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-3-set"><a href="#10-4-3-set" class="headerlink" title="10.4.3    set"></a>10.4.3    set</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //使用set须包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator IT;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(a, a + <span class="number">5</span>)</span></span>;    <span class="comment">// st里是 1 2 3 4 6</span></span><br><span class="line">	<span class="built_in">pair</span>&lt; IT, <span class="keyword">bool</span>&gt; result;</span><br><span class="line">	result = st.insert(<span class="number">5</span>); <span class="comment">// st变成  1 2 3 4 5 6</span></span><br><span class="line">	<span class="keyword">if</span> (result.second)    <span class="comment">//插入成功则输出被插入元素</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *result.first &lt;&lt; <span class="string">&quot; inserted&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出: 5 inserted</span></span><br><span class="line">	<span class="keyword">if</span> (st.insert(<span class="number">5</span>).second)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *result.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *result.first &lt;&lt; <span class="string">&quot; already exists&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//输出 5 already exists</span></span><br><span class="line">	<span class="built_in">pair</span>&lt;IT, IT&gt; bounds = st.equal_range(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *bounds.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; *bounds.second;  <span class="comment">//输出：4,5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-4-multimap"><a href="#10-4-4-multimap" class="headerlink" title="10.4.4    multimap"></a>10.4.4    multimap</h4><p>一个学生成绩录入和查询系统接受以下两种输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Add name id score</span><br><span class="line">Query score</span><br></pre></td></tr></table></figure>
<p>name 是一个字符串，其中不包含空格，表示学生姓名。id 是一个整数，表示学号。score 是一个整数，表示分数。学号不会重复，分数和姓名都可能重复。</p>
<p>两种输入交替出现。第一种输入表示要添加一个学生的信息，碰到这种输入，就记下学生的姓名、id 和分数。<br>第二种输入表示要查询分数为 score 的学生的信息，碰到这种输入，就输出已有记录中分数比查询分数低的最高分获得者的姓名、学号和分数。如果有多个学生满足条件，则输出学号最大的学生的信息。如果找不到满足条件的学生，则输出“Nobody”。</p>
<p>输入样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Add Jack <span class="number">12</span> <span class="number">78</span></span><br><span class="line">Query <span class="number">78</span></span><br><span class="line">Query <span class="number">81</span></span><br><span class="line">Add Percy <span class="number">9</span> <span class="number">81</span></span><br><span class="line">Add Marry <span class="number">8</span> <span class="number">81</span></span><br><span class="line">Query <span class="number">82</span></span><br><span class="line">Add Tom <span class="number">11</span> <span class="number">79</span></span><br><span class="line">Query <span class="number">80</span></span><br><span class="line">Query <span class="number">81</span></span><br></pre></td></tr></table></figure>
<p>输出结果样例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Nobody</span><br><span class="line">Jack <span class="number">12</span> <span class="number">78</span></span><br><span class="line">Percy <span class="number">9</span> <span class="number">81</span></span><br><span class="line">Tom <span class="number">11</span> <span class="number">79</span></span><br><span class="line">Tom <span class="number">11</span> <span class="number">79</span></span><br></pre></td></tr></table></figure>
<p>使用vector查找和插入元素效率低下，考虑使用multimap。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //使用multimap需要包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CInfo</span>  //类的内部还可以定义类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    CInfo info;  <span class="comment">//学生的其他信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span> &lt;<span class="keyword">int</span>, CStudent::CInfo&gt; MAP_STD;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    MAP_STD mp;</span><br><span class="line">    CStudent st;</span><br><span class="line">    <span class="built_in">string</span> cmd;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cmd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="string">&quot;Add&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score;</span><br><span class="line">            mp.insert(MAP_STD::value_type(st.score, st.info));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;Query&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> score;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line">            MAP_STD::iterator p = mp.lower_bound(score);</span><br><span class="line">            <span class="keyword">if</span> (p != mp.begin()) &#123;</span><br><span class="line">                --p;</span><br><span class="line">                score = p-&gt;first;  <span class="comment">//比要查询分数低的最高分</span></span><br><span class="line">                MAP_STD::iterator maxp = p;</span><br><span class="line">                <span class="keyword">int</span> maxId = p-&gt;second.id;</span><br><span class="line">                <span class="keyword">for</span> (; p != mp.begin() &amp;&amp; p-&gt;first == score; --p) &#123;</span><br><span class="line">                    <span class="comment">//遍历所有成绩和score相等的学生</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;second.id &gt; maxId) &#123;</span><br><span class="line">                        maxp = p;</span><br><span class="line">                        maxId = p-&gt;second.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;first == score) &#123; <span class="comment">//如果上面的循环因为 p == mp.begin()</span></span><br><span class="line">                                         <span class="comment">//而终止，则p指向的元素还要处理</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;second.id &gt; maxId) &#123;</span><br><span class="line">                        maxp = p;</span><br><span class="line">                        maxId = p-&gt;second.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; maxp-&gt;second.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxp-&gt;second.id &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                    &lt;&lt; maxp-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//lower_bound 的结果就是 begin，说明没有分数比查询分数低</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Nobody&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-5-map"><a href="#10-4-5-map" class="headerlink" title="10.4.5    map"></a>10.4.5    map</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //使用map需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; o, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;T1, T2&gt;&amp; p)</span><br><span class="line">&#123; <span class="comment">//将pair对象输出为 (first,second)形式</span></span><br><span class="line">	o &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T first, T last)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//打印区间[first,last)</span></span><br><span class="line">	<span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; MYMAP; <span class="comment">//此容器关键字是整型，</span></span><br><span class="line">											<span class="comment">//元素按关键字从大到小排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MYMAP mp;</span><br><span class="line">	mp.insert(MYMAP::value_type(<span class="number">15</span>, <span class="number">2.7</span>));</span><br><span class="line">	<span class="built_in">pair</span>&lt;MYMAP::iterator, <span class="keyword">bool</span>&gt; p = mp.insert(<span class="built_in">make_pair</span>(<span class="number">15</span>, <span class="number">99.3</span>));</span><br><span class="line">	<span class="keyword">if</span> (!p.second)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *(p.first) &lt;&lt; <span class="string">&quot; already exists&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//会输出</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; mp.count(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 1) 1</span></span><br><span class="line">	mp.insert(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="number">9.3</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; mp[<span class="number">40</span>] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//如果没有关键字为40的元素，则插入一个</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span>; Print(mp.begin(), mp.end());<span class="comment">//输出：3) (40,0)(20,9.3)(15,2.7)</span></span><br><span class="line">	mp[<span class="number">15</span>] = <span class="number">6.28</span>; <span class="comment">//把关键字为15的元素值改成6.28</span></span><br><span class="line">	mp[<span class="number">17</span>] = <span class="number">3.14</span>; <span class="comment">//插入关键字为17的元素，并将其值设为3.14</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) &quot;</span>; Print(mp.begin(), mp.end());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-5-容器适配器"><a href="#10-5-容器适配器" class="headerlink" title="10.5    容器适配器"></a>10.5    容器适配器</h3><p>容器适配器在顺序容器基础上屏蔽了一些功能，增加了另一些功能，它们有以下几个成员函数：<code>push()</code>添加一个元素，<code>top()</code>返回顶部或队头元素的引用，<code>pop()</code>删除一个元素。</p>
<h4 id="10-5-1-stack"><a href="#10-5-1-stack" class="headerlink" title="10.5.1    stack"></a>10.5.1    stack</h4><p>栈是一种后进先出的元素序列，访问删除插入都只能对栈顶进行。使用stack需要包含头文件stack。栈默认用双端队列实现。</p>
<h4 id="10-5-2-queue"><a href="#10-5-2-queue" class="headerlink" title="10.5.2    queue"></a>10.5.2    queue</h4><p>队列是一种先进先出的元素序列，访问删除只能对队头进行，插入只能对队尾进行。使用queue需要包含头文件queue。队列默认用双端队列实现。</p>
<h4 id="10-5-3-priority-queue"><a href="#10-5-3-priority-queue" class="headerlink" title="10.5.3    priority_queue"></a>10.5.3    priority_queue</h4><p>优先队列是一种特殊的队列，它的队头元素总是最大的。使用priority_queue需要包含头文件queue。优先队列默认用可变长数组实现。优先队列使用堆排序实现，其内部并非完全有序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;<span class="keyword">double</span>&gt; pq1;</span><br><span class="line">	pq1.push(<span class="number">3.2</span>); pq1.push(<span class="number">9.8</span>); pq1.push(<span class="number">9.8</span>); pq1.push(<span class="number">5.4</span>);</span><br><span class="line">	<span class="keyword">while</span> (!pq1.empty()) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq1.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pq1.pop();</span><br><span class="line">	&#125; <span class="comment">//上面输出 9.8 9.8 5.4 3.2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">priority_queue</span>&lt;<span class="keyword">double</span>, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;, greater&lt;<span class="keyword">double</span>&gt; &gt; pq2;</span><br><span class="line">	pq2.push(<span class="number">3.2</span>); pq2.push(<span class="number">9.8</span>); pq2.push(<span class="number">9.8</span>); pq2.push(<span class="number">5.4</span>);</span><br><span class="line">	<span class="keyword">while</span> (!pq2.empty()) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pq2.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pq2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面输出 3.2 5.4 9.8 9.8</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-6-STL算法分类"><a href="#10-6-STL算法分类" class="headerlink" title="10.6    STL算法分类"></a>10.6    STL算法分类</h3><p>STL算法分为不变序列算法、变值算法、删除算法、变序算法、排序算法、有序区间算法、数值算法。</p>
<h3 id="10-7-不变序列算法"><a href="#10-7-不变序列算法" class="headerlink" title="10.7    不变序列算法"></a>10.7    不变序列算法</h3><p>此类算法不会修改算法所用的容器或对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span></span>;<span class="comment">//返回x，y中较小的元素</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span></span>;<span class="comment">//返回x，y中较大的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">min_element</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//返回[fist,last)中最小元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">max_element</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//返回[fist,last)中最大元素的迭代器</span></span><br><span class="line"><span class="function">Pred <span class="title">for_each</span><span class="params">(ierator first,iterator last,Pred op)</span></span>;<span class="comment">//对区间[first,last)中的每个元素x都执行op(x)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(iterator first,iterator last,<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//计算区间[first,last)中等于val的元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_if</span><span class="params">(iterator first,iterator last,Pred op)</span></span>;<span class="comment">//计算区间[first,last)中使得op(x)为true的x的个数</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(iterator first,iterator last,<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//返回[first,last)中等于val的元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">find_if</span><span class="params">(iterator first,iterator last,Pred op)</span></span>;<span class="comment">//返回[first,last)中使得op(x)为true的元素x的迭代器</span></span><br><span class="line"><span class="function">iteraior <span class="title">find_end</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2)</span></span>;<span class="comment">//返回[first1,last1)中最后出现序列[first2,last2)的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">find_first_of</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2)</span></span>;<span class="comment">//返回[first2,last2)中的元素（随便哪个都行）在[first1,last1)中最早出现的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">adjacent_find</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//返回最先出现连续两个元素相等的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">search</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2)</span></span>;<span class="comment">//返回[first1,last1)中第一次出现[first2,last2)的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">search_n</span><span class="params">(iterator first,iterator last,T1 count,<span class="keyword">const</span> T2&amp; val)</span></span>;<span class="comment">//返回[first,last)中最早出现的连续count个val的位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(iterator first1,iterator last1,iterator first2)</span></span>;<span class="comment">//判断[first1,lastl)是否和以first2为起点的等长区间中的每个元素都相等</span></span><br><span class="line">pair&lt;iterator,iterator&gt; mismaich(iterator first1,iterator last1,iteraor first2);//逐个比较[first1,last1)和以finst2为起点的等长区间中的元素，返回第一次发生不相等时的两个元素的迭代器</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lexicographical_compare</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2)</span></span>;<span class="comment">//按字典序比较法比较区间[finst1,last1)和[first2,last2)，如果前者更小，则返回true；否则返回false</span></span><br></pre></td></tr></table></figure>
<h3 id="10-8-变值算法"><a href="#10-8-变值算法" class="headerlink" title="10.8    变值算法"></a>10.8    变值算法</h3><p>此类算法会修改源区间或目标区间中元素的值，值被修改的区间不应属于关联容器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(iterator first,iterator last,Pred op);<span class="comment">//对区间[first,last)中的每个元素x都执行op(x)</span></span><br><span class="line"><span class="function">iterator <span class="title">copy</span><span class="params">(iterator first,iterator last,iterator dest)</span></span>;<span class="comment">//将[first,last)复制到从dest开始的地方</span></span><br><span class="line"><span class="function">iterator <span class="title">copy_backwand</span><span class="params">(iterator first,iteraor last,iterator dest)</span></span>;<span class="comment">//将[first,last)复制到[dest-(last-first),dest)，复制从后往前进行</span></span><br><span class="line">transform(iterator first,iteralor last,iterator dest,Pred op);<span class="comment">//对于[first,last)中的每个元素x，将op(x)的返回值放入从dest开始的地方</span></span><br><span class="line">swap_ranges(iterator first1,iterator last1,iterator first2);<span class="comment">//交换[first1,last1)和从first2开始的等长区间的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(iterator first,iterator last,<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//用val填充区间[first,last)</span></span><br><span class="line">fill_n(iterator first,Diff count,<span class="keyword">const</span> T&amp; val);<span class="comment">//用val替换从first开始的count个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(iterator first,iterator last,Pred op)</span></span>;<span class="comment">//用op()的返回值填充[first,last)</span></span><br><span class="line">generate_n(iterator first,Diff count,Pred op);<span class="comment">//用op()的返回值替换从first开始的count个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(iterator first,iterator last,<span class="keyword">const</span> T&amp; oldVal,<span class="keyword">const</span> T&amp; newVal)</span></span>;<span class="comment">//用newVal替换区间[first,last)中的oldVal</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_if</span><span class="params">(iterator first,iterator last,Pred op,<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//对于[first,last)中使得op(x)为true的每个元素x，用val进行替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_copy</span><span class="params">(iterator first,iterator last,Pred op,iterator dest,<span class="keyword">const</span> T&amp; oldVal,<span class="keyword">const</span> T&amp; newVal)</span></span>;<span class="comment">//将[first,last)复制到从dest开始的地方,若碰到源区间的oldVal则不复制，而是复制newVal到目标区间</span></span><br><span class="line">replace_copy_if(iterator first,iterator last,iterator dest,Pred op,<span class="keyword">const</span> T&amp; newVal);<span class="comment">//将区间[first,last)复制到从dest开始的地方。复制过程中，若碰到源区间中的x使得op(x)为ture，则不复制x，而将newVal复制到目标区间</span></span><br></pre></td></tr></table></figure>
<h3 id="10-9-删除算法"><a href="#10-9-删除算法" class="headerlink" title="10.9    删除算法"></a>10.9    删除算法</h3><p>删除算法删除一个容器中某些元素，但不会使容器中元素减少，删除的过程是应删除元素看作空位，剩余元素依次向前移动，最后未被填充的空位维持原来的值不变。不适用于关联容器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">remove</span><span class="params">(iterator first,iterator last.<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//删除[first,last)中等于val的元素，如果n个元素被删除，返回指向第last-n个元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">remove_if</span><span class="params">(iterator first,iterator last,Pred op)</span></span>;<span class="comment">//删除[first,last)中所有使得op(x)为真的x。如果有n个元素被删除，则返回值就是last-n</span></span><br><span class="line"><span class="function">iterator <span class="title">remove_copy</span><span class="params">(iterator first,iterator last,iterator dest,<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//将[first,last)复制到dest开始的地方，等于val的元素不复制</span></span><br><span class="line"><span class="function">iterator <span class="title">remove_copy_if</span><span class="params">(iterator first,iterator last,iterator dest,Pred op)</span></span>;<span class="comment">//将[first,last)复制到dest开始的地方，使得op(x)为真的元素×不复制</span></span><br><span class="line"><span class="function">iterator <span class="title">unique</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//对[first,last)中连续相等的元素，只留下第一个，删除其他元素</span></span><br><span class="line"><span class="function">iterator <span class="title">unique_copy</span><span class="params">(iterator first,iterator last,iterator dest)</span></span>;<span class="comment">//将[first,last)复制到dest开始的地方，对[first,last)中连续相等的元素，只复制第 一个到目标区间，有n个元素被复制返回值就是dest+n</span></span><br></pre></td></tr></table></figure>
<h3 id="10-10-变序算法"><a href="#10-10-变序算法" class="headerlink" title="10.10    变序算法"></a>10.10    变序算法</h3><p>变序算法改变容器中元素顺序，但不改变元素的值。不适用于关联容器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//颠倒区间[first,last)的次序</span></span><br><span class="line"><span class="function">iterator <span class="title">reverse_copy</span><span class="params">(iterator first,iterator last,iterator dest)</span></span>;<span class="comment">//将颠倒次序的[first,last)的内容复制到dest开始处，[frst,last)不变。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(iterator first,iterator newFirst,iterator last)</span></span>;<span class="comment">//将区间[first,last)进行循环左移，即左侧移出去的元素填充右侧。左移后，原*newFirst成为新的区间起点，原*first则被移动到原来first+(last-newFirst)的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">rotate_copy</span><span class="params">(iterator first,iterator newFirst,iterator last,iterator dest)</span></span>;<span class="comment">//将区间[first,last)循环左移后的结果复制到dest开始处,[first,last)不变</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permnutation</span><span class="params">(iteralor first,iterator last)</span></span>;<span class="comment">//将区间[first,last)改为下一个排列。这里所说的“排列”，是“排列组合”这个数学概念中的“排列”。n个元素最多有n!种排列（有可能有重复元素，所以不一定有n!种排列)，把这些排列按字典方式排序后，“上一个排列”或“下一个排列”的说法就是有意义的。例如，“12354”的下一个排列是“12435”，上一个排列是“12345”，而“12345”没有上一个排列，它已经是最小的排列了。如果存在符合要求的排列，该函数返回tnue；否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prev_permutation</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//将区间[first,last)改为上一个排列。如果存在符合要求的排列，该函数返回tnue，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_shuffle</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//将区间[first,last)内元素的顺序随机打乱，调用本算法前，还需要调用随机数发生函数srand以设置随机种子，否则每次程序运行时得到的结果一样</span></span><br><span class="line"><span class="function">iterator <span class="title">partition</span><span class="params">(iterator first,iterator last,Pred op)</span></span>;<span class="comment">//将区间[first,last)中满足op(x)为true的x移动到区间前部，返回值为第一个使得op(x)为false的迭代器</span></span><br></pre></td></tr></table></figure>
<h3 id="10-11-排序算法"><a href="#10-11-排序算法" class="headerlink" title="10.11    排序算法"></a>10.11    排序算法</h3><p>排序算法需随机访问迭代器支持，不适用于关联容器和list，每个排序算法有两个版本，一个使用<code>&lt;</code>，另一个使用<code>Pred op</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//将区间[first,last)排序，一般用快速排序算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stable_sort</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//将区间[first,last)排序，并保持相等元素的先后次序，一般用归并排序算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partial_sort</span><span class="params">(iterator first,iterator mid,iterator last)</span></span>;<span class="comment">//使[first,last)中最小的mid-first个元素就位，一般用堆排序算法实现</span></span><br><span class="line"><span class="function">iterator <span class="title">partial_sort_copy</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2)</span></span>;<span class="comment">//设x=min&#123;last1-first1,last2-first2&#125;，则本算法将区间[first1,last1)的排序结果复制到first2开始处，且只复制排序结果的前×个元素；[first1,last1)保持不变。返回值是first2+x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nth_element</span><span class="params">(iterator first,iterator mid,iterator last)</span></span>;<span class="comment">//对[first,last)进行部分排序，排序后，mid位置的元素x满足以下条件：比x小的都在x的前面，比x大的都在x后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//将区间[first,last)做成一个堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//在区间[first,last-1)已经是堆的情况下将[first,last)变成堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//在[first,last)已经是堆的情况下，将堆中的最大元素，即*first，移动到last-1的位置，原*(last-1)元素移动到前面某个位置且移动后[first,last-1)仍然是堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(iterator first,iterator last)</span></span>;<span class="comment">//在[first,last)已经是堆的情况下,对[first,last)进行排序。排序结束后成为普通的有序区间，不再是堆</span></span><br></pre></td></tr></table></figure>
<h3 id="10-12-有序区间算法"><a href="#10-12-有序区间算法" class="headerlink" title="10.12    有序区间算法"></a>10.12    有序区间算法</h3><p>有序区间算法要求操作区间已经排好序，且需要随机访问迭代器支持，不适用于关联容器和list，每个有序区间算法有两个版本，一个使用<code>&lt;</code>，另一个使用<code>Pred op</code>。算法比较大小的规则必须和排序大小比较规则一致。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(iterator first,iterator last,<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//判断区间[first,last)是否包含val</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">includes</span><span class="params">(iterator firsi1,iterator last1,iterator first2,iterator last2)</span></span>;<span class="comment">//判断是否[first2,last2)中的每个元素都被[firstl,last1)包含,即判断[first2,last2)是否是[firstl,last1)的子集</span></span><br><span class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(iterator first,iterator last,<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//返回一个最大的迭代器it，使得[first,it)中的元素都比val小</span></span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(iterator finst,iterator last,<span class="keyword">const</span> T&amp; val)</span></span>;<span class="comment">//返回一个最小的迭代器it，使得[it,last)中的元素都比val大</span></span><br><span class="line">pair&lt;iterator,iterator&gt; equal_range(iterator first,iterator last,const T&amp; val);//同时计算lower_bound和upper_bound。返回值p是一个pair模板类对象，p.first存放lower_bound的返回值，p.second存放upper_bound的返回值</span><br><span class="line"><span class="function">iterator <span class="title">merge</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2,iterator dest)</span></span>;<span class="comment">//将[firstl,lastl)和[first2,lasti2)的全部内容复制到dest。返回值是dest+(lastl-firstl)+(last2-first2)</span></span><br><span class="line"><span class="function">iterator <span class="title">set_union</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2,iterator dest)</span></span>;<span class="comment">//将[first1,last1)和[first2,last2)的并复制到dest。并的规则是：若元素e在[frst1，last1)中出现n1次，在[first2,last2)中出现n2次，则e在目标区间中出现max(n1,n2)次。假设有n个元素被复制到目标区间，则返回值是dest+n</span></span><br><span class="line"><span class="function">iterator <span class="title">set_intersection</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2,iterator dest)</span></span>;<span class="comment">//将[first1,last1)和[first2,last2)的交复制到dest。交的规则是：若元素e在[first1，last1)中出现n1次，在[first2,last2)中出现n2次，则e在目标区间中出现min(nl,n2)次。假设有n个元素被复制到目标区间，则返回值是dest+n</span></span><br><span class="line"><span class="function">iterator <span class="title">set_difference</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2,iterator dest)</span></span>;<span class="comment">//将[first1,last1)和[first2,last2)的差复制到dest。差的规则是：若元素在[first1，last1)中出现n1次，在[first2,last2)中出现n2次，则e在目标区间中出现max(0,nl-n2)次。假设有n个元素被复制到目标区间，则返回值是dest+n</span></span><br><span class="line"><span class="function">iterator <span class="title">set_symmetric_difference</span><span class="params">(iterator first1,iterator last1,iterator first2,iterator last2,iterator dest)</span></span>;<span class="comment">//将[first1,last1)和[firs2,las2)的对称差复制到dest。对称差的规则是：若元素e有[finsi1,Jastl)中出现n1次，在[firsl2,last2)中出现n2次，则e在目标区间中出现Lnl-n21况假设有n个元素被复制到目标区间，则返回值是dest+n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inplace_merge</span><span class="params">(iterator first,iterator mid,iterator last)</span></span>;<span class="comment">//将有序区间[first,mid)和[mid,last)合并。合并后的区间[first,last)也是有序的</span></span><br></pre></td></tr></table></figure>
<h3 id="10-13-string类详解"><a href="#10-13-string类详解" class="headerlink" title="10.13    string类详解"></a>10.13    string类详解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">()</span></span>;					<span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">4</span>,<span class="string">&#x27;K&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">&quot;12345&quot;</span>,<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s1;						<span class="comment">//赋值</span></span><br><span class="line">s1=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s1=<span class="string">&#x27;K&#x27;</span>;</span><br><span class="line">s1.assign(<span class="string">&quot;12345&quot;</span>);				</span><br><span class="line"><span class="keyword">int</span> l=s1.length();					<span class="comment">//求字符串长度</span></span><br><span class="line">l=s1.size();</span><br><span class="line">string s1(&quot;123&quot;),s2(&quot;abc&quot;);			//字符串连接</span><br><span class="line">s1.append(s2);</span><br><span class="line"><span class="keyword">int</span> n=s1.compare(s2);				<span class="comment">//string的比较</span></span><br><span class="line">n=s1.compare(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;Hello&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;this is ok&quot;</span>;				<span class="comment">//求string的子串</span></span><br><span class="line"><span class="built_in">string</span> s2=s1.substr(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">s2=s1.substr(<span class="number">2</span>);</span><br><span class="line">s1.swap(s2);						<span class="comment">//交换string的内容</span></span><br><span class="line">s1.find(<span class="string">&quot;abc&quot;</span>);						<span class="comment">//查找子串和字符</span></span><br><span class="line">s1.rfind(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.find_first_of(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.find_last_of(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.find_first_not_of(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.find_last_not_of(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.replace(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">2</span>,<span class="number">4</span>);			<span class="comment">//替换子串</span></span><br><span class="line">s1.erase(<span class="number">1</span>,<span class="number">3</span>);						<span class="comment">//删除子串</span></span><br><span class="line">s1.insert(<span class="number">2</span>,<span class="string">&quot;123&quot;</span>);					<span class="comment">//插入字符串</span></span><br></pre></td></tr></table></figure>
<p>使用流对象可以把string对象当作流输入输出。需要包含头文件sstream。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">src</span><span class="params">(<span class="string">&quot;Avatar 123 5.2 Titanic K&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">istringstream</span> <span class="title">istrStream</span><span class="params">(src)</span></span>; <span class="comment">//建立src到istrStream的联系</span></span><br><span class="line">	<span class="built_in">string</span> s1, s2;</span><br><span class="line">	<span class="keyword">int</span> n;  <span class="keyword">double</span> d;  <span class="keyword">char</span> c;</span><br><span class="line">	istrStream &gt;&gt; s1 &gt;&gt; n &gt;&gt; d &gt;&gt; s2 &gt;&gt; c; <span class="comment">//把src的内容当做输入流进行读取</span></span><br><span class="line">	<span class="built_in">ostringstream</span> ostrStream;</span><br><span class="line">	ostrStream &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ostrStream.str();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>string对象可看作顺序容器，支持随机访问迭代器，可以使用STL算法操作string对象。</p>
<h3 id="10-14-bitset对象"><a href="#10-14-bitset对象" class="headerlink" title="10.14    bitset对象"></a>10.14    bitset对象</h3><p>bitset对象由若干个位组成，可以不必通过位运算就能方便地访问修改其中任意一位，需要包含头文件bitset。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;7&gt; bst1;</span><br><span class="line">	<span class="built_in">bitset</span>&lt;7&gt; bst2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 1) 0000000</span></span><br><span class="line">	bst1.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//将第0位变成1，bst1变为 0000001</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 2) 0000001</span></span><br><span class="line">	bst1 &lt;&lt;= <span class="number">4</span>; <span class="comment">//左移4位，变为 0010000</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3) 0010000</span></span><br><span class="line">	bst2.<span class="built_in">set</span>(<span class="number">2</span>);<span class="comment">//第二位设置为1，bst2变成  0000100</span></span><br><span class="line">	bst2 |= bst1; <span class="comment">// bst2变成  0010100</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) &quot;</span> &lt;&lt; bst2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 4) 0010100</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5) &quot;</span> &lt;&lt; bst2.to_ulong() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 5) 20</span></span><br><span class="line">	bst2.flip(); <span class="comment">//每一位都取反，bst2变成 1101011</span></span><br><span class="line">	bst1.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//bst1变成  0011000</span></span><br><span class="line">	bst2.flip(<span class="number">6</span>); <span class="comment">//bst2变成 0101011</span></span><br><span class="line">	<span class="built_in">bitset</span>&lt;7&gt; bst3 = bst2 ^ bst1;<span class="comment">//bst3 变成 0110011</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6) &quot;</span> &lt;&lt; bst3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 6) 0110011</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;7) &quot;</span> &lt;&lt; bst3[<span class="number">3</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; bst3[<span class="number">4</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 7) 0,1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十一-C-高级主题"><a href="#十一-C-高级主题" class="headerlink" title="十一    C++高级主题"></a>十一    C++高级主题</h2><h3 id="11-1-static-cast、reinterpret-cast、const-cast、dynamic-cast"><a href="#11-1-static-cast、reinterpret-cast、const-cast、dynamic-cast" class="headerlink" title="11.1    static_cast、reinterpret_cast、const_cast、dynamic_cast"></a>11.1    static_cast、reinterpret_cast、const_cast、dynamic_cast</h3><p>C语言的强制类型转换是有风险的，C++引入了四种强制类型转换运算符进行强制类型转换。</p>
<h4 id="11-1-1-static-cast"><a href="#11-1-1-static-cast" class="headerlink" title="11.1.1    static_cast"></a>11.1.1    static_cast</h4><p>static_cast提供低风险转换，如整型、浮点型、字符型的转换，不支持指针和引用的转换。</p>
<h4 id="11-1-2-reinterpret-cast"><a href="#11-1-2-reinterpret-cast" class="headerlink" title="11.1.2    reinterpret_cast"></a>11.1.2    reinterpret_cast</h4><p>用于不同类型的指针、不同类型的引用之间的转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	A(<span class="keyword">int</span> n) :i(n), j(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; r = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(a); <span class="comment">//强行让 r 引用 a</span></span><br><span class="line">	r = <span class="number">200</span>;  <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a.i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.j &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 200,100</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">300</span>;</span><br><span class="line">	A* pa = <span class="keyword">reinterpret_cast</span>&lt;A*&gt; (&amp;n); <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">	pa-&gt;i = <span class="number">400</span>;	 <span class="comment">// n 变成 400</span></span><br><span class="line">	pa-&gt;j = <span class="number">500</span>;  <span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 400</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> la = <span class="number">0x12345678abcd</span>LL;</span><br><span class="line">	pa = <span class="keyword">reinterpret_cast</span>&lt;A*&gt;(la); <span class="comment">//la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> u = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(pa);<span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; u &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5678abcd</span></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PF1)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF2)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">	PF1 pf1;	  PF2 pf2;</span><br><span class="line">	pf2 = <span class="keyword">reinterpret_cast</span>&lt;PF2&gt;(pf1); <span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-1-3-const-cast"><a href="#11-1-3-const-cast" class="headerlink" title="11.1.3    const_cast"></a>11.1.3    const_cast</h4><p>仅用于去除const属性的转换。</p>
<h4 id="11-1-4-dynamic-cast"><a href="#11-1-4-dynamic-cast" class="headerlink" title="11.1.4    dynamic_cast"></a>11.1.4    dynamic_cast</h4><p>专门用于将多态基类的指针或引用强制转换为派生类的指针或引用。不能用于非多态基类指针或引用的转换。</p>
<h3 id="11-2-C-异常处理"><a href="#11-2-C-异常处理" class="headerlink" title="11.2    C++异常处理"></a>11.2    C++异常处理</h3><h4 id="11-2-1-什么是异常处理"><a href="#11-2-1-什么是异常处理" class="headerlink" title="11.2.1    什么是异常处理"></a>11.2.1    什么是异常处理</h4><p>程序运行时会碰到一些异常情况，C++异常处理机制能够在发生异常时让程序执行到同一个地方，能够对异常进行集中处理，程序会更容易编写和维护。</p>
<h4 id="11-2-2-C-异常处理基本语法"><a href="#11-2-2-C-异常处理基本语法" class="headerlink" title="11.2.2    C++异常处理基本语法"></a>11.2.2    C++异常处理基本语法</h4><p>C++通过throw和try…catch语句实现异常处理，处理过程是执行try块语句，若没有异常抛出则执行最后一个catch块后的语句，若抛出异常则跳转到第一个异常类型匹配的catch块执行，执行完后跳转到最后一个catch块后继续执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> m, n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> - <span class="number">1</span>; <span class="comment">//抛出int类型异常</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; m / n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">double</span> d) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;catch(double) &quot;</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">int</span> e) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;catch(int) &quot;</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-3-能够捕获任何异常的catch语句"><a href="#11-2-3-能够捕获任何异常的catch语句" class="headerlink" title="11.2.3    能够捕获任何异常的catch语句"></a>11.2.3    能够捕获任何异常的catch语句</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(...)<span class="comment">//这个语句可以捕获任何未被捕获的异常</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-4-异常的再抛出"><a href="#11-2-4-异常的再抛出" class="headerlink" title="11.2.4    异常的再抛出"></a>11.2.4    异常的再抛出</h4><p>有时虽然函数中对异常进行处理，但还是希望能通知调用者，在catch块中抛出异常能够满足这种需要。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountTax</span><span class="params">(<span class="keyword">int</span> salary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (salary &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;zero salary&quot;</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;counting tax&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="built_in">string</span> s) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CountTax error : &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">throw</span>; <span class="comment">//继续抛出捕获的异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;tax counted&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> salary * <span class="number">0.15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> f = <span class="number">1.2</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		CountTax(<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;end of try block&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="built_in">string</span> s) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-5-函数的异常声明列表"><a href="#11-2-5-函数的异常声明列表" class="headerlink" title="11.2.5    函数的异常声明列表"></a>11.2.5    函数的异常声明列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span><span class="title">throw</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">double</span>,A,B,C)</span><span class="comment">//可能抛出的异常列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span><span class="title">throw</span><span class="params">()</span></span>;<span class="comment">//不会抛出任何异常</span></span><br></pre></td></tr></table></figure>
<h4 id="11-2-6-C-标准异常类"><a href="#11-2-6-C-标准异常类" class="headerlink" title="11.2.6    C++标准异常类"></a>11.2.6    C++标准异常类</h4><p>C++标准库有一些类代表异常，这些类都从exception类派生来。bad_typeid类用于操作数是一个多态类指针且该指针值为NULL，bad_cast用于dynamic_cast强制类型转换不安全，bad_alloc用于动态内存分配没有足够内存，out_of_range用于下标越界。</p>
<h3 id="11-3-C-11新特性概要"><a href="#11-3-C-11新特性概要" class="headerlink" title="11.3    C++11新特性概要"></a>11.3    C++11新特性概要</h3><h4 id="11-3-1-智能指针shared-ptr"><a href="#11-3-1-智能指针shared-ptr" class="headerlink" title="11.3.1    智能指针shared_ptr"></a>11.3.1    智能指针shared_ptr</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	A(<span class="keyword">int</span> n) :i(n) &#123; &#125;;</span><br><span class="line">	~A() &#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;destructed&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A(<span class="number">2</span>))</span></span>; <span class="comment">//A(2)由sp1托管，</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;       <span class="comment">//A(2)同时交由sp2托管</span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; sp3;</span><br><span class="line">	sp3 = sp2;   <span class="comment">//A(2)同时交由sp3托管</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sp1-&gt;i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sp2-&gt;i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sp3-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	A* p = sp3.get();      <span class="comment">// get返回托管的指针，p 指向 A(2)</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2</span></span><br><span class="line">	sp1.reset(<span class="keyword">new</span> A(<span class="number">3</span>));    <span class="comment">// reset导致托管新的指针, 此时sp1托管A(3)</span></span><br><span class="line">	sp2.reset(<span class="keyword">new</span> A(<span class="number">4</span>));    <span class="comment">// sp2托管A(4)</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sp1-&gt;i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3</span></span><br><span class="line">	sp3.reset(<span class="keyword">new</span> A(<span class="number">5</span>));    <span class="comment">// sp3托管A(5),A(2)无人托管，被delete</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-2-无序容器（哈希表）"><a href="#11-3-2-无序容器（哈希表）" class="headerlink" title="11.3.2    无序容器（哈希表）"></a>11.3.2    无序容器（哈希表）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; a;<span class="comment">//四种无序容器都实现了哈希表，哈希表和关联容器类似，但查找时间比关联容器更快</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="built_in">unordered_multimap</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="built_in">unordered_multiset</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; a;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-3-正则表达式"><a href="#11-3-3-正则表达式" class="headerlink" title="11.3.3    正则表达式"></a>11.3.3    正则表达式</h4><p>正则表达式用于非常灵活的字符串匹配查找和替换。<code>.</code>代表任意一个字符，<code>*</code>代表出现零次或更多次的字符，<code>+</code>代表出现一次或更多次的字符，<code>?</code>代表出现零次或一次的字符，<code>\d</code>代表后面出现数字，<code>\s</code>代表空格，<code>()</code>中内容是项，<code>\1</code>代表此处出现第一项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt; //使用正则表达式须包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">&quot;b.?p.*k&quot;</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; regex_match(<span class="string">&quot;bopggk&quot;</span>, reg) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//输出 1 表示匹配成功</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; regex_match(<span class="string">&quot;boopgggk&quot;</span>, reg) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 0 表示匹配失败</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; regex_match(<span class="string">&quot;b pk&quot;</span>, reg) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//输出 1 表示匹配成功</span></span><br><span class="line">	<span class="function">regex <span class="title">reg2</span><span class="params">(<span class="string">&quot;\\d&#123;3&#125;([a-zA-Z]+).(\\d&#123;2&#125;|N/A)\\s\\1&quot;</span>)</span></span>;</span><br><span class="line">	<span class="built_in">string</span> correct = <span class="string">&quot;123Hello N/A Hello&quot;</span>;</span><br><span class="line">	<span class="built_in">string</span> incorrect = <span class="string">&quot;123Hello 12 hello&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; regex_match(correct, reg2) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//输出 1 表示匹配成功</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; regex_match(incorrect, reg2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 0 表示匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-4-Lambda表达式"><a href="#11-3-4-Lambda表达式" class="headerlink" title="11.3.4    Lambda表达式"></a>11.3.4    Lambda表达式</h4><p>对于只使用一次的函数对象，可以使用Lambda表达式代替，使得程序更加优雅。Lambda表达式实际上是没有名字的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>]=&#123;<span class="number">11</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">4</span>&#125;;</span><br><span class="line">sort(a,a+<span class="number">4</span>,[=](<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> x%<span class="number">10</span>&lt;y%<span class="number">10</span>;&#125;);<span class="comment">//=表示不允许定义在&#123;&#125;外部的变量被表达式改变</span></span><br><span class="line">for_each(a,a+<span class="number">4</span>,[=](<span class="keyword">int</span> x)&#123;<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;)<span class="comment">//-&gt;和返回值类型可以省略</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">100</span>, y = <span class="number">200</span>, z = <span class="number">300</span>;</span><br><span class="line">	<span class="keyword">auto</span> ff = [=, &amp;y, &amp;z](<span class="keyword">int</span> n) &#123;<span class="comment">//外部变量y,z可以被修改</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		y++; z++;</span><br><span class="line">		<span class="keyword">return</span> n * n;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ff(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//将Lambda表达式值赋给ff，可通过其调用表达式</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-5-auto关键字和decltype关键字"><a href="#11-3-5-auto关键字和decltype关键字" class="headerlink" title="11.3.5    auto关键字和decltype关键字"></a>11.3.5    auto关键字和decltype关键字</h4><p>auto关键字定义的变量，编译器会自动判断其类型。decltype(表达式)用于求表达式的类型。这在类型过长或不易推导时很方便。</p>
<h4 id="11-3-6-基于范围的for循环"><a href="#11-3-6-基于范围的for循环" class="headerlink" title="11.3.6    基于范围的for循环"></a>11.3.6    基于范围的for循环</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="keyword">int</span> n;	A(<span class="keyword">int</span> i) :n(i) &#123;	&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ary[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>&amp; e : ary)  	<span class="comment">//将ary中每个元素都乘以10</span></span><br><span class="line">		e *= <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> e : ary)	    <span class="comment">//输出ary中所有元素</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;A&gt; <span class="title">st</span><span class="params">(ary, ary + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : st)  <span class="comment">//将st中每个元素都乘以10</span></span><br><span class="line">		it.n *= <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">for</span> (A it : st)   <span class="comment">//输出st中所有元素</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it.n &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-7-右值引用"><a href="#11-3-7-右值引用" class="headerlink" title="11.3.7    右值引用"></a>11.3.7    右值引用</h4><p>能出现在赋值号左边的表达式称为左值，不能的称为右值。左值可以取地址而右值不可以。一般的引用都是引用变量的，故为左值引用。const变量、非引用的函数返回值、无名的临时变量都是右值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line">A&amp; r1=A();<span class="comment">//错误，A()是右值</span></span><br><span class="line">A&amp;&amp; r2=A();<span class="comment">//正确，r2是右值引用</span></span><br></pre></td></tr></table></figure>
<p>右值引用可以在对象复制时避免没有必要的深复制操作，提高程序运行效率。</p>
<h2 id="附录-魔兽世界大作业"><a href="#附录-魔兽世界大作业" class="headerlink" title="附录    魔兽世界大作业"></a>附录    魔兽世界大作业</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>魔兽世界的西面是红魔军的司令部，东面是蓝魔军的司令部。两个司令部之间是依次排列的若干城市，城市从西向东依次编号为1,2,3 …. N ( N &lt;= 20 )。红魔军的司令部算作编号为0的城市，蓝魔军的司令部算作编号为N+1的城市。司令部有生命元，用于制造武士。</p>
<p>两军的司令部都会制造武士。武士一共有 dragon 、ninja、iceman、lion、wolf 五种。每种武士都有编号、生命值、攻击力这三种属性。</p>
<p>双方的武士编号都是从1开始计算。红方制造出来的第 n 个武士，编号就是n。同样，蓝方制造出来的第 n 个武士，编号也是n。</p>
<p>武士在刚降生的时候有一个初始的生命值，生命值在战斗中会发生变化，如果生命值减少到0（生命值变为负数时应当做变为0处理），则武士死亡（消失）。</p>
<p>有的武士可以拥有武器。武器有三种，sword, bomb,和arrow，编号分别为0,1,2。</p>
<p>武士降生后就朝对方司令部走，在经过的城市如果遇到敌人（同一时刻每个城市最多只可能有1个蓝武士和一个红武士），就会发生战斗。每次战斗只有一方发起主动进攻一次。被攻击者生命值会减去进攻者的攻击力值和进攻者手中sword的攻击力值。被进攻者若没死，就会发起反击，被反击者的生命值要减去反击者攻击力值的一半(去尾取整)和反击者手中sword的攻击力值。反击可能致敌人于死地。</p>
<p>如果武士在战斗中杀死敌人（不论是主动进攻杀死还是反击杀死），则其司令部会立即向其发送8个生命元作为奖励，使其生命值增加8。当然前提是司令部得有8个生命元。如果司令部的生命元不足以奖励所有的武士，则优先奖励距离敌方司令部近的武士。</p>
<p>如果某武士在某城市的战斗中杀死了敌人，则该武士的司令部立即取得该城市中所有的生命元。注意，司令部总是先完成全部奖励工作，然后才开始从各个打了胜仗的城市回收生命元。对于因司令部生命元不足而领不到奖励的武士，司令部也不会在取得战利品生命元后为其补发奖励。</p>
<p>如果一次战斗的结果是双方都幸存(平局)，则双方都不能拿走发生战斗的城市的生命元。</p>
<p>城市可以插旗子，一开始所有城市都没有旗子。在插红旗的城市，以及编号为奇数的无旗城市，由红武士主动发起进攻。在插蓝旗的城市，以及编号为偶数的无旗城市，由蓝武士主动发起进攻。</p>
<p>当某个城市有连续两场战斗都是同一方的武士杀死敌人(两场战斗之间如果有若干个战斗时刻并没有发生战斗，则这两场战斗仍然算是连续的；但如果中间有平局的战斗，就不算连续了) ，那么该城市就会插上胜方的旗帜，若原来插着败方的旗帜，则败方旗帜落下。旗帜一旦插上，就一直插着，直到被敌人更换。一个城市最多只能插一面旗帜，旗帜没被敌人更换前，也不会再次插同颜色的旗。</p>
<p>各种武器有其特点：</p>
<p>sword武器的初始攻击力为拥有它的武士的攻击力的20%（去尾取整）。但是sword每经过一次战斗(不论是主动攻击还是反击)，就会变钝，攻击力变为本次战斗前的80% (去尾取整)。sword攻击力变为0时，视为武士失去了sword。如果武士降生时得到了一个初始攻击力为0的sword，则视为武士没有sword.</p>
<p>arrow有一个攻击力值R。如果下一步要走到的城市有敌人，那么拥有arrow的武士就会放箭攻击下一个城市的敌人（不能攻击对方司令部里的敌人）而不被还击。arrow使敌人的生命值减少R，若减至小于等于0，则敌人被杀死。arrow使用3次后即被耗尽，武士失去arrow。两个相邻的武士可能同时放箭把对方射死。</p>
<p>拥有bomb的武士，在战斗开始前如果判断自己将被杀死（不论主动攻击敌人，或者被敌人主动攻击都可能导致自己被杀死，而且假设武士可以知道敌人的攻击力和生命值），那么就会使用bomb和敌人同归于尽。武士不预测对方是否会使用bomb。</p>
<p>武士使用bomb和敌人同归于尽的情况下，不算是一场战斗，双方都不能拿走城市的生命元，也不影响城市的旗帜。</p>
<p>不同的武士有不同的特点。</p>
<p>dragon可以拥有一件武器。编号为n的dragon降生时即获得编号为 n%3 的武器。dragon还有“士气”这个属性，是个浮点数，其值为它降生后其司令部剩余生命元的数量除以造dragon所需的生命元数量。dragon 在一次在它主动进攻的战斗结束后，如果还没有战死，而且士气值大于0.8，就会欢呼。dragon每取得一次战斗的胜利(敌人被杀死)，士气就会增加0.2，每经历一次未能获胜的战斗，士气值就会减少0.2。士气增减发生在欢呼之前。</p>
<p>ninja可以拥有两件武器。编号为n的ninja降生时即获得编号为 n%3 和 (n+1)%3的武器。ninja 挨打了也从不反击敌人。</p>
<p>iceman有一件武器。编号为n的iceman降生时即获得编号为 n%3 的武器。iceman 每前进两步，在第2步完成的时候，生命值会减少9，攻击力会增加20。但是若生命值减9后会小于等于0，则生命值不减9,而是变为1。即iceman不会因走多了而死。</p>
<p>lion 有“忠诚度”这个属性，其初始值等于它降生之后其司令部剩余生命元的数目。每经过一场未能杀死敌人的战斗，忠诚度就降低K。忠诚度降至0或0以下，则该lion逃离战场,永远消失。但是已经到达敌人司令部的lion不会逃跑。Lion在己方司令部可能逃跑。lion 若是战死，则其战斗前的生命值就会转移到对手身上。所谓“战斗前”，就是每个小时的40分前的一瞬间。</p>
<p>wolf降生时没有武器，但是在战斗中如果获胜（杀死敌人），就会缴获敌人的武器，但自己已有的武器就不缴获了。被缴获的武器当然不能算新的，已经被用到什么样了，就是什么样的。</p>
<p>以下是不同时间会发生的不同事件：</p>
<p>在每个整点，即每个小时的第0分， 双方的司令部中各有一个武士降生。</p>
<p>红方司令部按照 iceman、lion、wolf、ninja、dragon 的顺序制造武士。</p>
<p>蓝方司令部按照 lion、dragon、ninja、iceman、wolf 的顺序制造武士。</p>
<p>制造武士需要生命元。</p>
<p>制造一个初始生命值为 m 的武士，司令部中的生命元就要减少 m 个。</p>
<p>如果司令部中的生命元不足以制造某武士，那么司令部就等待，直到获得足够生命元后的第一个整点，才制造该武士。例如，在2:00，红方司令部本该制造一个 wolf ，如果此时生命元不足，那么就会等待，直到生命元足够后的下一个整点，才制造一个 wolf。</p>
<p>在每个小时的第5分，该逃跑的lion就在这一时刻逃跑了。</p>
<p>在每个小时的第10分：所有的武士朝敌人司令部方向前进一步。即从己方司令部走到相邻城市，或从一个城市走到下一个城市。或从和敌军司令部相邻的城市到达敌军司令部。</p>
<p>在每个小时的第20分：每个城市产出10个生命元。生命元留在城市，直到被武士取走。</p>
<p>在每个小时的第30分：如果某个城市中只有一个武士，那么该武士取走该城市中的所有生命元，并立即将这些生命元传送到其所属的司令部。</p>
<p>在每个小时的第35分，拥有arrow的武士放箭，对敌人造成伤害。放箭事件应算发生在箭发出的城市。注意，放箭不算是战斗，因此放箭的武士不会得到任何好处。武士在没有敌人的城市被箭射死也不影响其所在城市的旗帜更换情况。</p>
<p>在每个小时的第38分，拥有bomb的武士评估是否应该使用bomb。如果是，就用bomb和敌人同归于尽。</p>
<p>在每个小时的第40分：在有两个武士的城市，会发生战斗。 如果敌人在5分钟前已经被飞来的arrow射死，那么仍然视为发生了一场战斗，而且存活者视为获得了战斗的胜利。此情况下不会有“武士主动攻击”，“武士反击”，“武士战死”的事件发生，但战斗胜利后应该发生的事情都会发生。如Wolf一样能缴获武器，旗帜也可能更换，等等。在此情况下,Dragon同样会通过判断是否应该轮到自己主动攻击来决定是否欢呼。</p>
<p>在每个小时的第50分，司令部报告它拥有的生命元数量。</p>
<p>在每个小时的第55分，每个武士报告其拥有的武器情况。</p>
<p>武士到达对方司令部后就算完成任务了，从此就呆在那里无所事事。</p>
<p>任何一方的司令部里若是出现了2个敌人，则认为该司令部已被敌人占领。</p>
<p>任何一方的司令部被敌人占领，则战争结束。战争结束之后就不会发生任何事情了。</p>
<p>给定一个时间，要求你将从0点0分开始到此时间为止的所有事件按顺序输出。事件及其对应的输出样例如下：</p>
<ul>
<li><p>1) 武士降生</p>
<p>输出样例： 000:00 blue lion 1 born表示在 0点0分，编号为1的蓝魔lion武士降生 如果造出的是dragon，那么还要多输出一行，例：000:00 blue dragon 1 born Its morale is 23.34  表示该该dragon降生时士气是23. 34(四舍五入到小数点后两位)如果造出的是lion，那么还要多输出一行，例: 000:00 blue lion 1 born Its loyalty is 24  表示该lion降生时的忠诚度是24</p>
</li>
<li><p>2) lion逃跑</p>
<p>输出样例： 000:05 blue lion 1 ran away 表示在 0点5分，编号为1的蓝魔lion武士逃走</p>
</li>
<li><p>3) 武士前进到某一城市</p>
<p>输出样例： 000:10 red iceman 1 marched to city 1 with 20 elements and force 30 表示在 0点10分，红魔1号武士iceman前进到1号城市，此时他生命值为20,攻击力为30 对于iceman,输出的生命值和攻击力应该是变化后的数值</p>
</li>
<li><p>4)武士放箭</p>
<p>输出样例： 000:35 blue dragon 1 shot 表示在 0点35分，编号为1的蓝魔dragon武士射出一支箭。如果射出的箭杀死了敌人，则应如下输出： 000:35 blue dragon 1 shot and killed red lion 4 表示在 0点35分，编号为1的蓝魔dragon武士射出一支箭，杀死了编号为4的红魔lion。</p>
</li>
<li><p>5)武士使用bomb</p>
<p>输出样例： 000:38 blue dragon 1 used a bomb and killed red lion 7 表示在 0点38分，编号为1的蓝魔dragon武士用炸弹和编号为7的红魔lion同归于尽。</p>
</li>
<li><p>6) 武士主动进攻</p>
<p>输出样例：000:40 red iceman 1 attacked blue lion 1 in city 1 with 20 elements and force 30 表示在0点40分，1号城市中，红魔1号武士iceman 进攻蓝魔1号武士lion,在发起进攻前，红魔1号武士iceman生命值为20，攻击力为 30</p>
</li>
<li><p>7) 武士反击</p>
<p>输出样例：001:40 blue dragon 2 fought back against red lion 2 in city 1 表示在1点40分，1号城市中，蓝魔2号武士dragon反击红魔2号武士lion</p>
</li>
<li><p>8) 武士战死</p>
<p>输出样例：001:40 red lion 2 was killed in city 1 被箭射死的武士就不会有这一条输出。</p>
</li>
<li><p>9) 武士欢呼</p>
<p>输出样例：003:40 blue dragon 2 yelled in city 4</p>
</li>
<li><p>10) 武士获取生命元( elements )</p>
<p>输出样例：001:40 blue dragon 2 earned 10 elements for his headquarter</p>
<p>输出不包括在30分不是通过战斗获取的elements</p>
</li>
<li><p>11) 旗帜升起</p>
<p>输出样例：004:40 blue flag raised in city 4</p>
</li>
<li><p>12) 武士抵达敌军司令部</p>
<p>输出样例：001:10 red iceman 1 reached blue headquarter with 20 elements and force 30 (此时他生命值为20,攻击力为30）对于iceman,输出的生命值和攻击力应该是变化后的数值</p>
</li>
<li><p>13) 司令部被占领</p>
<p>输出样例：003:10 blue headquarter was taken</p>
</li>
<li><p>14)司令部报告生命元数量</p>
<p>000:50 100 elements in red headquarter 000:50 120 elements in blue headquarter 表示在0点50分，红方司令部有100个生命元，蓝方有120个</p>
</li>
<li><p>15)武士报告武器情况</p>
<p>000:55 blue wolf 2 has arrow(2),bomb,sword(23) 000:55 blue wolf 4 has no weapon 000:55 blue wolf 5 has sword(20) 表示在0点55分，蓝魔2号武士wolf有一支arrow（这支arrow还可以用2次），一个bomb，还有一支攻击力为23的sword。 蓝魔4号武士wolf没武器。 蓝魔5号武士wolf有一支攻击力为20的sword。 交代武器情况时，次序依次是：arrow,bomb,sword。如果没有某种武器，某种武器就不用提。报告时，先按从西向东的顺序所有的红武士报告，然后再从西向东所有的蓝武士报告。</p>
</li>
</ul>
<p>输出事件时：</p>
<p>首先按时间顺序输出；</p>
<p>同一时间发生的事件，按发生地点从西向东依次输出. 武士前进的事件, 算是发生在目的地。</p>
<p>在一次战斗中有可能发生上面的 6 至 11 号事件。这些事件都算同时发生，其时间就是战斗开始时间。一次战斗中的这些事件，序号小的应该先输出。</p>
<p>两个武士同时抵达同一城市，则先输出红武士的前进事件，后输出蓝武士的。</p>
<p>显然，13号事件发生之前的一瞬间一定发生了12号事件。输出时，这两件事算同一时间发生，但是应先输出12号事件</p>
<p>虽然任何一方的司令部被占领之后，就不会有任何事情发生了。但和司令部被占领同时发生的事件，全都要输出。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行是t,代表测试数据组数</p>
<p>每组样例共三行。</p>
<p>第一行，五个整数 M,N,R,K, T。其含义为：</p>
<p>每个司令部一开始都有M个生命元( 1 &lt;= M &lt;= 10000)</p>
<p>两个司令部之间一共有N个城市( 1 &lt;= N &lt;= 20 )</p>
<p>arrow的攻击力是R</p>
<p>lion每经过一场未能杀死敌人的战斗，忠诚度就降低K。</p>
<p>要求输出从0时0分开始，到时间T为止(包括T) 的所有事件。T以分钟为单位，0 &lt;= T &lt;= 5000</p>
<p>第二行：五个整数，依次是 dragon 、ninja、iceman、lion、wolf 的初始生命值。它们都大于0小于等于10000</p>
<p>第三行：五个整数，依次是 dragon 、ninja、iceman、lion、wolf 的攻击力。它们都大于0小于等于10000</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对每组数据，先输出一行：</p>
<p>Case n:</p>
<p>如对第一组数据就输出 Case1:</p>
<p>然后按恰当的顺序和格式输出到时间T为止发生的所有事件。每个事件都以事件发生的时间开头，时间格式是“时: 分”，“时”有三位，“分”有两位。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">20 1 10 10 1000</span><br><span class="line">20 20 30 10 20</span><br><span class="line">5 5 5 5 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">000:00 blue lion 1 born</span><br><span class="line">Its loyalty is 10</span><br><span class="line">000:10 blue lion 1 marched to city 1 with 10 elements and force 5</span><br><span class="line">000:30 blue lion 1 earned 10 elements for his headquarter</span><br><span class="line">000:50 20 elements in red headquarter</span><br><span class="line">000:50 20 elements in blue headquarter</span><br><span class="line">000:55 blue lion 1 has no weapon</span><br><span class="line">001:00 blue dragon 2 born</span><br><span class="line">Its morale is 0.00</span><br><span class="line">001:10 blue lion 1 reached red headquarter with 10 elements and force 5</span><br><span class="line">001:10 blue dragon 2 marched to city 1 with 20 elements and force 5</span><br><span class="line">001:30 blue dragon 2 earned 10 elements for his headquarter</span><br><span class="line">001:50 20 elements in red headquarter</span><br><span class="line">001:50 10 elements in blue headquarter</span><br><span class="line">001:55 blue lion 1 has no weapon</span><br><span class="line">001:55 blue dragon 2 has arrow(3)</span><br><span class="line">002:10 blue dragon 2 reached red headquarter with 20 elements and force 5</span><br><span class="line">002:10 red headquarter was taken</span><br></pre></td></tr></table></figure>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//魔兽世界终极版 by tetrahedron</span></span><br><span class="line"><span class="comment">//2020-4-18</span></span><br><span class="line"><span class="comment">//写得很烂，完全没有用继承和多态</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VACANT 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRAGON 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	NINJA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICEMAN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LION 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WOLF 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWORD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOMB 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARROW 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 10000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> M, N, R, K, T, HOUR, MIN, h, m;<span class="comment">//司令部初始生命，城市数，arrow攻击力，忠诚度降低数，终止时间，小时和分钟</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* S[] = &#123; <span class="string">&quot;dragon&quot;</span>,<span class="string">&quot;ninja&quot;</span>,<span class="string">&quot;iceman&quot;</span>,<span class="string">&quot;lion&quot;</span>,<span class="string">&quot;wolf&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* W[] = &#123; <span class="string">&quot;sword&quot;</span>,<span class="string">&quot;bomb&quot;</span>,<span class="string">&quot;arrow&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* B[] = &#123; <span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CREATE[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;<span class="comment">//红方和蓝方生成武士的顺序</span></span><br><span class="line"><span class="keyword">int</span> HP[<span class="number">5</span>], ATK[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">now</span><span class="params">()</span> </span>&#123;<span class="comment">//输出当前时间</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; setfill(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; h &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; setfill(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; m &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">weapon</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> atk;		<span class="comment">//武器攻击力</span></span><br><span class="line">	<span class="keyword">int</span> id;			<span class="comment">//默认编号，即WEAPON中编号</span></span><br><span class="line">	<span class="keyword">int</span> dur;		<span class="comment">//耐久</span></span><br><span class="line">	weapon(<span class="keyword">int</span> id_, <span class="keyword">int</span> atk_) :id(id_) &#123;</span><br><span class="line">		<span class="keyword">if</span> (id == SWORD) atk = atk_ * <span class="number">2</span> / <span class="number">10</span>, dur = INF;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (id == BOMB) atk = INF, dur = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> atk = R, dur = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> flag;		<span class="comment">//红0蓝1</span></span><br><span class="line">	<span class="keyword">int</span> hp;			<span class="comment">//生命</span></span><br><span class="line">	<span class="keyword">int</span> n;			<span class="comment">//位置红0蓝N+1</span></span><br><span class="line">	<span class="keyword">int</span> snum;		<span class="comment">//当前武士编号，需要出生的武士编号要+1</span></span><br><span class="line">	<span class="keyword">int</span> taken;		<span class="comment">//是否已有1个对方武士</span></span><br><span class="line">&#125; b[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solider</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> n;			<span class="comment">//在某一方中编号，即第n个生产出的武士</span></span><br><span class="line">	<span class="keyword">int</span> id;			<span class="comment">//默认编号，即SOLIDER中编号</span></span><br><span class="line">	<span class="keyword">int</span> flag;		<span class="comment">//红方0或蓝方1</span></span><br><span class="line">	<span class="keyword">int</span> hp;			<span class="comment">//生命值</span></span><br><span class="line">	<span class="keyword">int</span> hpp;		<span class="comment">//开战前生命值</span></span><br><span class="line">	<span class="keyword">int</span> atk;		<span class="comment">//攻击力</span></span><br><span class="line">	<span class="keyword">int</span> loyalty;	<span class="comment">//lion专属忠诚</span></span><br><span class="line">	<span class="keyword">double</span> morale;	<span class="comment">//dragon专属士气</span></span><br><span class="line">	weapon* w[<span class="number">3</span>];	<span class="comment">//武士拥有的武器</span></span><br><span class="line">	<span class="keyword">bool</span> yell;</span><br><span class="line">	<span class="keyword">bool</span> reached;</span><br><span class="line">	solider(<span class="keyword">int</span> n_, <span class="keyword">int</span> id_, <span class="keyword">int</span> flag_) :n(n_ + <span class="number">1</span>), id(id_), flag(flag_)&#123;<span class="comment">//注意此时+1</span></span><br><span class="line">		hpp = hp = HP[id_];</span><br><span class="line">		atk = ATK[id_];</span><br><span class="line">		loyalty = <span class="number">0</span>;</span><br><span class="line">		morale = <span class="number">0</span>;</span><br><span class="line">		yell = reached = <span class="number">0</span>;</span><br><span class="line">		w[<span class="number">0</span>] = w[<span class="number">1</span>] = w[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">		now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; born&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (id == DRAGON) &#123;</span><br><span class="line">			w[n % <span class="number">3</span>] = <span class="keyword">new</span> weapon(n % <span class="number">3</span>, atk);</span><br><span class="line">			morale = (b[flag].hp - HP[<span class="number">0</span>]) / (<span class="keyword">double</span>)HP[<span class="number">0</span>];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Its morale is &quot;</span> &lt;&lt; morale &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (id == NINJA) &#123;</span><br><span class="line">			w[n % <span class="number">3</span>] = <span class="keyword">new</span> weapon(n % <span class="number">3</span>, atk);</span><br><span class="line">			w[(n + <span class="number">1</span>) % <span class="number">3</span>] = <span class="keyword">new</span> weapon((n + <span class="number">1</span>) % <span class="number">3</span>, atk);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (id == ICEMAN) w[n % <span class="number">3</span>] = <span class="keyword">new</span> weapon(n % <span class="number">3</span>, atk);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (id == LION) &#123;</span><br><span class="line">			loyalty = b[flag].hp - HP[<span class="number">3</span>];</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Its loyalty is &quot;</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; loyalty &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">city</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line">	<span class="keyword">int</span> hp;</span><br><span class="line">	<span class="keyword">int</span> win;	<span class="comment">//战斗胜利数，红连胜x场记为+x</span></span><br><span class="line">&#125; C[<span class="number">22</span>];</span><br><span class="line">solider* c[<span class="number">2</span>][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judgefirst</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (C[i].flag == RED || (C[i].flag == VACANT &amp;&amp; i % <span class="number">2</span> == <span class="number">1</span>)) <span class="keyword">return</span> RED;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (C[i].flag == BLUE || (C[i].flag == VACANT &amp;&amp; i % <span class="number">2</span> == <span class="number">0</span>)) <span class="keyword">return</span> BLUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">born</span><span class="params">()</span> </span>&#123;<span class="comment">//武士降生</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> flag = <span class="number">0</span>; flag &lt; <span class="number">2</span>; flag++)</span><br><span class="line">		<span class="keyword">if</span> (b[flag].hp &gt;= HP[CREATE[flag][b[flag].snum % <span class="number">5</span>]]) &#123;</span><br><span class="line">			c[flag][b[flag].n] = <span class="keyword">new</span> solider(b[flag].snum, CREATE[flag][b[flag].snum % <span class="number">5</span>], flag);</span><br><span class="line">			b[flag].hp -= c[flag][b[flag].n]-&gt;hp;</span><br><span class="line">			b[flag].snum++;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//lion逃跑</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((i == <span class="number">0</span> &amp;&amp; flag == BLUE) || (i == N + <span class="number">1</span> &amp;&amp; flag == RED)) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i] &amp;&amp; c[flag][i]-&gt;id == LION &amp;&amp; c[flag][i]-&gt;loyalty &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&quot; lion &quot;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; ran away&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				c[flag][i] = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">icemanlosehp</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c[flag][t]-&gt;hp &gt; <span class="number">9</span>) c[flag][t]-&gt;hp -= <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">else</span> c[flag][t]-&gt;hp = <span class="number">1</span>;</span><br><span class="line">	c[flag][t]-&gt;atk += <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headquarter</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c[<span class="number">1</span> - flag][b[flag].n] &amp;&amp; c[<span class="number">1</span> - flag][b[flag].n]-&gt;reached == <span class="number">0</span>) &#123;</span><br><span class="line">		c[<span class="number">1</span> - flag][b[flag].n]-&gt;reached = <span class="number">1</span>;</span><br><span class="line">		now(); <span class="built_in">cout</span> &lt;&lt; B[<span class="number">1</span> - flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - flag][b[flag].n]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - flag][b[flag].n]-&gt;n &lt;&lt; <span class="string">&quot; reached &quot;</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&quot; headquarter with &quot;</span> &lt;&lt; c[<span class="number">1</span> - flag][b[flag].n]-&gt;hp &lt;&lt; <span class="string">&quot; elements and force &quot;</span> &lt;&lt; c[<span class="number">1</span> - flag][b[flag].n]-&gt;atk &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">if</span> (b[flag].taken) &#123;</span><br><span class="line">			now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&quot; headquarter was taken&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			b[flag].taken = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> b[flag].taken = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">march</span><span class="params">()</span> </span>&#123;<span class="comment">//武士前进和攻占司令部</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = b[<span class="number">1</span> - flag].n;</span><br><span class="line">		<span class="keyword">if</span> (c[flag][t + (flag == RED ? <span class="number">-1</span> : <span class="number">1</span>)]) c[flag][t] = c[flag][t + (flag == RED ? <span class="number">-1</span> : <span class="number">1</span>)];</span><br><span class="line">		<span class="keyword">if</span> (c[flag][t] &amp;&amp; c[flag][t]-&gt;id == ICEMAN &amp;&amp; (t - b[flag].n) % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; c[flag][t]-&gt;reached == <span class="number">0</span>) icemanlosehp(flag, t);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			t = (flag == RED ? i : N + <span class="number">1</span> - i);</span><br><span class="line">			<span class="keyword">int</span> pre = (flag == RED ? t - <span class="number">1</span> : t + <span class="number">1</span>);</span><br><span class="line">			c[flag][t] = c[flag][pre];</span><br><span class="line">			<span class="keyword">if</span> (c[flag][t] &amp;&amp; c[flag][t]-&gt;id == ICEMAN &amp;&amp; (t - b[flag].n) % <span class="number">2</span> == <span class="number">0</span>) icemanlosehp(flag, t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c[RED][<span class="number">0</span>] = c[BLUE][N + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">	headquarter(RED);<span class="comment">//红方司令部</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)<span class="comment">//城市</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i])  now(), <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; marched to city &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; with &quot;</span> &lt;&lt; c[flag][i]-&gt;hp &lt;&lt; <span class="string">&quot; elements and force &quot;</span> &lt;&lt; c[flag][i]-&gt;atk &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	headquarter(BLUE);<span class="comment">//蓝方司令部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hpborn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) C[i].hp += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gethp30</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i] &amp;&amp; !c[<span class="number">1</span> - flag][i]) &#123;</span><br><span class="line">				b[flag].hp += C[i].hp;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; earned &quot;</span> &lt;&lt; C[i].hp &lt;&lt; <span class="string">&quot; elements for his headquarter&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				C[i].hp = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;<span class="comment">//放箭</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)<span class="comment">//城市</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) &#123;</span><br><span class="line">			<span class="keyword">int</span> next = (flag == RED ? i + <span class="number">1</span> : i - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i] &amp;&amp; c[flag][i]-&gt;w[ARROW] &amp;&amp; c[flag][i]-&gt;w[ARROW]-&gt;dur &gt; <span class="number">0</span> &amp;&amp; c[<span class="number">1</span> - flag][next]) &#123;</span><br><span class="line">				c[<span class="number">1</span> - flag][next]-&gt;hp -= R;</span><br><span class="line">				c[flag][i]-&gt;w[ARROW]-&gt;dur--;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; shot&quot;</span>;</span><br><span class="line">				<span class="keyword">if</span> (c[<span class="number">1</span> - flag][next]-&gt;hp &lt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; and killed &quot;</span> &lt;&lt; B[<span class="number">1</span> - flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - flag][next]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - flag][next]-&gt;n;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usebomb</span><span class="params">()</span> </span>&#123;<span class="comment">//使用bomb</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="keyword">if</span> (c[RED][i] &amp;&amp; c[BLUE][i] &amp;&amp; c[RED][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; (c[RED][i]-&gt;w[BOMB] || c[BLUE][i]-&gt;w[BOMB])) &#123;</span><br><span class="line">			<span class="keyword">int</span> p = judgefirst(i);</span><br><span class="line">			<span class="keyword">int</span> php = c[p][i]-&gt;hp, qhp = c[<span class="number">1</span> - p][i]-&gt;hp;<span class="comment">//攻击方和反击方战斗前的生命</span></span><br><span class="line">			c[p][i]-&gt;hpp = c[p][i]-&gt;hp;</span><br><span class="line">			c[<span class="number">1</span> - p][i]-&gt;hpp = c[<span class="number">1</span> - p][i]-&gt;hp;</span><br><span class="line">			c[<span class="number">1</span> - p][i]-&gt;hp -= (c[p][i]-&gt;atk + (c[p][i]-&gt;w[SWORD] ? c[p][i]-&gt;w[SWORD]-&gt;atk : <span class="number">0</span>));</span><br><span class="line">			<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;hp &gt; <span class="number">0</span>) &#123;<span class="comment">//没打死，反击</span></span><br><span class="line">				<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;id != NINJA) &#123;</span><br><span class="line">					c[p][i]-&gt;hp -= c[<span class="number">1</span> - p][i]-&gt;atk / <span class="number">2</span>;</span><br><span class="line">					<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;w[SWORD]) c[p][i]-&gt;hp -= c[<span class="number">1</span> - p][i]-&gt;w[SWORD]-&gt;atk;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (c[p][i]-&gt;hp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (c[p][i]-&gt;w[BOMB]) &#123;</span><br><span class="line">						now(); <span class="built_in">cout</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; used a bomb and killed &quot;</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">						c[RED][i] = c[BLUE][i] = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> c[p][i]-&gt;hp = c[p][i]-&gt;hpp, c[<span class="number">1</span> - p][i]-&gt;hp = c[<span class="number">1</span> - p][i]-&gt;hpp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> c[p][i]-&gt;hp = c[p][i]-&gt;hpp, c[<span class="number">1</span> - p][i]-&gt;hp = c[<span class="number">1</span> - p][i]-&gt;hpp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//打死了</span></span><br><span class="line">				<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;w[BOMB]) &#123;</span><br><span class="line">					now(); <span class="built_in">cout</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="string">&quot; used a bomb and killed &quot;</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					c[RED][i] = c[BLUE][i] = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> c[p][i]-&gt;hp = c[p][i]-&gt;hpp, c[<span class="number">1</span> - p][i]-&gt;hp = c[<span class="number">1</span> - p][i]-&gt;hpp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cwin</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> i, <span class="keyword">int</span> hp)</span> </span>&#123;<span class="comment">//i城p方主动攻击q方胜利的结算，失败方战前血量hp</span></span><br><span class="line">	<span class="keyword">if</span> (q == <span class="number">2</span>) &#123;<span class="comment">//没人死</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = RED; j &lt;= BLUE; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (c[j][i]-&gt;id == DRAGON) c[j][i]-&gt;morale -= <span class="number">0.2</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[j][i]-&gt;id == LION) c[j][i]-&gt;loyalty -= K;</span><br><span class="line">		&#125;</span><br><span class="line">		C[i].win = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (c[<span class="number">1</span> - q][i]-&gt;id == LION) c[q][i]-&gt;hp += hp;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c[q][i]-&gt;id == WOLF) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = SWORD; j &lt;= ARROW; j++)</span><br><span class="line">				<span class="keyword">if</span> (!c[q][i]-&gt;w[j] &amp;&amp; c[<span class="number">1</span> - q][i]-&gt;w[j]) c[q][i]-&gt;w[j] = c[<span class="number">1</span> - q][i]-&gt;w[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c[q][i]-&gt;id == DRAGON) &#123;</span><br><span class="line">			c[q][i]-&gt;morale += <span class="number">0.2</span>;</span><br><span class="line">			<span class="keyword">if</span> (p == q) c[q][i]-&gt;yell = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q == RED) &#123;</span><br><span class="line">			<span class="keyword">if</span> (C[i].win &gt;= <span class="number">0</span>) C[i].win++;</span><br><span class="line">			<span class="keyword">else</span> C[i].win = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (C[i].win &lt;= <span class="number">0</span>) C[i].win--;</span><br><span class="line">			<span class="keyword">else</span> C[i].win = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cattack</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//在i城p方主动攻击</span></span><br><span class="line">	<span class="keyword">int</span> php = c[p][i]-&gt;hp, qhp = c[<span class="number">1</span> - p][i]-&gt;hp;<span class="comment">//攻击方和反击方战斗前的生命</span></span><br><span class="line">	c[<span class="number">1</span> - p][i]-&gt;hp -= c[p][i]-&gt;atk;</span><br><span class="line">	<span class="keyword">if</span> (c[p][i]-&gt;w[SWORD]) &#123;</span><br><span class="line">		c[<span class="number">1</span> - p][i]-&gt;hp -= c[p][i]-&gt;w[SWORD]-&gt;atk;</span><br><span class="line">		c[p][i]-&gt;w[SWORD]-&gt;atk = c[p][i]-&gt;w[SWORD]-&gt;atk * <span class="number">8</span> / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;hp &gt; <span class="number">0</span>) &#123;<span class="comment">//没打死，反击</span></span><br><span class="line">		<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;id != NINJA) &#123;</span><br><span class="line">			c[p][i]-&gt;hp -= c[<span class="number">1</span> - p][i]-&gt;atk / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;w[SWORD]) &#123;</span><br><span class="line">				c[p][i]-&gt;hp -= c[<span class="number">1</span> - p][i]-&gt;w[SWORD]-&gt;atk;</span><br><span class="line">				c[<span class="number">1</span> - p][i]-&gt;w[SWORD]-&gt;atk = c[<span class="number">1</span> - p][i]-&gt;w[SWORD]-&gt;atk * <span class="number">8</span> / <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c[p][i]-&gt;hp &lt;= <span class="number">0</span>) cwin(p, <span class="number">1</span> - p, i, php);<span class="comment">//主动攻击方死</span></span><br><span class="line">		<span class="keyword">else</span> cwin(p, <span class="number">2</span>, i, <span class="number">0</span>);<span class="comment">//都没死</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cwin(p, p, i, qhp);<span class="comment">//被攻击方死</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">battle</span><span class="params">()</span> </span>&#123;<span class="comment">//主动进攻，反击，战死，欢呼，获取生命，旗帜升起</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)<span class="comment">//对每个城进行战斗</span></span><br><span class="line">		<span class="keyword">if</span> (c[RED][i] &amp;&amp; c[BLUE][i]) &#123;<span class="comment">//有两个武士</span></span><br><span class="line">			c[RED][i]-&gt;hpp = c[RED][i]-&gt;hp;</span><br><span class="line">			c[BLUE][i]-&gt;hpp = c[BLUE][i]-&gt;hp;</span><br><span class="line">			<span class="keyword">if</span> (c[RED][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hp &gt; <span class="number">0</span>) cattack(judgefirst(i), i);<span class="comment">//hp都大于0</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[RED][i]-&gt;hp &lt;= <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hp &gt; <span class="number">0</span>) cwin(judgefirst(i), BLUE, i, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c[RED][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hp &lt;= <span class="number">0</span>) cwin(judgefirst(i), RED, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = flag == RED ? i : N + <span class="number">1</span> - i;</span><br><span class="line">			<span class="keyword">if</span> (c[flag][t] &amp;&amp; c[<span class="number">1</span> - flag][t] &amp;&amp; c[flag][t]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[<span class="number">1</span> - flag][t]-&gt;hp &lt;= <span class="number">0</span> &amp;&amp; b[flag].hp &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">				c[flag][t]-&gt;hp += <span class="number">8</span>;</span><br><span class="line">				b[flag].hp -= <span class="number">8</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="keyword">if</span> (c[RED][i] &amp;&amp; c[BLUE][i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> p = judgefirst(i);</span><br><span class="line">			<span class="keyword">if</span> (c[RED][i]-&gt;hpp &gt; <span class="number">0</span> &amp;&amp; c[BLUE][i]-&gt;hpp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; attacked &quot;</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="string">&quot; in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; with &quot;</span> &lt;&lt; c[p][i]-&gt;hpp &lt;&lt; <span class="string">&quot; elements and force &quot;</span> &lt;&lt; c[p][i]-&gt;atk &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;hp &gt; <span class="number">0</span>) &#123;<span class="comment">//没打死，反击</span></span><br><span class="line">					<span class="keyword">if</span> (c[<span class="number">1</span> - p][i]-&gt;id != NINJA) now(), <span class="built_in">cout</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="string">&quot; fought back against &quot;</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">if</span> (c[p][i]-&gt;hp &lt;= <span class="number">0</span>) now(), <span class="built_in">cout</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; was killed in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> now(), <span class="built_in">cout</span> &lt;&lt; B[<span class="number">1</span> - p] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[<span class="number">1</span> - p][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[<span class="number">1</span> - p][i]-&gt;n &lt;&lt; <span class="string">&quot; was killed in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//打死了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (c[p][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[p][i]-&gt;morale &gt;= <span class="number">0.8</span>) now(), <span class="built_in">cout</span> &lt;&lt; B[p] &lt;&lt; <span class="string">&quot; dragon &quot;</span> &lt;&lt; c[p][i]-&gt;n &lt;&lt; <span class="string">&quot; yelled in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">				<span class="keyword">if</span> (c[flag][i] &amp;&amp; c[<span class="number">1</span> - flag][i] &amp;&amp; c[flag][i]-&gt;hp &gt; <span class="number">0</span> &amp;&amp; c[<span class="number">1</span> - flag][i]-&gt;hp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					b[flag].hp += C[i].hp;</span><br><span class="line">					now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; earned &quot;</span> &lt;&lt; C[i].hp &lt;&lt; <span class="string">&quot; elements for his headquarter&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					C[i].hp = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> ((C[i].win == <span class="number">2</span> &amp;&amp; C[i].flag != RED) || (C[i].win == <span class="number">-2</span> &amp;&amp; C[i].flag != BLUE)) &#123;</span><br><span class="line">				C[i].flag = (C[i].win == <span class="number">2</span> ? RED : BLUE);</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[C[i].flag] &lt;&lt; <span class="string">&quot; flag raised in city &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) <span class="keyword">if</span> (c[flag][i] &amp;&amp; c[flag][i]-&gt;hp &lt;= <span class="number">0</span>) c[flag][i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rehp</span><span class="params">()</span> </span>&#123;<span class="comment">//司令部报告生命</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = RED; i &lt;= BLUE; i++) now(), <span class="built_in">cout</span> &lt;&lt; b[i].hp &lt;&lt; <span class="string">&quot; elements in &quot;</span> &lt;&lt; B[i] &lt;&lt; <span class="string">&quot; headquarter&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coutdot</span><span class="params">(<span class="keyword">bool</span>&amp; tmp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tmp) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span>; tmp = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rew</span><span class="params">()</span> </span>&#123;<span class="comment">//武士报告武器</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++)</span><br><span class="line">			<span class="keyword">if</span> (c[flag][i]) &#123;</span><br><span class="line">				now(); <span class="built_in">cout</span> &lt;&lt; B[flag] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; S[c[flag][i]-&gt;id] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c[flag][i]-&gt;n &lt;&lt; <span class="string">&quot; has &quot;</span>;</span><br><span class="line">				<span class="keyword">bool</span> tmp = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = ARROW; j &gt;= SWORD; j--)</span><br><span class="line">					<span class="keyword">if</span> (c[flag][i]-&gt;w[j]) &#123;</span><br><span class="line">						<span class="keyword">if</span> (j == SWORD) &#123;</span><br><span class="line">							<span class="keyword">if</span> (c[flag][i]-&gt;w[j]-&gt;atk == <span class="number">0</span>) c[flag][i]-&gt;w[j] = <span class="literal">NULL</span>;</span><br><span class="line">							<span class="keyword">else</span> coutdot(tmp), <span class="built_in">cout</span> &lt;&lt; W[j] &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; c[flag][i]-&gt;w[j]-&gt;atk &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (j == ARROW) &#123;</span><br><span class="line">							<span class="keyword">if</span> (c[flag][i]-&gt;w[j]-&gt;dur == <span class="number">0</span>) c[flag][i]-&gt;w[j] = <span class="literal">NULL</span>;</span><br><span class="line">							<span class="keyword">else</span> coutdot(tmp), <span class="built_in">cout</span> &lt;&lt; W[j] &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; c[flag][i]-&gt;w[j]-&gt;dur &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> coutdot(tmp), <span class="built_in">cout</span> &lt;&lt; W[j];</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">if</span> (!tmp) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no weapon&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化和输入</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N &gt;&gt; R &gt;&gt; K &gt;&gt; T &gt;&gt; HP[<span class="number">0</span>] &gt;&gt; HP[<span class="number">1</span>] &gt;&gt; HP[<span class="number">2</span>] &gt;&gt; HP[<span class="number">3</span>] &gt;&gt; HP[<span class="number">4</span>] &gt;&gt; ATK[<span class="number">0</span>] &gt;&gt; ATK[<span class="number">1</span>] &gt;&gt; ATK[<span class="number">2</span>] &gt;&gt; ATK[<span class="number">3</span>] &gt;&gt; ATK[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = RED; i &lt;= BLUE; i++) &#123;</span><br><span class="line">		b[i].hp = M; b[i].flag = i; b[i].n = (N + <span class="number">1</span>) * i; b[i].snum = <span class="number">0</span>; b[i].taken = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	HOUR = T / <span class="number">60</span>; MIN = T % <span class="number">60</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		C[i].flag = VACANT; C[i].hp = <span class="number">0</span>; C[i].win = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N + <span class="number">1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> flag = RED; flag &lt;= BLUE; flag++) c[flag][i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;<span class="comment">//数据组数</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">		input();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		h = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			m = <span class="number">0</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; born();</span><br><span class="line">			m = <span class="number">5</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; run();</span><br><span class="line">			m = <span class="number">10</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; march();</span><br><span class="line">			<span class="keyword">if</span> (b[RED].taken == <span class="number">2</span> || b[BLUE].taken == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">			m = <span class="number">20</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; hpborn();</span><br><span class="line">			m = <span class="number">30</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; gethp30();</span><br><span class="line">			m = <span class="number">35</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; shoot();</span><br><span class="line">			m = <span class="number">38</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; usebomb();</span><br><span class="line">			m = <span class="number">40</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; battle();</span><br><span class="line">			m = <span class="number">50</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; rehp();</span><br><span class="line">			m = <span class="number">55</span>; <span class="keyword">if</span> (h == HOUR &amp;&amp; m &gt; MIN) <span class="keyword">break</span>; rew();</span><br><span class="line">			h++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
