<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++程序设计笔记</title>
    <url>/2020/12/28/fundamentals-of-Cpp-programming-and-algorithms/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/12/28/fundamentals-of-Cpp-programming-and-algorithms/IMG_20201223_235334.jpg">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">为了做这句话，我还学了一点HTML。</div>
</center>




<a id="more"></a>



<h2 id="一-从C到C"><a href="#一-从C到C" class="headerlink" title="一    从C到C++"></a>一    从C到C++</h2><h3 id="1-1-C-语言的历史"><a href="#1-1-C-语言的历史" class="headerlink" title="1.1    C++语言的历史"></a>1.1    C++语言的历史</h3><p>1983年诞生的C++对C语言的改进包括面向对象、虚函数、函数和运算符重载、引用等。1989年推出的C++2.0实现了多重继承、抽象类、静态成员、常量成员函数等功能。1990年加入了模板、异常处理、命名空间等机制。1998年诞生的C++98加入了标准模板库（STL），C++从此实现了泛型程序设计。2011年发布的C++11标准支持正则表达式、哈希表以及其他一系列重要的功能。当前最新的C++标准是C++20。</p>
<h3 id="1-2-输入输出"><a href="#1-2-输入输出" class="headerlink" title="1.2    输入输出"></a>1.2    输入输出</h3><p>C++使用<code>cin</code>和<code>cout</code>实现输入输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; d;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-头文件"><a href="#1-3-头文件" class="headerlink" title="1.3    头文件"></a>1.3    头文件</h3><p>C++头文件不再以”.h”结尾，常用的C++头文件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;		//标准输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;		//STL 通用算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;		//参数化输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;			//定义数学函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;		//字符串处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;			//定义关于时间的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;		//STL 动态数组容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;			//STL 队列容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;			//STL 堆栈容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;		//字符串类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;		//文件输入／输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;			//STL 集合容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;			//STL 映射容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;		//定义杂项函数及内存分配函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;		//STL 通用模板类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;		//基于字符串的流</span></span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-强制类型转换"><a href="#1-4-强制类型转换" class="headerlink" title="1.4    强制类型转换"></a>1.4    强制类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="number">3.5</span>);	<span class="comment">//C++通常写成类似函数调用的格式</span></span><br><span class="line"><span class="keyword">double</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span>(a);</span><br><span class="line">(<span class="keyword">int</span>)<span class="number">3.5</span>;	<span class="comment">//传统的C格式</span></span><br><span class="line">(<span class="keyword">double</span>)<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-函数参数的默认值"><a href="#1-5-函数参数的默认值" class="headerlink" title="1.5    函数参数的默认值"></a>1.5    函数参数的默认值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">(<span class="keyword">int</span> x=<span class="number">20</span>)</span></span>;	<span class="comment">//函数声明，x默认为20</span></span><br><span class="line">Function1();				<span class="comment">//函数调用，等效于Function(20);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用表达式作为函数的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y=Max(a,b),<span class="keyword">int</span> z=a*b)</span><span class="comment">//函数定义处也可以写参数的默认值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Function2(<span class="number">4</span>);		<span class="comment">//Function2(4,Max(a,b),a*b)</span></span><br><span class="line">Function2(<span class="number">4</span>,<span class="number">9</span>);		<span class="comment">//Function2(4,9,a*b);</span></span><br><span class="line">Function2(<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Function2(<span class="number">4</span>,,<span class="number">3</span>);	<span class="comment">//报错，省略的参数一定是最右边连续的几个</span></span><br></pre></td></tr></table></figure>
<h3 id="1-6-引用和函数参数的传递"><a href="#1-6-引用和函数参数的传递" class="headerlink" title="1.6    引用和函数参数的传递"></a>1.6    引用和函数参数的传递</h3><h4 id="1-6-1-引用"><a href="#1-6-1-引用" class="headerlink" title="1.6.1    引用"></a>1.6.1    引用</h4><p>引用某个变量相当于某个变量的别名。<strong>定义引用时必须初始化，通常用某个变量初始化引用。</strong>引用初始化后会一直引用该变量，不会引用别的变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>&amp; r=n;</span><br></pre></td></tr></table></figure>
<p>修改变量的值，引用的值也会修改。修改引用的值，变量的值也会修改。多个不同的引用可以引用同一变量。</p>
<h4 id="1-6-2-引用作为函数返回值"><a href="#1-6-2-引用作为函数返回值" class="headerlink" title="1.6.2    引用作为函数返回值"></a>1.6.2    引用作为函数返回值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">SetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetValue()=<span class="number">40</span>;		<span class="comment">//返回引用的函数表达式可作为左值使用，等效于n=40;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; r=SetValue();	<span class="comment">//r为n的引用，r=40；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-3-值传递和引用传递"><a href="#1-6-3-值传递和引用传递" class="headerlink" title="1.6.3    值传递和引用传递"></a>1.6.3    值传递和引用传递</h4><p>函数传参的形式有两种，一是值传递，二是引用传递。值传递形参是实参的拷贝，形参改变不影响实参。在函数调用过程中，实参的值会被复制到栈中，函数执行过程中对形参的改变只是修改了实参的拷贝，不修改实参。如果函数的形参是引用，那么形参的改变会影响实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//错误</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span><span class="comment">//正确</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-4-常引用"><a href="#1-6-4-常引用" class="headerlink" title="1.6.4    常引用"></a>1.6.4    常引用</h4><p>加上<code>const</code>关键字的引用称为常引用。<strong>不能通过常引用修改其引用的内容。</strong>常引用的类型为<code>const T&amp;</code>。引用和变量可以初始化常引用，但常变量和常引用不能初始化引用，除非进行强制类型转换。</p>
<h3 id="1-7-内联函数"><a href="#1-7-内联函数" class="headerlink" title="1.7    内联函数"></a>1.7    内联函数</h3><p>进行函数调用时，首先要在栈中开辟形参和局部变量的存储空间，接着把实参的值复制给形参，然后把函数返回地址放入栈中，最后跳转至函数内部执行。函数调用结束时，需要从栈中回收形参和局部变量的空间，取出返回地址才能跳转到该地址继续执行。如果一个函数语句很简单，执行时间很短，又经常被调用，函数调用带来的时间开销就非常大。因此在返回值前加上<code>inline</code>关键字，成为内联函数，编译器编译时就不会将该语句编译成调用指令，而是直接插入代码。这样既可以实现代码复用，又不会造成函数调用的额外开销。调用内联函数前必须出现内联函数的定义而不仅是其声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-函数重载"><a href="#1-8-函数重载" class="headerlink" title="1.8    函数重载"></a>1.8    函数重载</h3><p>多个函数名字相同但参数表不同称为函数重载。编译器可以通过函数调用语句中实参的个数和类型确定应该调用哪个函数。常见的一种重载编译出错是二义性错误。仅返回值不同的函数是重复定义，不是重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Max 1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Max 2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sum 1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sum 2&quot;</span>&lt;&lt;end</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Max(<span class="number">3</span>,<span class="number">1.5</span>);		<span class="comment">//二义性错误</span></span><br><span class="line">    Sum(<span class="number">1</span>,<span class="number">2</span>);		<span class="comment">//二义性错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-9-指针和动态内存分配"><a href="#1-9-指针和动态内存分配" class="headerlink" title="1.9    指针和动态内存分配"></a>1.9    指针和动态内存分配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[n];	<span class="comment">//编译出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>;	<span class="comment">//动态分配4byte的内存空间</span></span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>* pn=<span class="keyword">new</span> <span class="keyword">int</span>[i*<span class="number">20</span>];	<span class="comment">//动态分配i*20*sizeof(int)byte的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> p;	<span class="comment">//动态分配的内存空间使用完后应当释放，但不能重复delete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> []p;		<span class="comment">//释放动态分配的数组内存</span></span><br></pre></td></tr></table></figure>
<h3 id="1-10-string对象"><a href="#1-10-string对象" class="headerlink" title="1.10    string对象"></a>1.10    string对象</h3><p><code>string</code>是标准模板库中的一个类，需要包含头文件<code>string</code>。处理字符串优先考虑使用<code>string</code>类。<code>string</code>对象只存放字符串地址而不直接存放字符串。</p>
<h4 id="1-10-1-string对象的定义、输入输出和赋值"><a href="#1-10-1-string对象的定义、输入输出和赋值" class="headerlink" title="1.10.1    string对象的定义、输入输出和赋值"></a>1.10.1    string对象的定义、输入输出和赋值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> str1;			<span class="comment">//没有初始化的值为空串&quot;&quot;</span></span><br><span class="line"><span class="built_in">string</span> city=<span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> as[]=&#123;<span class="string">&quot;Beijing&quot;</span>,<span class="string">&quot;Shanghai&quot;</span>,<span class="string">&quot;Chengdu&quot;</span>&#125;;	<span class="comment">//string数组</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;as[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><code>string</code>可以互相赋值，也可以用<code>char[]</code>赋值。</p>
<h4 id="1-10-2-string的运算"><a href="#1-10-2-string的运算" class="headerlink" title="1.10.2    string的运算"></a>1.10.2    string的运算</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;abc&quot;</span>,s3;	<span class="comment">//s3==&quot;&quot;</span></span><br><span class="line">s3=s1+s2;						<span class="comment">//s3==&quot;123abc&quot;</span></span><br><span class="line">s3+=<span class="string">&quot;de&quot;</span>;						<span class="comment">//s3==&quot;123abcde&quot;</span></span><br><span class="line"><span class="keyword">bool</span> b=s1&lt;s3;					<span class="comment">//b==true</span></span><br><span class="line"><span class="keyword">char</span> c=s1[<span class="number">2</span>];					<span class="comment">//c==&#x27;3&#x27;</span></span><br><span class="line">s1[<span class="number">2</span>]=<span class="string">&#x27;5&#x27;</span>;						<span class="comment">//s1=&quot;125&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-10-3-string类的使用"><a href="#1-10-3-string类的使用" class="headerlink" title="1.10.3    string类的使用"></a>1.10.3    string类的使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;abcdef&quot;</span>,s3;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1.size()&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2.substr(<span class="number">1</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//bcd</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">s3=s1+s2;</span><br><span class="line"><span class="built_in">strcpy</span>(str,s3.c_str());			<span class="comment">//123abcdef</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="二-类和对象初步"><a href="#二-类和对象初步" class="headerlink" title="二    类和对象初步"></a>二    类和对象初步</h2><h3 id="2-1-结构化程序设计的不足"><a href="#2-1-结构化程序设计的不足" class="headerlink" title="2.1    结构化程序设计的不足"></a>2.1    结构化程序设计的不足</h3><p>结构化程序设计也称为面向过程的程序设计，过程用函数实现，因此设计时就要考虑如何把功能分割成一个个函数，不同函数互相调用，每个函数实现各自的功能。结构化程序设计难免会使用一些全局变量，这些变量往往被很多函数访问或修改，这样的程序在规模庞大的情况下就难以进行理解和维护。随着软件规模不断扩大，结构化程序设计已经难以适应开发大型软件的需要，面向对象的程序设计便应运而生。</p>
<h3 id="2-2-面向对象程序设计的概念和特点"><a href="#2-2-面向对象程序设计的概念和特点" class="headerlink" title="2.2    面向对象程序设计的概念和特点"></a>2.2    面向对象程序设计的概念和特点</h3><p><strong>面向对象的程序设计的基本特点是抽象、封装、继承、多态。</strong></p>
<p>抽象指把同一类事物的共同特点概括出来。对象的特点包括属性和方法。属性指对象的静态特征，可以用变量表示。方法指对象的行为，可以用函数表示。方法可以对属性进行操作。完成抽象后将数据和操作数据的算法组合在一起，形成形式上的整体，叫做“类”，这个过程称为封装。封装可以把对象的一部分属性和方法隐藏起来，对外界不可见，这样可以减少程序不同部分的耦合度，提高代码扩充修改和复用的效率。继承机制就是在编写一个类时以现有的类作为基础，利用派生达到代码复用的目的 。多态则指的是不同种类的对象具有相同名称的行为，但实现方式有所不同。</p>
<h3 id="2-3-类的定义和使用"><a href="#2-3-类的定义和使用" class="headerlink" title="2.3    类的定义和使用"></a>2.3    类的定义和使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>							//类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:								<span class="comment">//访问范围说明符</span></span><br><span class="line">    <span class="keyword">int</span> a;								<span class="comment">//成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func1</span><span class="params">()</span>							<span class="comment">//成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;								<span class="comment">//成员变量和成员函数的先后次序没有规定</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> b)</span>						<span class="comment">//成员函数可以互相调用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b=Func1();</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>;			<span class="comment">//成员函数可以重载，也可以设定参数默认值</span></span><br><span class="line">&#125;;										<span class="comment">//以“；”结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Myclass::Func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>;	<span class="comment">//成员函数实现可位于类定义以外</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">Myclass m;									<span class="comment">//定义某个类的对象</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-类的示例"><a href="#2-4-类的示例" class="headerlink" title="2.4    类的示例"></a>2.4    类的示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">perimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRectangle::init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w=w_;</span><br><span class="line">    h=h_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRectangle::area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Crectangle::perimeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    return2*(w+h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    CRectangle r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;w&gt;&gt;h;</span><br><span class="line">    r.init(w,h);									<span class="comment">//访问成员函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;It&#x27;s area is &quot;</span>&lt;&lt;r.area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;It&#x27;s perimeter is &quot;</span>&lt;&lt;r.perimeter()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(CRectangle)&lt;&lt;<span class="built_in">endl</span>;						<span class="comment">//对象占用内存空间大小等于各成员变量占用内存空间大小之和，输出8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-访问对象的成员"><a href="#2-5-访问对象的成员" class="headerlink" title="2.5    访问对象的成员"></a>2.5    访问对象的成员</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CRectangle r1.r2;</span><br><span class="line">CRectangle* p1=&amp;r1;</span><br><span class="line">CRectangle* p2=&amp;r2;</span><br><span class="line">p1-&gt;w=<span class="number">5</span>;</span><br><span class="line">p2-&gt;init(<span class="number">5</span>,<span class="number">4</span>);			<span class="comment">//使用指针-&gt;成员名访问成员</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRectangle&amp; rr=r2;</span><br><span class="line">rr.w=<span class="number">5</span>;</span><br><span class="line">rr.init(<span class="number">5</span>,<span class="number">4</span>);			<span class="comment">//使用引用名.成员名访问对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CRectangle</span>		//用<span class="keyword">struct</span>表示类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没有成员函数的<code>struct</code>还是称为结构。对象可以使用”=“赋值，但不能进行比较运算。</p>
<h3 id="2-6-类成员的可访问范围"><a href="#2-6-类成员的可访问范围" class="headerlink" title="2.6    类成员的可访问范围"></a>2.6    类成员的可访问范围</h3><h4 id="2-6-1-private和public访问范围说明符"><a href="#2-6-1-private和public访问范围说明符" class="headerlink" title="2.6.1    private和public访问范围说明符"></a>2.6.1    private和public访问范围说明符</h4><p>private用来指定私有成员，私有成员只有在该类的成员函数内部才能访问。public用来指定公有成员，公有成员可以在任何地方访问。protected用来指定保护成员。三种关键字次数和顺序没有限制。若成员没有访问范围说明符，对于class类默认为私有成员，对于struct类默认为公有成员。</p>
<h4 id="2-6-2-“隐藏”的作用"><a href="#2-6-2-“隐藏”的作用" class="headerlink" title="2.6.2    “隐藏”的作用"></a>2.6.2    “隐藏”的作用</h4><p>隐藏强制对成员变量的访问通过成员函数进行，如果未来修改了成员变量类型等属性，只需修改成员函数即可。隐藏还可以避免对对象的不正确操作。</p>
<h2 id="三-类和对象进阶"><a href="#三-类和对象进阶" class="headerlink" title="三    类和对象进阶"></a>三    类和对象进阶</h2><h3 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1    构造函数"></a>3.1    构造函数</h3><h4 id="3-1-1-构造函数的概念和作用"><a href="#3-1-1-构造函数的概念和作用" class="headerlink" title="3.1.1    构造函数的概念和作用"></a>3.1.1    构造函数的概念和作用</h4><p>面向对象的程序设计语言倾向于对象一定要经过初始化后使用起来才比较安全。因此引入构造函数的概念，用于对对象进行初始化。一个类可以有多个构造函数，如果没有写构造函数，编译器会自动生成一个默认的无参构造函数，该函数什么都不做。如果编写了构造函数，就不会再生成默认构造函数。对象生成时一定会调用某个构造函数进行初始化，一旦生成就再也不会执行构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c;						<span class="comment">//无参构造函数</span></span><br><span class="line">Complex* p=<span class="keyword">new</span> Complex;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i=<span class="number">0</span>);			<span class="comment">//构造函数是特殊的成员函数，名字和类名一样，不写返回值，可以重载</span></span><br><span class="line">&#125;;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)				<span class="comment">//构造函数1</span></span><br><span class="line">&#123;</span><br><span class="line">    real=r;</span><br><span class="line">    imag=i;</span><br><span class="line">&#125;</span><br><span class="line">Complex::Complex(Complex c1,Complex c2)			<span class="comment">//构造函数2</span></span><br><span class="line">&#123;</span><br><span class="line">    real=c1.real+c2.real;</span><br><span class="line">    imag=c1.imag+c2.imag;</span><br><span class="line">&#125;</span><br><span class="line">Complex c1;									<span class="comment">//错误，没有无参构造函数</span></span><br><span class="line">Complex* pc=<span class="keyword">new</span> Complex;					<span class="comment">//错误</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2</span>)</span></span>;								<span class="comment">//正确，相当于Complex c2(2,0);</span></span><br><span class="line">Complex c3(2,4),c4(3,5);					//正确</span><br><span class="line">Complex* pc2=<span class="keyword">new</span> Complex(<span class="number">3</span>,<span class="number">4</span>);					<span class="comment">//正确</span></span><br><span class="line"><span class="function">Complex <span class="title">c5</span><span class="params">(c3,c4)</span></span>;							<span class="comment">//正确，使用构造函数2</span></span><br><span class="line">Complex c6=<span class="number">5</span>;								<span class="comment">//正确，使用构造函数1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-构造函数在数组中的使用"><a href="#3-1-2-构造函数在数组中的使用" class="headerlink" title="3.1.2    构造函数在数组中的使用"></a>3.1.2    构造函数在数组中的使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest(<span class="keyword">int</span> n)&#123;&#125;			<span class="comment">//构造函数1</span></span><br><span class="line">    CTest(<span class="keyword">int</span> n,<span class="keyword">int</span> m)&#123;&#125;	<span class="comment">//构造函数2</span></span><br><span class="line">    CTest()&#123;&#125;				<span class="comment">//构造函数3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest array1[<span class="number">3</span>]=&#123;<span class="number">1</span>,CTest(<span class="number">1</span>,<span class="number">2</span>)&#125;;					<span class="comment">//1，2，3</span></span><br><span class="line">    CTest array2[<span class="number">3</span>]=&#123;CTest(<span class="number">2</span>,<span class="number">3</span>),CTest(<span class="number">1</span>,<span class="number">2</span>),<span class="number">1</span>&#125;;		<span class="comment">//2，2，1</span></span><br><span class="line">    CTest* pArray[<span class="number">3</span>]=&#123;<span class="keyword">new</span> CTest(<span class="number">4</span>),<span class="keyword">new</span> CTest(<span class="number">1</span>,<span class="number">2</span>)&#125;;		<span class="comment">//1，2，只生成了两个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-复制构造函数"><a href="#3-1-3-复制构造函数" class="headerlink" title="3.1.3    复制构造函数"></a>3.1.3    复制构造函数</h4><h5 id="1-复制构造函数的概念"><a href="#1-复制构造函数的概念" class="headerlink" title="1.复制构造函数的概念"></a>1.复制构造函数的概念</h5><p>复制构造函数是构造函数的一种，它只有一个该类的引用作为参数。引用可以是const引用，也可以是非const引用，一般使用前者。默认构造函数不一定存在，但复制构造函数总是存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;		<span class="comment">//用复制构造函数初始化c2</span></span><br></pre></td></tr></table></figure>
<p>构造函数不能以本类的对象作为唯一参数。</p>
<h5 id="2-复制构造函数被调用的三种情况"><a href="#2-复制构造函数被调用的三种情况" class="headerlink" title="2.复制构造函数被调用的三种情况"></a>2.复制构造函数被调用的三种情况</h5><ul>
<li>用一个对象初始化同类的另一个对象</li>
<li>作为形参的对象用复制构造函数初始化，复制构造函数的参数就是调用函数时的实参。</li>
<li>作为函数返回值的对象用复制构造函数初始化，复制构造函数的参数就是return语句返回的对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2=c1;		<span class="comment">//只有初始化语句才能调用复制构造函数</span></span><br><span class="line">c2=c1;				<span class="comment">//赋值语句不能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(A&amp; a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">(A a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function">A <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    Func1(a);		<span class="comment">//调用复制构造函数</span></span><br><span class="line">    Func2();		<span class="comment">//调用复制构造函数</span></span><br><span class="line">    Func3(a);		<span class="comment">//通过引用避免了复制构造函数，同时保证实参的值不会改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-4-类型转换构造函数"><a href="#3-1-4-类型转换构造函数" class="headerlink" title="3.1.4    类型转换构造函数"></a>3.1.4    类型转换构造函数</h4><p>除复制构造函数外，只有一个参数的构造函数称为类型转换构造函数，这样的构造函数能起到自动类型转换的作用。类型转换构造函数可以在初始化语句和赋值语句被调用。处理赋值语句时，编译器往往会把在等号右侧生成一个临时对象，再赋值给等号左侧。</p>
<h3 id="3-2-析构函数"><a href="#3-2-析构函数" class="headerlink" title="3.2    析构函数"></a>3.2    析构函数</h3><p>析构函数用于对象消亡前的善后工作，在对象消亡时自动调用。例如在析构函数中调用delete语句即可确保对象运行时动态分配的内存空间被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~Cdemo()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDemo <span class="built_in">array</span>[<span class="number">2</span>];			<span class="comment">//构造函数调用2次</span></span><br><span class="line">    CDemo* pTest=<span class="keyword">new</span> CDemo;	<span class="comment">//构造函数调用</span></span><br><span class="line">    <span class="keyword">delete</span> pTest;			<span class="comment">//析构函数调用</span></span><br><span class="line">    pTest=<span class="keyword">new</span> CDemo[<span class="number">2</span>];		<span class="comment">//构造函数调用2次</span></span><br><span class="line">    <span class="keyword">delete</span> []pTest;			<span class="comment">//析构函数调用2次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;				<span class="comment">//析构函数调用2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的参数对象和作为函数返回值的对象消亡时也会引发析构函数调用。</p>
<h3 id="3-3-构造函数、析构函数和变量的生存期"><a href="#3-3-构造函数、析构函数和变量的生存期" class="headerlink" title="3.3    构造函数、析构函数和变量的生存期"></a>3.3    构造函数、析构函数和变量的生存期</h3><p>全局对象在进入main函数前形成，直到程序结束消亡。临时对象在语句执行完毕后消亡，局部对象在初始化时生成，在最近的大括号处消亡。含static关键字的静态局部对象相当于全局对象。</p>
<h3 id="3-4-静态成员变量和静态成员函数"><a href="#3-4-静态成员变量和静态成员函数" class="headerlink" title="3.4    静态成员变量和静态成员函数"></a>3.4    静态成员变量和静态成员函数</h3><p>静态成员变量和静态成员函数加了<code>static</code>关键字，静态成员变量被所有同类对象共享，静态成员函数并不具体作用在某个对象上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> w, h;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> totalArea;			<span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> totalNumber;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span>		<span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function">	</span>&#123;								<span class="comment">//静态成员函数不能访问非静态成员变量，也不能调用非静态成员函数</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; totalNumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; totalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CRectangle(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span><br><span class="line">	&#123;</span><br><span class="line">		w = w_;</span><br><span class="line">		h = h_;</span><br><span class="line">		totalNumber++;</span><br><span class="line">		totalArea += w * h;</span><br><span class="line">	&#125;</span><br><span class="line">	CRectangle(CRectangle&amp; r)		<span class="comment">//有些对象用复制构造函数初始化，需要编写专门的复制构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		totalNumber++;</span><br><span class="line">		totalArea += r.w * r.h;</span><br><span class="line">		w = r.w;</span><br><span class="line">		h = r.h;</span><br><span class="line">	&#125;</span><br><span class="line">	~CRectangle()</span><br><span class="line">	&#123;</span><br><span class="line">		totalNumber--;</span><br><span class="line">		totalArea -= w * h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> CRectangle::totalArea = <span class="number">0</span>;			<span class="comment">//必须对静态成员变量做声明或初始化</span></span><br><span class="line"><span class="keyword">int</span> CRectangle::totalNumber = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRectangle r1(3, 3), r2(2, 2);</span><br><span class="line">	CRectangle::PrintTotal();</span><br><span class="line">	r1.PrintTotal();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-常量对象和常量成员函数"><a href="#3-5-常量对象和常量成员函数" class="headerlink" title="3.5    常量对象和常量成员函数"></a>3.5    常量对象和常量成员函数</h3><p>定义时加<code>const</code> 的对象和成员函数称为常量对象和常量成员函数，常量对象初始化后就再也不被改变，常量对象不能调用普通成员函数，但可以调用常量成员函数，常量成员函数不会修改任何非静态成员变量的值，也不允许调用其他非常量成员函数，但静态成员函数除外。两个名字和参数表不同的一个带const一个不带的函数算重载。如果一个成员函数没有调用非常量成员函数也没有修改成员变量，那么应写成常量成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest()&#123;n=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> n;&#125;			<span class="comment">//常量成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*n;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CTest o1;							<span class="comment">//常量对象</span></span><br><span class="line">    CTest o2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;o1.GetValue()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;o2.GetValue();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-成员对象和封闭类"><a href="#3-6-成员对象和封闭类" class="headerlink" title="3.6    成员对象和封闭类"></a>3.6    成员对象和封闭类</h3><h4 id="3-6-1-封闭类构造函数的初始化列表"><a href="#3-6-1-封闭类构造函数的初始化列表" class="headerlink" title="3.6.1    封闭类构造函数的初始化列表"></a>3.6.1    封闭类构造函数的初始化列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTyre(<span class="keyword">int</span> r,<span class="keyword">int</span> w):radius(r),width(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>			//包含成员对象的类称为封闭类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    Ctyre tyre;		<span class="comment">//成员对象</span></span><br><span class="line">    CEngine engine;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar(<span class="keyword">int</span> p,<span class="keyword">int</span> tr,<span class="keyword">int</span> tw):price(p),tyre(tr,tw)&#123;&#125;	<span class="comment">//使用初始化列表编写构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封闭类对象生成时先执行所有成员对象的构造函数，在执行封闭类构造函数。封闭类对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数。</p>
<h4 id="3-6-2-封闭类的复制构造函数"><a href="#3-6-2-封闭类的复制构造函数" class="headerlink" title="3.6.2    封闭类的复制构造函数"></a>3.6.2    封闭类的复制构造函数</h4><p>封闭类对象如果使用默认复制构造函数初始化，其成员对象也会用复制构造函数初始化。</p>
<h3 id="3-7-const成员和引用成员"><a href="#3-7-const成员和引用成员" class="headerlink" title="3.7    const成员和引用成员"></a>3.7    const成员和引用成员</h3><p>常量成员变量和引用成员变量必须在构造函数初始化列表进行初始化，常量成员变量的值一旦初始化就不能改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> :</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> num; <span class="comment">//常量型成员变量</span></span><br><span class="line">		<span class="keyword">int</span> &amp; ref;     <span class="comment">//引用型成员变量</span></span><br><span class="line">		<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		CDemo( <span class="keyword">int</span> n):num(n),ref(f),value(<span class="number">4</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">		&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(CDemo) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-友元"><a href="#3-8-友元" class="headerlink" title="3.8    友元"></a>3.8    友元</h3><h4 id="3-8-1-友元函数"><a href="#3-8-1-友元函数" class="headerlink" title="3.8.1    友元函数"></a>3.8.1    友元函数</h4><p>定义类时可以把一些函数（包括全局函数和其他类的成员函数）声明为友元，友元函数可以访问该类的私有成员。不能把其他类的私有成员函数声明为友元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span>							<span class="comment">//提前声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[],<span class="keyword">int</span> total)</span></span>;		<span class="comment">//全局函数为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;				<span class="comment">//其他类成员函数为友元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[],<span class="keyword">int</span> total)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-2-友元类"><a href="#3-8-2-友元类" class="headerlink" title="3.8.2    友元类"></a>3.8.2    友元类</h4><p>定义类时将某个其他类声明为自己的友元，该类的所有成员函数就能访问自己对象的私有成员。友元关系不能传递。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	nt price;</span><br><span class="line">	riend <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span> <span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	CCar myCar;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span>  <span class="comment">//改装汽车</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		myCar.price += <span class="number">1000</span>;<span class="comment">//因CDriver是CCar的友元类，故此处可以访问其私有成员</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-this指针"><a href="#3-9-this指针" class="headerlink" title="3.9    this指针"></a>3.9    this指针</h3><h4 id="3-9-1-C-程序到C程序的翻译"><a href="#3-9-1-C-程序到C程序的翻译" class="headerlink" title="3.9.1    C++程序到C程序的翻译"></a>3.9.1    C++程序到C程序的翻译</h4><p>类被翻译成结构体，对象被翻译成结构变量，成员函数被翻译成全局函数，全局函数比成员函数多一个参数，即指向结构变量的this指针。</p>
<h4 id="3-9-2-this指针的作用"><a href="#3-9-2-this指针的作用" class="headerlink" title="3.9.2    this指针的作用"></a>3.9.2    this指针的作用</h4><p>静态成员函数内部不能使用this指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">double</span> real, imag;</span><br><span class="line">	Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) :real(r), imag(i) &#123; &#125;</span><br><span class="line">	<span class="function">Complex <span class="title">AddOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;real++;	<span class="comment">//相当于real++;</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-在多个文件中使用类"><a href="#3-10-在多个文件中使用类" class="headerlink" title="3.10    在多个文件中使用类"></a>3.10    在多个文件中使用类</h3><p>类的定义可以写在一个头文件中。非内联成员函数函数体只能出现在某一.cpp文件中，不能放在头文件。内联成员函数应当写在头文件中。</p>
]]></content>
  </entry>
</search>
