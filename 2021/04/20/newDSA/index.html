<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    数据结构与算法 |  tetrahedron&#39;s Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="tetrahedron's Hexo" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-newDSA"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数据结构与算法
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/20/newDSA/" class="article-date">
  <time datetime="2021-04-19T17:34:28.000Z" itemprop="datePublished">2021-04-20</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">38.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">195 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="一-概论"><a href="#一-概论" class="headerlink" title="一    概论"></a>一    概论</h2><h3 id="1-1-数据结构和抽象数据类型"><a href="#1-1-数据结构和抽象数据类型" class="headerlink" title="1.1    数据结构和抽象数据类型"></a>1.1    数据结构和抽象数据类型</h3><p>数据结构包括逻辑、存储和运算三个部分。逻辑结构包括线性结构和非线性结构，线性结构包括线性表，非线性结构包括树和图。数据的存储结构是逻辑结构到物理存储单元的映射，包括顺序、链接、索引和散列。抽象数据类型（ADT）定义了一组运算的数学模型，与物理存储结构无关，它隐藏了运算实现的细节和内部数据结构，利于软件复用。</p>
<h3 id="1-2-算法特性和分类"><a href="#1-2-算法特性和分类" class="headerlink" title="1.2    算法特性和分类"></a>1.2    算法特性和分类</h3><p>算法具有通用性、有效性、确定性、有穷性的特点。基本算法分类包括穷举、回溯、搜索、递归、分治、贪心、动态规划等。</p>
<h3 id="1-3-算法复杂性分析"><a href="#1-3-算法复杂性分析" class="headerlink" title="1.3    算法复杂性分析"></a>1.3    算法复杂性分析</h3><p>令$p(n)$和$q(n)$是两个非负函数，称$p(n)$渐进地大于$q(n)$当且仅当</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}\frac{q(n)}{p(n)}=0</script><p>称$q(n)$渐进地小于$p(n)$当且仅当$p(n)$渐进地大于$q(n)$，称$p(n)$渐进地等于$q(n)$当且仅当$q(n)$不渐进地大于$p(n)$且$p(n)$不渐进地大于$q(n)$。</p>
<p>记法$f(n)=O(g(n))$中表示$f(n)$渐进地小于或等于$g(n)$。</p>
<p>记法$f(n)=\Omega(g(n))$中表示$f(n)$渐进地大于或等于$g(n)$。</p>
<p>记法$f(n)=\Theta(g(n))$中表示$f(n)$渐进地等于$g(n)$。</p>
<p>记法$f(n)=o(g(n))$中表示$f(n)$渐进地小于$g(n)$。</p>
<p>$g(n)$通常为系数为1的单项。</p>
<a id="more"></a>
<h2 id="二-线性表"><a href="#二-线性表" class="headerlink" title="二    线性表"></a>二    线性表</h2><h3 id="myList-h"><a href="#myList-h" class="headerlink" title="myList.h"></a>myList.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myList.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                    <span class="comment">// 置空线性表</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                    <span class="comment">// 线性表为空时，返回True</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;                <span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;            <span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>;                <span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> p)</span></span>;                <span class="comment">// 返回位置p的元素值</span></span><br><span class="line">    <span class="function">T <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;            <span class="comment">// 用value修改位置p的元素值</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h3 id="arrList-h"><a href="#arrList-h" class="headerlink" title="arrList.h"></a>arrList.h</h3><p><a herf="#myList-h">#include “myList.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>            <span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrList</span> :</span> <span class="keyword">public</span> List&lt;T&gt; &#123;        <span class="comment">// 顺序表，向量</span></span><br><span class="line"><span class="keyword">private</span>:                        <span class="comment">// 线性表的取值类型和取值空间</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;                <span class="comment">// 私有变量，顺序表实例的最大长度</span></span><br><span class="line">    <span class="keyword">int</span> curLen;                    <span class="comment">// 私有变量，顺序表实例的当前长度</span></span><br><span class="line">    <span class="keyword">int</span> position;                <span class="comment">// 私有变量，当前处理位置</span></span><br><span class="line">    T *aList;                    <span class="comment">// 私有变量，存储顺序表的实例</span></span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 顺序表的运算集</span></span><br><span class="line">    arrList(<span class="keyword">const</span> <span class="keyword">int</span> size) &#123;        <span class="comment">// 创建一个新的顺序表，参数为表实例的最大长度</span></span><br><span class="line">        maxSize = size;</span><br><span class="line">        aList = <span class="keyword">new</span> T[maxSize];</span><br><span class="line">        curLen = position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~arrList() &#123;                    <span class="comment">// 析构函数，用于消除该表实例</span></span><br><span class="line">        <span class="keyword">delete</span>[] aList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                <span class="comment">// 将顺序表存储的内容清除，成为空表</span></span><br><span class="line">        <span class="keyword">delete</span>[] aList;</span><br><span class="line">        curLen = position = <span class="number">0</span>;</span><br><span class="line">        aList = <span class="keyword">new</span> T[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;                    <span class="comment">// 返回此顺序表的当前实际长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;            <span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;        <span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>;            <span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPos</span><span class="params">(<span class="keyword">const</span> T value)</span></span>;        <span class="comment">// 在线性表中查找值为value的元素，并返回第1次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;                     <span class="comment">// 打印线性表 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T </span></span><br><span class="line"><span class="keyword">int</span> arrList&lt;T&gt;::getPos(<span class="keyword">const</span> T value) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;                            <span class="comment">// 元素下标</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; curLen; i++) &#123;                <span class="comment">// 依次比较</span></span><br><span class="line">        <span class="keyword">if</span> (value == aList[i])            <span class="comment">// 下标为i的元素与value相等</span></span><br><span class="line">            <span class="keyword">return</span> i;                <span class="comment">// 返回下标i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                        <span class="comment">// 顺序表没有元素值为value的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设元素的类型为T， aList是存储顺序表的数组， maxSize是其最大长度；</span></span><br><span class="line"><span class="comment">// p为新元素value的插入位置,</span></span><br><span class="line"><span class="comment">// 插入成功则返回true, 否则返回false</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> arrList&lt;T&gt;::insert(<span class="keyword">int</span> p, <span class="keyword">const</span> T value) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (curLen &gt;= maxSize) &#123;                <span class="comment">// 检查顺序表是否溢出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The list is overflow&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; curLen) &#123;                <span class="comment">// 检查插入位置是否合法</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insertion is illegal&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = curLen; i &gt; p; i--)</span><br><span class="line">        aList[i] = aList[i - <span class="number">1</span>];            <span class="comment">// 从表尾curLen -1起往右移动直到p</span></span><br><span class="line">    aList[p] = value;                    <span class="comment">// 位置p处插入新元素</span></span><br><span class="line">    curLen++;                        <span class="comment">// 表的实际长度增1 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> arrList&lt;T&gt;::del(<span class="keyword">int</span> p) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (curLen &lt;= <span class="number">0</span>) &#123;                <span class="comment">// 检查顺序表是否为空</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; No element to delete \n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; curLen - <span class="number">1</span>) &#123;            <span class="comment">// 检查删除位置是否合法</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deletion is illegal\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = p; i &lt; curLen - <span class="number">1</span>; i++)</span><br><span class="line">        aList[i] = aList[i + <span class="number">1</span>];            <span class="comment">// 从位置p开始每个元素左移直到curLen,</span></span><br><span class="line">    curLen--;                        <span class="comment">// 表的实际长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">void</span> arrList&lt;T&gt;::print() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curLen; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; aList[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Link-h"><a href="#Link-h" class="headerlink" title="Link.h"></a>Link.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;                            <span class="comment">// 用于保存结点元素的内容</span></span><br><span class="line">    Link *next;                        <span class="comment">// 指向后继结点的指针</span></span><br><span class="line">    Link(<span class="keyword">const</span> T info, Link *nextValue = <span class="literal">NULL</span>) &#123;    <span class="comment">// 具有两个参数的Link构造函数</span></span><br><span class="line">        data = info;</span><br><span class="line">        next = nextValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Link(Link *nextValue = <span class="literal">NULL</span>) &#123;            <span class="comment">// 具有一个参数的Link构造函数</span></span><br><span class="line">        next = nextValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lnkList-h"><a href="#lnkList-h" class="headerlink" title="lnkList.h"></a>lnkList.h</h3><p><a herf="#Link-h">#include “Link.h”</a></p>
<p><a herf="#myList-h">#include “myList.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myList.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Link.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkList</span> :</span> <span class="keyword">public</span> List&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Link&lt;T&gt; *head;                    <span class="comment">// 单链表的头指针</span></span><br><span class="line">    Link&lt;T&gt; *tail;                    <span class="comment">// 单链表的尾指针</span></span><br><span class="line">    <span class="function">Link&lt;T&gt; *<span class="title">setPos</span><span class="params">(<span class="keyword">int</span> p)</span></span>;                <span class="comment">// 返回线性表指向第p个元素的指针值     </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    lnkList(<span class="keyword">int</span>);                        <span class="comment">// 构造函数</span></span><br><span class="line">    ~lnkList();                        <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                     <span class="comment">// 将链表存储的内容清除，成为空表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;                              <span class="comment">// 返回此顺序表的当前实际长度</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;                   <span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;            <span class="comment">// 在位置p上插入一个元素value，表的长度增1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>;                     <span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> p, T value)</span></span>;           <span class="comment">// 返回位置p的元素值 </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getPos</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> T value)</span></span>;    <span class="comment">// 查找值为value的元素，并返回第1次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">lnkList&lt;T&gt;::lnkList(<span class="keyword">int</span> defSize) &#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Link&lt;T&gt;(<span class="number">9999</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">lnkList&lt;T&gt;::~lnkList() &#123;</span><br><span class="line">    Link&lt;T&gt; *tmp;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定线性表的元素类型为T</span></span><br><span class="line">Link&lt;T&gt; *lnkList&lt;T&gt;::setPos(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    Link&lt;T&gt; *p;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">-1</span>)                   <span class="comment">// i为-1则定位到&quot;虚&quot;头结点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> Link&lt;T&gt;(head-&gt;next);      <span class="comment">// 若i为0则定位到第一个结点     </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; count &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> p;                <span class="comment">// 指向第 i 结点，i＝0,1,…，当链表中结点数小于i时返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 线性表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> lnkList&lt;T&gt;::insert(<span class="keyword">int</span> i, T value) &#123;</span><br><span class="line">    Link&lt;T&gt; *p, *q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = setPos(i - <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;        <span class="comment">// p是第i个结点的前驱</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; the insertion point is illegal&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = <span class="keyword">new</span> Link&lt;T&gt;(value, p-&gt;next);</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    <span class="keyword">if</span> (p == tail)                        <span class="comment">// 插入点在链尾，插入结点成为新的链尾</span></span><br><span class="line">        tail = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete a node from singly linked list</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 线性表的元素类型为T</span></span><br><span class="line"><span class="keyword">bool</span> lnkList&lt;T&gt;::del(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    Link&lt;T&gt; *p, *q;</span><br><span class="line">    <span class="keyword">if</span> ((p = setPos(i - <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;        <span class="comment">// 待删结点不存在，即给定的i大于当前链中元素个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; the deletion point is illegal&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;next;                            <span class="comment">// q是真正待删结点</span></span><br><span class="line">    <span class="keyword">if</span> (q == tail) &#123;                        <span class="comment">// 待删结点为尾结点，则修改尾指针</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;                        <span class="comment">// 删除结点q 并修改链指针</span></span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="keyword">void</span> lnkList&lt;T&gt;::print() &#123;</span><br><span class="line">    Link&lt;T&gt; *tmp = head;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;begin\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;end\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-栈与队列"><a href="#三-栈与队列" class="headerlink" title="三    栈与队列"></a>三    栈与队列</h2><h3 id="myStack-h"><a href="#myStack-h" class="headerlink" title="myStack.h"></a>myStack.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myStack.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> 					<span class="comment">// 栈的元素类型为 T</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: 	            			<span class="comment">// 栈的运算集</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;	   			<span class="comment">// 变为空栈</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span></span>; 		<span class="comment">// item入栈，成功则返回真，否则返回假</span></span><br><span class="line"> 	<span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;				<span class="comment">// 返回栈顶内容并弹出，成功返回真，否则返回假,</span></span><br><span class="line"> 	<span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T&amp; item)</span></span>;	  			<span class="comment">// 返回栈顶内容但不弹出成功返回真，否则返回假,</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; 	   			<span class="comment">// 若栈已空返回真</span></span><br><span class="line">   	<span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;        			<span class="comment">// 若栈已满返回真</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="lnkStack-h"><a href="#lnkStack-h" class="headerlink" title="lnkStack.h"></a>lnkStack.h</h3><p><a herf="#myStack-h">#include “myStack.h”</a></p>
<p><a herf="#Link-h">#include “Link.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Link.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkStack</span> :</span> <span class="keyword">public</span> Stack&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:                                <span class="comment">// 栈的链式存储</span></span><br><span class="line">    Link&lt;T&gt; *top;                    <span class="comment">// 指向栈顶的指针</span></span><br><span class="line">    <span class="keyword">int</span> size;                    <span class="comment">// 存放元素的个数</span></span><br><span class="line"><span class="keyword">public</span>:                                <span class="comment">// 栈运算的链式实现</span></span><br><span class="line">    lnkStack(<span class="keyword">int</span> defSize) &#123;                <span class="comment">// 构造函数</span></span><br><span class="line">        top = <span class="literal">NULL</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~lnkStack() &#123;                    <span class="comment">// 析构函数</span></span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 清空栈内容</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Link&lt;T&gt; *tmp = top;</span><br><span class="line">            top = top-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;                <span class="comment">// 入栈操作的链式实现	</span></span><br><span class="line">        Link&lt;T&gt; *tmp = <span class="keyword">new</span> Link&lt;T&gt;(item, top);</span><br><span class="line">        top = tmp;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T *item)</span> </span>&#123;                <span class="comment">// 出栈的链式实现</span></span><br><span class="line">        Link&lt;T&gt; *tmp;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = top-&gt;data;</span><br><span class="line">        tmp = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = tmp;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T *item)</span> </span>&#123;                <span class="comment">// 返回栈顶内容，但不弹出</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = top-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="arrStack-h"><a href="#arrStack-h" class="headerlink" title="arrStack.h"></a>arrStack.h</h3><p><a herf="#myStack-h">#include “myStack.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  array-based stack: definition and implementation for some methods</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrStack</span> :</span> <span class="keyword">public</span> Stack&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:                            <span class="comment">// 栈的顺序存储</span></span><br><span class="line">    <span class="keyword">int</span> mSize;            <span class="comment">// 栈中最多可存放的元素个数</span></span><br><span class="line">    T *st;            <span class="comment">// 存放栈元素的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> top;                    <span class="comment">// 栈顶位置，应小于mSize </span></span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 栈的运算的顺序实现</span></span><br><span class="line">    arrStack(<span class="keyword">int</span> size) &#123;                <span class="comment">// 创建一个顺序栈的实例</span></span><br><span class="line">        mSize = size;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        st = <span class="keyword">new</span> T[mSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arrStack() &#123;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~arrStack() &#123;                    <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] st;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 清空栈内容</span></span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;            <span class="comment">// 入栈操作的顺序实现	</span></span><br><span class="line">        <span class="keyword">if</span> (top == mSize - <span class="number">1</span>) &#123;            <span class="comment">// 栈已满 </span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈满溢出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 新元素入栈并修改栈顶指针</span></span><br><span class="line">            st[++top] = item;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T *item)</span> </span>&#123;                                    <span class="comment">// 出栈的顺序实现</span></span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;                                   <span class="comment">// 栈为空</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *item = st[top--];             <span class="comment">// 返回栈顶元素并修改栈顶指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(T *item)</span> </span>&#123;                     <span class="comment">// 返回栈顶内容，但不弹出</span></span><br><span class="line">        <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;                     <span class="comment">// 栈空</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 栈为空，不能出栈操作&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *item = st[top];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (top == <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (top == mSize - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Calculator-h"><a href="#Calculator-h" class="headerlink" title="Calculator.h"></a>Calculator.h</h3><p><a herf="#arrStack-h">#include “arrStack.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arrStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Class Declaration 类的说明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    arrStack&lt;<span class="keyword">double</span>&gt; s;        <span class="comment">// 这个栈用于压入保存操作数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">GetTwoOperands</span><span class="params">(<span class="keyword">double</span> &amp;opd1, <span class="keyword">double</span> &amp;opd2)</span></span>;    <span class="comment">// 从栈顶弹出两个操作数opd1和opd2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Compute</span><span class="params">(<span class="keyword">char</span> op)</span></span>;    <span class="comment">// 调用GetTwoOperands，并按op运算对两个操作数进行计算</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//       Calculator()&#123;&#125; ;		// 创建计算器实例，开辟一个空栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;            <span class="comment">// 后缀表达式的读入，在遇到符号&quot;=&quot;时 ，启动求值计算 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span></span>;        <span class="comment">// 计算器的清除，为随后的下一次计算做准备  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算器类class Calculator中部分成员函数的程序实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Calculator::GetTwoOperands</span><span class="params">(<span class="keyword">double</span> &amp;opd1, <span class="keyword">double</span> &amp;opd2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Missing operand!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.pop(&amp;opd1);                            <span class="comment">// 右操作数</span></span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Missing operand!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.pop(&amp;opd2);                        <span class="comment">// 左操作数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculator::Compute</span><span class="params">(<span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result;</span><br><span class="line">    <span class="keyword">double</span> operand1, operand2;</span><br><span class="line">    result = GetTwoOperands(operand1, operand2);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">                s.push(operand2 + operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">                s.push(operand2 - operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">                s.push(operand2 * operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                <span class="keyword">if</span> (operand1 == <span class="number">0.0</span>) &#123;</span><br><span class="line">                    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Divide by 0!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    s.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    s.push(operand2 / operand1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculator::Run</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> newOperand, res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; c, c != <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :</span><br><span class="line">                Compute(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="built_in">cin</span>.putback(c);</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; newOperand;</span><br><span class="line">                s.push(newOperand);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">        s.pop(&amp;res);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;                    <span class="comment">// 印出求值的最后结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="myQueue-h"><a href="#myQueue-h" class="headerlink" title="myQueue.h"></a>myQueue.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>  &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: 			        		<span class="comment">// 队列的运算集</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;					<span class="comment">// 变为空队列</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T item)</span></span>; 		<span class="comment">// item入队，插入队尾，成功则返回真否则返回假</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T item)</span></span>;     	<span class="comment">// 返回队头元素并从队列中删除，成功则返回真</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">front</span><span class="params">(T* item)</span></span>;	       	<span class="comment">// 返回队头元素，但不删除，成功则返回真</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; 				<span class="comment">// 返回真，若队列已空</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;       			<span class="comment">// 返回真，若队列已满</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="arrQueue-h"><a href="#arrQueue-h" class="headerlink" title="arrQueue.h"></a>arrQueue.h</h3><p><a herf="#myQueue-h">#include “myQueue.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array-base queue</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arrQueue</span> :</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;</span>T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mSize;                        <span class="comment">// 存放队列的数组的大小</span></span><br><span class="line">    <span class="keyword">int</span> front;                            <span class="comment">// 表示队头所在位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> rear;                            <span class="comment">// 表示队尾所在位置的下标</span></span><br><span class="line">    T *qu;     <span class="comment">// 存放类型为T的队列元素的数组</span></span><br><span class="line"><span class="keyword">public</span>:                                <span class="comment">// 队列的运算集</span></span><br><span class="line">    arrQueue(<span class="keyword">int</span> size) &#123;                    <span class="comment">// 创建队列的实例</span></span><br><span class="line">        mSize = size + <span class="number">1</span>;                    <span class="comment">// 浪费一个存储空间，以区别队列空和队列满</span></span><br><span class="line">        qu = <span class="keyword">new</span> T[mSize];</span><br><span class="line">        front = rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~arrQueue() &#123;                    <span class="comment">// 消除该实例，并释放其空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] qu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> clear&#123;                        <span class="comment">// 清空队列</span></span><br><span class="line">            front = rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(T item)</span> </span>&#123;                <span class="comment">//  item入队，插入队尾</span></span><br><span class="line">        <span class="keyword">if</span> (((rear + <span class="number">1</span>) % mSize) == front) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列已满，溢出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qu[rear] = item;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % mSize;            <span class="comment">// 循环后继</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T &amp;item)</span> </span>&#123;                <span class="comment">// 返回队头元素并从队列中删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = qu[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % mSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">front</span><span class="params">(T &amp;item)</span> </span>&#123;                    <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        item = qu[front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lnkQueue-h"><a href="#lnkQueue-h" class="headerlink" title="lnkQueue.h"></a>lnkQueue.h</h3><p><a herf="#lnkQueue-h">#include “lnkQueue.h”</a></p>
<p><a herf="#Link-h">#include “Link.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Link.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lnkQueue</span> :</span> <span class="keyword">public</span> Queue&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;                            <span class="comment">// 队列中当前元素的个数</span></span><br><span class="line">    Link&lt;T&gt; *front;                            <span class="comment">// 表示队头的指针</span></span><br><span class="line">    Link&lt;T&gt; *rear;                            <span class="comment">// 表示队尾的指针</span></span><br><span class="line"><span class="keyword">public</span>:                                    <span class="comment">// 队列的运算集</span></span><br><span class="line">    lnkQueue(<span class="keyword">int</span> size) &#123;                        <span class="comment">// 创建队列的实例</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        front = rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~lnkQueue() &#123;                        <span class="comment">// 消除该实例，并释放其空间</span></span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;                            <span class="comment">// 清空队列</span></span><br><span class="line">        <span class="keyword">while</span> (front != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rear = front;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> rear;</span><br><span class="line">        &#125;</span><br><span class="line">        rear = <span class="literal">NULL</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T item)</span> </span>&#123;                <span class="comment">//  item入队，插入队尾</span></span><br><span class="line">        <span class="keyword">if</span> (rear == <span class="literal">NULL</span>) &#123;                <span class="comment">// 空队列</span></span><br><span class="line">            front = rear = <span class="keyword">new</span> Link&lt;T&gt;(item, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 添加新的元素</span></span><br><span class="line">            rear-&gt;next = <span class="keyword">new</span> Link&lt;T&gt;(item, <span class="literal">NULL</span>);</span><br><span class="line">            rear = rear-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T *item)</span> </span>&#123;                    <span class="comment">// 返回队头元素并从队列中删除</span></span><br><span class="line">        Link&lt;T&gt; *tmp;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;                        <span class="comment">// 队列为空，没有元素可出队</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = front-&gt;data;</span><br><span class="line">        tmp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">            rear = <span class="literal">NULL</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getFront</span><span class="params">(T *item)</span> </span>&#123;                        <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;                        <span class="comment">// 队列为空，没有元素可出队</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *item = front-&gt;data;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                    <span class="comment">// 返回队头元素，但不删除</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Link&lt;T&gt; *p = front;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四-字符串"><a href="#四-字符串" class="headerlink" title="四    字符串"></a>四    字符串</h2><h3 id="myString-h"><a href="#myString-h" class="headerlink" title="myString.h"></a>myString.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String(<span class="keyword">char</span> *s) &#123;</span><br><span class="line">        size = <span class="built_in">strlen</span>(s);</span><br><span class="line">        str = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">1</span>];</span><br><span class="line">        assert(str != <span class="string">&#x27;\0&#x27;</span>);       <span class="comment">// 当开辟动态区域不成功时，运行异常退出</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">Substr</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> left = size - pos;                    <span class="comment">// 自下标pos向右计数到串尾查看剩余长度</span></span><br><span class="line">        String tmp;</span><br><span class="line">        <span class="keyword">char</span> *p, *q;</span><br><span class="line">        <span class="comment">// 以下7行语句，全是为取出子串做准备工作</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= size)                        <span class="comment">// 若下标pos值超过本串实际串长，则返回空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; left)                        <span class="comment">// 若n超过自pos以右的子串长度，则把n变小</span></span><br><span class="line">            n = left;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp.str;                    <span class="comment">// 释放原来的存储空间</span></span><br><span class="line">        tmp.str = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">        assert(tmp.str != <span class="literal">NULL</span>);                <span class="comment">// 若开辟动态存储空间失败，则退出</span></span><br><span class="line">        p = tmp.str;                        <span class="comment">//  p指向暂无内容的字符串</span></span><br><span class="line">        q = &amp;str[pos];                        <span class="comment">//  q指向本实例串str数组下标pos处</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            *p++ = *q++;                    <span class="comment">// 将q所指的内容赋值给 p，并同时后移</span></span><br><span class="line">        *p = <span class="string">&#x27;\0&#x27;</span>;                        <span class="comment">// 循环结束后，让temp.str的结尾为&#x27;\0&#x27;</span></span><br><span class="line">        tmp.size = n;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> String &amp;s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> String &amp;s) &#123;</span><br><span class="line">    os &lt;&lt; s.str;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="KMPStrMatching-h"><a href="#KMPStrMatching-h" class="headerlink" title="KMPStrMatching.h"></a>KMPStrMatching.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPStrMatching</span><span class="params">(<span class="built_in">string</span> T, <span class="built_in">string</span> P,  <span class="keyword">int</span> *N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;							<span class="comment">// 模式的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;							<span class="comment">// 目标的下标变量</span></span><br><span class="line">    <span class="keyword">int</span> pLen = P. length ( );             		<span class="comment">// 模式的长度</span></span><br><span class="line">    <span class="keyword">int</span> tLen = T.length( );					<span class="comment">// 目标的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tLen &lt; pLen) 				    		<span class="comment">// 如果目标比模式短，匹配无法成功</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);          			</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; pLen  &amp;&amp;  j &lt; tLen)  &#123;  		<span class="comment">// 反复比较对应字符来开始匹配</span></span><br><span class="line">       		<span class="keyword">if</span> ( i == <span class="number">-1</span>  ||  T[j] == P[i]) </span><br><span class="line">    			i++,  j++;</span><br><span class="line">    		<span class="keyword">else</span> i = N[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= pLen)</span><br><span class="line">    		<span class="keyword">return</span> (j - pLen + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">findNext</span><span class="params">(<span class="built_in">string</span> P)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span> m = P.length();    					<span class="comment">// m为字符串P的长度</span></span><br><span class="line">  	assert(m &gt; <span class="number">0</span>);     					<span class="comment">// 若m＝0，退出</span></span><br><span class="line">  	<span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[m];  				<span class="comment">// 动态存储区开辟整数数组</span></span><br><span class="line">    assert(next != <span class="number">0</span>);   					<span class="comment">// 若开辟存储区域失败，退出</span></span><br><span class="line">  	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) &#123; 						<span class="comment">// 计算i=1..m-1的next值</span></span><br><span class="line">		<span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; P[i] != P[k])  		<span class="comment">// 求最大首尾子串</span></span><br><span class="line">			k = next[k];		</span><br><span class="line">        i++;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">if</span> (i == m) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (P[i] == P[k] ) 				</span><br><span class="line">			next[i] = next[k];				<span class="comment">//  P[i]和P[k]相等，优化</span></span><br><span class="line">		<span class="keyword">else</span> next[i] = k;					<span class="comment">// 不需要优化，就是位置i的首尾子串长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="五-二叉树"><a href="#五-二叉树" class="headerlink" title="五    二叉树"></a>五    二叉树</h2><h3 id="BinaryTreeNode-h"><a href="#BinaryTreeNode-h" class="headerlink" title="BinaryTreeNode.h"></a>BinaryTreeNode.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  BinaryTreeNode.h  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;</span>T&gt;;	<span class="comment">//声明二叉树为结点类的友元类，便于访问私有数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T  info;				     	    	<span class="comment">//二叉树结点数据域</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* left;		   		<span class="comment">//二叉树结点指向左子树的指针</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* right;    			<span class="comment">//二叉树结点指向左子树的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTreeNode();							<span class="comment">//缺省构造函数</span></span><br><span class="line">	BinaryTreeNode(<span class="keyword">const</span> T&amp; inf);	 			<span class="comment">//给定数据的构造函数</span></span><br><span class="line">	BinaryTreeNode(<span class="keyword">const</span> T&amp; inf,BinaryTreeNode&lt;T&gt;* l, BinaryTreeNode&lt;T&gt;* r);<span class="comment">//给定了结点值和左右子树的构造函数</span></span><br><span class="line">	<span class="function">T  <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>;							<span class="comment">//返回当前结点的数据</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;*  <span class="title">leftchild</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//返回当前结点左子树</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;*  <span class="title">rightchild</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//返回当前结点右子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setLeftchild</span><span class="params">(BinaryTreeNode&lt;T&gt;*)</span> </span>;	<span class="comment">//设置当前结点的左子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setRightchild</span><span class="params">(BinaryTreeNode&lt;T&gt;*)</span> </span>;	<span class="comment">//设置当前结点的右子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>  <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>; 				<span class="comment">//设置当前结点的数据域</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span>  <span class="title">isLeaf</span><span class="params">()</span> <span class="keyword">const</span></span>;				<span class="comment">//判定当前结点是否为叶结点,若是返回true</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> BinaryTreeNode&lt;T&gt;&amp; Node)&#123;<span class="keyword">this</span> = Node;&#125;;<span class="comment">//重载赋值操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//****** BinaryTreeNode Implementation *******//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode()  &#123;</span><br><span class="line">	left = right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode(<span class="keyword">const</span> T&amp; inf)  &#123;	<span class="comment">//给定数据的构造函数</span></span><br><span class="line">	info = inf;</span><br><span class="line">	left = right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;::BinaryTreeNode(<span class="keyword">const</span> T&amp; inf,BinaryTreeNode* l, BinaryTreeNode* r)  &#123;<span class="comment">//给定数据的左右指针的构造函数</span></span><br><span class="line">	info = inf;</span><br><span class="line">	left = l;</span><br><span class="line">	right = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T  BinaryTreeNode&lt;T&gt;::value() <span class="keyword">const</span>  &#123;</span><br><span class="line">	<span class="keyword">return</span> info; </span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;*  BinaryTreeNode&lt;T&gt;::leftchild() <span class="keyword">const</span>  &#123; <span class="comment">//返回当前结点指向左子树的指针</span></span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;												</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;*  BinaryTreeNode&lt;T&gt;::rightchild() <span class="keyword">const</span>  &#123; <span class="comment">//返回当前结点指向右子树的指针</span></span><br><span class="line">	<span class="keyword">return</span> right;								</span><br><span class="line">&#125;			</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setLeftchild(BinaryTreeNode&lt;T&gt;* subroot)  &#123; <span class="comment">//设置当前结点的左子树</span></span><br><span class="line">	left = subroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setRightchild(BinaryTreeNode&lt;T&gt;* subroot)  &#123; <span class="comment">//设置当前结点的右子树</span></span><br><span class="line">	right = subroot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  BinaryTreeNode&lt;T&gt;::setValue(<span class="keyword">const</span> T&amp; val)  &#123;	<span class="comment">//设置当前结点的数据域</span></span><br><span class="line">	info = val; </span><br><span class="line">&#125; 									</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span>  BinaryTreeNode&lt;T&gt;::isLeaf() <span class="keyword">const</span>	 &#123;	<span class="comment">//判定当前结点是否为叶结点,若是返回true</span></span><br><span class="line">	<span class="keyword">return</span> (left == <span class="literal">NULL</span>) &amp;&amp; (right == <span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BinaryTree-h"><a href="#BinaryTree-h" class="headerlink" title="BinaryTree.h"></a>BinaryTree.h</h3><p><a herf="#BinaryTreeNode-h">#include “BinaryTreeNode.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************BinaryTree.h****************//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BinaryTreeNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Tags</span>&#123;</span>Left,Right&#125;;    <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackElement</span>  &#123;</span>         <span class="comment">//StackElement</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer;</span><br><span class="line">	Tags tag;</span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	BinaryTreeNode&lt;T&gt;*  root;      			<span class="comment">//二叉树根结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BinaryTree()&#123;root = <span class="literal">NULL</span>;&#125;;				<span class="comment">//构造函数</span></span><br><span class="line">	~BinaryTree() &#123;DeleteBinaryTree(root);&#125;;	<span class="comment">//析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;						<span class="comment">//判定二叉树是否为空树</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">Root</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> root;&#125;;	<span class="comment">//返回二叉树根结点</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">Parent</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;<span class="comment">//返回current的父结点</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">LeftSibling</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;</span><br><span class="line">	<span class="comment">//返回current结点的左兄弟</span></span><br><span class="line">	<span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">RightSibling</span><span class="params">(BinaryTreeNode&lt;T&gt;* current)</span></span>;</span><br><span class="line">	<span class="comment">//返回current结点的右兄弟</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(<span class="keyword">const</span> T&amp; info, BinaryTree&lt;T&gt;&amp; leftTree, BinaryTree&lt;T&gt;&amp; rightTree)</span></span>;</span><br><span class="line">	<span class="comment">//构造一棵以info为根、leftTree和rightTree为左右子树的新二叉树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;  	<span class="comment">//前序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;		<span class="comment">//中序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;	<span class="comment">//后序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归前序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归中序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostOrderWithoutRecursion</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;<span class="comment">//非递归后序周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>; 	<span class="comment">//按层次周游二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DeleteBinaryTree</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;	<span class="comment">//删除二叉树或其子树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; Value;&#125;;           <span class="comment">//访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//**********  BianryTree Implementation  ***********//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> BinaryTree&lt;T&gt;:: isEmpty() <span class="keyword">const</span>  &#123;      <span class="comment">//判定二叉树是否为空树</span></span><br><span class="line">	<span class="keyword">return</span> ( root? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::Parent(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;						<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> != root &amp;&amp; <span class="literal">NULL</span> != current)  &#123;		</span><br><span class="line">		<span class="keyword">while</span>(!aStack.empty() || pointer)	&#123;</span><br><span class="line">			<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">				<span class="keyword">if</span>(current == pointer-&gt;leftchild() ||current == pointer-&gt;rightchild()) <span class="comment">//如果当前pointer的孩子就是current，返回parent</span></span><br><span class="line">					<span class="keyword">return</span> pointer;</span><br><span class="line">				aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">				pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  &#123;                         <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">				pointer = aStack.top();			<span class="comment">//栈顶元素退栈                 </span></span><br><span class="line">				aStack.pop();</span><br><span class="line">				pointer = pointer-&gt;rightchild();  	<span class="comment">//当前链接结构指向右孩子</span></span><br><span class="line">			&#125;<span class="comment">//endif</span></span><br><span class="line">		&#125; <span class="comment">//endwhile</span></span><br><span class="line">	&#125;<span class="comment">//endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::LeftSibling(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="comment">//返回current结点的左兄弟</span></span><br><span class="line">	<span class="keyword">if</span>(current)  &#123;</span><br><span class="line">		BinaryTreeNode&lt;T&gt;* temp = Parent(current);    <span class="comment">//返回current结点的父结点</span></span><br><span class="line">		<span class="keyword">if</span> ((temp == <span class="literal">NULL</span>) || current == temp-&gt;leftchild())</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">NULL</span>;	  <span class="comment">//如果父结点为空，或者current没有左兄弟，返回空</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> temp-&gt;leftchild();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::RightSibling(BinaryTreeNode&lt;T&gt;* current)  &#123;</span><br><span class="line">	<span class="comment">//返回current结点的右兄弟</span></span><br><span class="line">	<span class="keyword">if</span>(current)  &#123;</span><br><span class="line">		BinaryTreeNode&lt;T&gt;* temp = Parent(current);<span class="comment">//返回current结点的父结点</span></span><br><span class="line">		<span class="keyword">if</span>(temp == <span class="literal">NULL</span>||current == temp-&gt;rightchild())</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">NULL</span>;		    <span class="comment">//如果父结点为空，或者current没有右兄弟</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> temp-&gt;rightchild();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: CreateTree (<span class="keyword">const</span> T&amp; info, BinaryTree&lt;T&gt;&amp; leftTree, BinaryTree&lt;T&gt;&amp; rightTree)  &#123;</span><br><span class="line">	<span class="comment">//由左子树leftTree、右子树rightTree和数据元素info创建一棵新树，根结点是info</span></span><br><span class="line">	<span class="comment">//其中this、leftTree、rightTree必须是不同的三棵树</span></span><br><span class="line">	root = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;(info, leftTree.root, rightTree.root);	<span class="comment">//创建新树</span></span><br><span class="line">	leftTree.root = rightTree.root = <span class="literal">NULL</span>;  <span class="comment">//原来两棵子树的根结点指空，避免访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: DeleteBinaryTree(BinaryTreeNode&lt;T&gt;* root)  &#123; <span class="comment">//以后序周游的方式删除二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root)  &#123;</span><br><span class="line">		DeleteBinaryTree(root-&gt;left);				<span class="comment">//递归删除左子树</span></span><br><span class="line">		DeleteBinaryTree(root-&gt;right);		    <span class="comment">//递归删除右子树</span></span><br><span class="line">		<span class="keyword">delete</span> root;							<span class="comment">//删除根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrder (BinaryTreeNode&lt;T&gt;* root)  &#123;  <span class="comment">//前序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">		PreOrder(root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		PreOrder(root-&gt;rightchild());			<span class="comment">//访问右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: InOrder (BinaryTreeNode&lt;T&gt;* root)  &#123;  <span class="comment">//中序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		InOrder (root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">		InOrder (root-&gt;rightchild());			<span class="comment">//访问右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;:: PostOrder (BinaryTreeNode&lt;T&gt;* root)  &#123; <span class="comment">//后序周游二叉树</span></span><br><span class="line">	<span class="keyword">if</span>(root != <span class="literal">NULL</span>)  &#123;</span><br><span class="line">		PostOrder(root-&gt;leftchild());			<span class="comment">//访问左子树</span></span><br><span class="line">		PostOrder (root-&gt;rightchild());		<span class="comment">//访问右子树</span></span><br><span class="line">		Visit(root-&gt;value());						<span class="comment">//访问当前结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PreOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;<span class="comment">//非递归前序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;						<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">while</span>(!aStack.empty() || pointer)	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">			Visit(pointer-&gt;value());			<span class="comment">//访问当前结点</span></span><br><span class="line">			aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  &#123;                         <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">			pointer = aStack.top();			<span class="comment">//栈顶元素退栈                 </span></span><br><span class="line">			aStack.pop();</span><br><span class="line">			pointer = pointer-&gt;rightchild();  	<span class="comment">//当前链接结构指向右孩子</span></span><br><span class="line">		&#125;<span class="comment">//endif</span></span><br><span class="line">    &#125; <span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::InOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;</span><br><span class="line">	<span class="comment">//非递归中序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;							<span class="comment">//使用STL中的stack</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;* &gt; aStack;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;      	<span class="comment">//保存输入参数	</span></span><br><span class="line">	<span class="keyword">while</span>(!aStack.empty() || pointer)  &#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer)  &#123;</span><br><span class="line">			aStack.push(pointer);				<span class="comment">//当前结点地址入栈</span></span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//当前链接结构指向左孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  &#123;                            <span class="comment">//左子树访问完毕，转向访问右子树</span></span><br><span class="line">			pointer = aStack.top();</span><br><span class="line">			aStack.pop();					<span class="comment">//栈顶元素退栈    </span></span><br><span class="line">			Visit(pointer-&gt;value());		<span class="comment">//访问当前结点</span></span><br><span class="line">			pointer = pointer-&gt;rightchild(); 	<span class="comment">//当前链接结构指向右孩子             </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::PostOrderWithoutRecursion(BinaryTreeNode&lt;T&gt;* root)  &#123;</span><br><span class="line">	<span class="comment">//非递归后序周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;							<span class="comment">//使用STL栈部分</span></span><br><span class="line">	StackElement&lt;T&gt; element;</span><br><span class="line">	<span class="built_in">stack</span>&lt;StackElement&lt;T &gt; &gt; aStack;			<span class="comment">//栈申明</span></span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;							<span class="comment">//空树即返回</span></span><br><span class="line">	<span class="keyword">else</span> pointer = root;						<span class="comment">//保存输入参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!aStack.empty() || pointer) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pointer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			element.pointer = pointer;</span><br><span class="line">			element.tag = Left;</span><br><span class="line">			aStack.push(element);</span><br><span class="line">			pointer = pointer-&gt;leftchild();		<span class="comment">//沿左子树方向向下周游</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		element = aStack.top();</span><br><span class="line">		aStack.pop();							<span class="comment">//托出栈顶元素</span></span><br><span class="line">		pointer = element.pointer;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (element.tag == Left)&#123;</span><br><span class="line">			<span class="comment">//从左子树回来</span></span><br><span class="line">			element.tag = Right;</span><br><span class="line">			aStack.push(element);</span><br><span class="line">			pointer = pointer-&gt;rightchild();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                                  <span class="comment">//从右子树回来</span></span><br><span class="line">			Visit(pointer-&gt;value());		    <span class="comment">//访问当前结点</span></span><br><span class="line">			pointer = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;T&gt;::LevelOrder(BinaryTreeNode&lt;T&gt;* root)	&#123;</span><br><span class="line">	<span class="comment">//按层次周游二叉树或其子树</span></span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;							<span class="comment">//使用STL的队列</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;BinaryTreeNode&lt;T&gt;*&gt; aQueue;</span><br><span class="line">	BinaryTreeNode&lt;T&gt;* pointer = root;			<span class="comment">//保存输入参数</span></span><br><span class="line">	<span class="keyword">if</span> (pointer)</span><br><span class="line">		aQueue.push(pointer);                  <span class="comment">//根结点入队列</span></span><br><span class="line">	<span class="keyword">while</span> (!aQueue.empty())  &#123;                 <span class="comment">//队列非空</span></span><br><span class="line">		pointer = aQueue.front();			 	<span class="comment">//取队列首结点</span></span><br><span class="line">		aQueue.pop();                        <span class="comment">//当前结点出队列</span></span><br><span class="line">        Visit(pointer-&gt;value());					<span class="comment">//访问当前结点</span></span><br><span class="line">		<span class="keyword">if</span>(pointer-&gt;leftchild())</span><br><span class="line">			aQueue.push(pointer-&gt;leftchild());		<span class="comment">//左子树进队列</span></span><br><span class="line">		<span class="keyword">if</span>(pointer-&gt;rightchild())</span><br><span class="line">			aQueue.push(pointer-&gt;rightchild());	<span class="comment">//右子树进队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BinarySearchTree-h"><a href="#BinarySearchTree-h" class="headerlink" title="BinarySearchTree.h"></a>BinarySearchTree.h</h3><p><a herf="#BinaryTree-h">#include “BinaryTree.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*******  BinarySearchTree.h  ******//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;BinaryTreeNode.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;BinaryTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> :</span> <span class="keyword">public</span> BinaryTree&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinarySearchTree() &#123; <span class="keyword">this</span>-&gt;root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~BinarySearchTree() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(BinaryTreeNode&lt;T&gt; *newpointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt; *<span class="title">Root</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;root; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(BinaryTreeNode&lt;T&gt; *root, BinaryTreeNode&lt;T&gt; *newpointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(BinaryTreeNode&lt;T&gt; *pointer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteNodeEx</span><span class="params">(BinaryTreeNode&lt;T&gt; *pointer)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********  implemention ***********//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::Initialize(BinaryTreeNode&lt;T&gt; *newpointer) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root = newpointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::InsertNode(BinaryTreeNode&lt;T&gt; *root,</span><br><span class="line">                                     BinaryTreeNode&lt;T&gt; *newpointer) &#123;                          <span class="comment">//向二叉搜索树插入新结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;                 <span class="comment">//如果是空树，初始化</span></span><br><span class="line">        Initialize(newpointer);            <span class="comment">//用指针newpointer初始化二叉搜索树树根，赋值实现</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        pointer = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newpointer-&gt;value() == pointer-&gt;value())</span><br><span class="line">            <span class="keyword">return</span>;                      <span class="comment">//相等则不用插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newpointer-&gt;value() &lt; pointer-&gt;value()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pointer-&gt;leftchild() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pointer-&gt;left = newpointer;        <span class="comment">//作为左子树</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> pointer = pointer-&gt;leftchild();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pointer-&gt;rightchild() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pointer-&gt;right = newpointer;      <span class="comment">//作为右子树</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> pointer = pointer-&gt;rightchild();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//endwhile</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">void BinarySearchTree&lt;T&gt;::DeleteNode(BinaryTreeNode&lt;T&gt;* pointer)  &#123;      //教材中写出这个算法</span></span><br><span class="line"><span class="comment">	//二叉搜索树中结点的删除</span></span><br><span class="line"><span class="comment">	BinaryTreeNode&lt;T&gt;* temppointer = NULL;</span></span><br><span class="line"><span class="comment">	if(!pointer)                            //如果删除的是空结点，则返回</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	BinaryTreeNode&lt;T&gt;* parent = Parent(pointer);</span></span><br><span class="line"><span class="comment">	if (pointer-&gt;leftchild() == NULL)  &#123;</span></span><br><span class="line"><span class="comment">		//被删结点无左子树，则将其右子树的根代替该删除结点</span></span><br><span class="line"><span class="comment">		if (parent == NULL)                 //被删除结点是根结点</span></span><br><span class="line"><span class="comment">			root = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		else if (parent-&gt;leftchild() == pointer)</span></span><br><span class="line"><span class="comment">			parent-&gt;left = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">			parent-&gt;right = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">		delete pointer;                     //删除该结点</span></span><br><span class="line"><span class="comment">		pointer = NULL;</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	else                                 //左子树不为空时</span></span><br><span class="line"><span class="comment">		temppointer = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	while (temppointer-&gt;rightchild() != NULL)  //在左子树中找对称序的最后一个结点</span></span><br><span class="line"><span class="comment">		temppointer = temppointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">	//被删除结点的右子树作为temppointer的右子树</span></span><br><span class="line"><span class="comment">	temppointer-&gt;right = pointer-&gt;rightchild();</span></span><br><span class="line"><span class="comment">	//被删除结点的左子树根代替被删除结点</span></span><br><span class="line"><span class="comment">	if(NULL == parent)</span></span><br><span class="line"><span class="comment">		root = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	else if (parent-&gt;leftchild() == pointer)</span></span><br><span class="line"><span class="comment">		parent-&gt;left = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	else </span></span><br><span class="line"><span class="comment">		parent-&gt;right = pointer-&gt;leftchild();</span></span><br><span class="line"><span class="comment">	delete pointer;                          //删除该结点</span></span><br><span class="line"><span class="comment">	pointer = NULL;</span></span><br><span class="line"><span class="comment">	return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BinarySearchTree&lt;T&gt;::DeleteNodeEx(BinaryTreeNode&lt;T&gt; *pointer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pointer == <span class="literal">NULL</span>)                    <span class="comment">// 若待删除结点不存在，返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *temppointer;         <span class="comment">// 用于保存替换结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *tempparent = <span class="literal">NULL</span>;  <span class="comment">// 用于保存替换结点的父结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *parent = Parent(pointer); <span class="comment">// 保存删除结点的父结点</span></span><br><span class="line">    <span class="comment">// 如果待删除结点的左子树为空，就将它的右子树代替它</span></span><br><span class="line">    <span class="keyword">if</span> (pointer-&gt;leftchild() == <span class="literal">NULL</span>)</span><br><span class="line">        temppointer = pointer-&gt;rightchild();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当待删除结点左子树不为空，就在左子树中寻找最大结点替换待删除结点</span></span><br><span class="line">        temppointer = pointer-&gt;leftchild();</span><br><span class="line">        <span class="keyword">while</span> (temppointer-&gt;rightchild() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tempparent = temppointer;</span><br><span class="line">            temppointer = temppointer-&gt;rightchild();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除替换结点</span></span><br><span class="line">        <span class="keyword">if</span> (tempparent == <span class="literal">NULL</span>)</span><br><span class="line">            pointer-&gt;left = temppointer-&gt;leftchild();</span><br><span class="line">        <span class="keyword">else</span> tempparent-&gt;right = temppointer-&gt;leftchild();</span><br><span class="line">        temppointer-&gt;left = pointer-&gt;leftchild();    <span class="comment">// 继承pointer的左子树</span></span><br><span class="line">        temppointer-&gt;right = pointer-&gt;rightchild();  <span class="comment">// 继承pointer的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用替换结点去替代真正的删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = temppointer;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;leftchild() == pointer)</span><br><span class="line">        parent-&gt;left = temppointer;</span><br><span class="line">    <span class="keyword">else</span> parent-&gt;right = temppointer;</span><br><span class="line">    <span class="keyword">delete</span> pointer;                            <span class="comment">// 删除该结点</span></span><br><span class="line">    pointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="MinHeap-h"><a href="#MinHeap-h" class="headerlink" title="MinHeap.h"></a>MinHeap.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************  算法5.12 堆的类定义和筛选法  **********************/</span></span><br><span class="line"><span class="comment">/****************           MinHeap.h           **********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> &#123;</span>                            <span class="comment">//最小堆类定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heapArray;                            <span class="comment">//存放堆数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> CurrentSize;                        <span class="comment">//当前堆中元素数目</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                            <span class="comment">//堆所能容纳的最大元素数目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> pos_x, <span class="keyword">int</span> pos_y)</span></span>;        <span class="comment">//交换位置x和y的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">()</span></span>;                        <span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinHeap(<span class="keyword">const</span> <span class="keyword">int</span> n);                 <span class="comment">//构造函数,n表示初始化堆的最大元素数目</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MinHeap() &#123; <span class="keyword">delete</span>[]heapArray; &#125;;    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                            <span class="comment">// 如果堆空，则返回真</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//如果是叶结点，返回TRUE</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回左孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rightchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回右孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//返回父结点位置</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> pos, T &amp;node)</span></span>;            <span class="comment">//删除给定下标的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T &amp;newNode)</span></span>;            <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="function">T &amp;<span class="title">RemoveMin</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶删除最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftUp</span><span class="params">(<span class="keyword">int</span> position)</span></span>;             <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftDown</span><span class="params">(<span class="keyword">int</span> left)</span></span>;             <span class="comment">//筛选法函数，参数left表示开始处理的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">MinHeap&lt;T&gt;::MinHeap(<span class="keyword">const</span> <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    CurrentSize = <span class="number">0</span>;</span><br><span class="line">    MaxSize = n;                        <span class="comment">//初始化堆容量为n</span></span><br><span class="line">    heapArray = <span class="keyword">new</span> T[MaxSize];            <span class="comment">//创建堆空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处进行堆元素的赋值工作</span></span><br><span class="line">    heapArray[<span class="number">0</span>] = <span class="number">19</span>;                 <span class="comment">//亦可以用插入的办法构造</span></span><br><span class="line">    heapArray[<span class="number">1</span>] = <span class="number">8</span>;</span><br><span class="line">    heapArray[<span class="number">2</span>] = <span class="number">35</span>;</span><br><span class="line">    heapArray[<span class="number">3</span>] = <span class="number">65</span>;</span><br><span class="line">    heapArray[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line">    heapArray[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">    heapArray[<span class="number">6</span>] = <span class="number">7</span>;</span><br><span class="line">    heapArray[<span class="number">7</span>] = <span class="number">45</span>;</span><br><span class="line">    CurrentSize = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    BuildHeap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::isEmpty() &#123;            <span class="comment">// 如果堆空，则返回真&#123;</span></span><br><span class="line">    <span class="keyword">return</span> ((CurrentSize) ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::isLeaf(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &gt;= CurrentSize / <span class="number">2</span>) &amp;&amp; (pos &lt; CurrentSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::BuildHeap() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = CurrentSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)    <span class="comment">//反复调用筛选函数</span></span><br><span class="line">        SiftDown(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::leftchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">1</span>;                        <span class="comment">//返回左孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::rightchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">2</span>;                          <span class="comment">//返回右孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MinHeap&lt;T&gt;::parent(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos - <span class="number">1</span>) / <span class="number">2</span>;                           <span class="comment">//返回父结点位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::Insert(<span class="keyword">const</span> T &amp;newNode) &#123;  <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == MaxSize)                   <span class="comment">//堆空间已经满</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    heapArray[CurrentSize] = newNode;</span><br><span class="line">    SiftUp(CurrentSize);                       <span class="comment">//向上调整</span></span><br><span class="line">    CurrentSize++;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::SiftUp(<span class="keyword">int</span> position) &#123;    <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="keyword">int</span> temppos = position;</span><br><span class="line">    T temp = heapArray[temppos];</span><br><span class="line">    <span class="keyword">while</span> ((temppos &gt; <span class="number">0</span>) &amp;&amp; (heapArray[parent(temppos)] &gt; temp)) &#123;</span><br><span class="line">        heapArray[temppos] = heapArray[parent(temppos)];</span><br><span class="line">        temppos = parent(temppos);</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[temppos] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::swap(<span class="keyword">int</span> pos_x, <span class="keyword">int</span> pos_y)     <span class="comment">//交换位置x和y的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    T temp = heapArray[pos_x];</span><br><span class="line">    heapArray[pos_x] = heapArray[pos_y];</span><br><span class="line">    heapArray[pos_y] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T &amp;MinHeap&lt;T&gt;::RemoveMin() &#123;                <span class="comment">//从堆顶删除最小值</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Can&#x27;t Delete&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        swap(<span class="number">0</span>, --CurrentSize);                    <span class="comment">//交换堆顶和最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (CurrentSize &gt; <span class="number">1</span>)</span><br><span class="line">            SiftDown(<span class="number">0</span>);                        <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        <span class="keyword">return</span> heapArray[CurrentSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MinHeap&lt;T&gt;::Remove(<span class="keyword">int</span> pos, T &amp;node) &#123;    <span class="comment">// 删除给定下标的元素</span></span><br><span class="line">    <span class="keyword">if</span> ((pos &lt; <span class="number">0</span>) || (pos &gt;= CurrentSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    node = heapArray[pos];</span><br><span class="line">    heapArray[pos] = heapArray[--CurrentSize];        <span class="comment">// 用最后的元素值替代删除位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (heapArray[parent(pos)] &gt; heapArray[pos])</span><br><span class="line">        SiftUp(pos);                        <span class="comment">// 当前元素小于父结点，需要上升调整</span></span><br><span class="line">    <span class="keyword">else</span> SiftDown(pos);                        <span class="comment">// 当前元素大于父结点，向下筛</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MinHeap&lt;T&gt;::SiftDown(<span class="keyword">int</span> left) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = left;                                <span class="comment">// 标识父结点</span></span><br><span class="line">    <span class="keyword">int</span> j = leftchild(i);                            <span class="comment">// 标识关键值较小的子结点</span></span><br><span class="line">    T temp = heapArray[i];                    <span class="comment">// 保存父结点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; CurrentSize) &#123;                    <span class="comment">// 过筛</span></span><br><span class="line">        <span class="keyword">if</span> ((j &lt; CurrentSize - <span class="number">1</span>) &amp;&amp; (heapArray[j] &gt; heapArray[j + <span class="number">1</span>]))</span><br><span class="line">            j++;                                <span class="comment">// j指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; heapArray[j]) &#123;</span><br><span class="line">            heapArray[i] = heapArray[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = leftchild(j);                        <span class="comment">// 向下继续</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="HuffmanTree-h"><a href="#HuffmanTree-h" class="headerlink" title="HuffmanTree.h"></a>HuffmanTree.h</h3><p><a herf="#MinHeap-h">#include “MinHeap.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------- HuffmanTree.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T info;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *parent;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *left;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HuffmanTreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">leftchild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> left; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">rightchild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> right; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info &gt; HN.info; &#125;; <span class="comment">// 注意要重载运算符</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info &lt; HN.info; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(HuffmanTreeNode&lt;T&gt; &amp;HN) &#123; <span class="keyword">return</span> info == HN.info; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *root;                    <span class="comment">//Huffman树的树根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把ht1和ht2为根的Huffman子树合并成一棵以parent为根的二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MergeTree</span><span class="params">(HuffmanTreeNode&lt;T&gt; &amp;ht1, HuffmanTreeNode&lt;T&gt; &amp;ht2, HuffmanTreeNode&lt;T&gt; *parent)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(HuffmanTreeNode&lt;T&gt; *root)</span></span>;<span class="comment">//删除Huffman树或其子树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造Huffman树，weight是存储权值的数组，n是数组长度</span></span><br><span class="line">    HuffmanTree(T weight[], <span class="keyword">int</span> n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~HuffmanTree() &#123; DeleteTree(root); &#125;;    <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(HuffmanTreeNode&lt;T&gt; *root)</span></span>;          <span class="comment">//中序周游 </span></span><br><span class="line">    <span class="function">HuffmanTreeNode&lt;T&gt; *<span class="title">GetRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">HuffmanTree&lt;T&gt;::HuffmanTree(T weight[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">    MinHeap&lt;HuffmanTreeNode&lt;T&gt; &gt; heap(n);        <span class="comment">//定义最小值堆</span></span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *parent, firstchild, secondchild;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *NodeList = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;                    <span class="comment">//初始化</span></span><br><span class="line">        NodeList[i].info = weight[i];</span><br><span class="line">        NodeList[i].parent = NodeList[i].left = NodeList[i].right = <span class="literal">NULL</span>;</span><br><span class="line">        heap.Insert(NodeList[i]);                <span class="comment">//向堆中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;                    <span class="comment">//通过n-1次合并建立Huffman树</span></span><br><span class="line">        parent = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;;</span><br><span class="line">        firstchild = heap.RemoveMin();                <span class="comment">//选择权值最小的结点</span></span><br><span class="line">        secondchild = heap.RemoveMin();                <span class="comment">//选择权值次小的结点</span></span><br><span class="line">        MergeTree(firstchild, secondchild, parent);    <span class="comment">//合并权值最小的两棵树</span></span><br><span class="line">        heap.Insert(*parent);                    <span class="comment">//把parent插入到堆中去</span></span><br><span class="line">        root = parent;                            <span class="comment">//建立根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[]NodeList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::DeleteTree(HuffmanTreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        DeleteTree(root-&gt;left);</span><br><span class="line">        DeleteTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::InOrder(HuffmanTreeNode&lt;T&gt; *root) &#123; <span class="comment">//中序周游</span></span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        InOrder(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;info &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        InOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> HuffmanTree&lt;T&gt;::MergeTree(HuffmanTreeNode&lt;T&gt; &amp;ht1, HuffmanTreeNode&lt;T&gt; &amp;ht2, HuffmanTreeNode&lt;T&gt; *parent) &#123;</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *l = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;();</span><br><span class="line">    HuffmanTreeNode&lt;T&gt; *r = <span class="keyword">new</span> HuffmanTreeNode&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    *l = ht1; <span class="comment">// 不能写为l = &amp;ht1，注意地址引用，开辟的是新空间，或者应用拷贝构造函数，只是有些麻烦</span></span><br><span class="line">    *r = ht2;</span><br><span class="line"></span><br><span class="line">    parent-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    parent-&gt;left = l;</span><br><span class="line">    parent-&gt;right = r;</span><br><span class="line">    parent-&gt;info = ht1.info + ht2.info;</span><br><span class="line">    ht1.parent = ht2.parent = parent; <span class="comment">// 指向父节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="六-树"><a href="#六-树" class="headerlink" title="六    树"></a>六    树</h2><h3 id="TreeNode-h"><a href="#TreeNode-h" class="headerlink" title="TreeNode.h"></a>TreeNode.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>        <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value);             <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~TreeNode() &#123;&#125;;                 <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span>;                         <span class="comment">//如果结点是叶，返回true</span></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span></span>;                             <span class="comment">//返回结点的值 </span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span></span>;         <span class="comment">//返回第一个左孩子</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span></span>;         <span class="comment">//返回右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;)</span></span>;                     <span class="comment">//设置结点的值 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span></span>;     <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span></span>;   <span class="comment">//设置右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertFirst</span><span class="params">(TreeNode&lt;T&gt; *node)</span></span>;     <span class="comment">//以第一个左孩子身份插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertNext</span><span class="params">(TreeNode&lt;T&gt; *node)</span></span>;     <span class="comment">//以右兄弟的身份插入结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt;::TreeNode(<span class="keyword">const</span> T &amp;value) &#123;    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    m_Value = value;</span><br><span class="line">    pChild = <span class="literal">NULL</span>;</span><br><span class="line">    pSibling = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> TreeNode&lt;T&gt;::isLeaf() &#123;</span><br><span class="line">    <span class="comment">//如果结点是叶，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (pChild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T TreeNode&lt;T&gt;::Value() &#123;                    <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="keyword">return</span> m_Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt; *TreeNode&lt;T&gt;::LeftMostChild() &#123; <span class="comment">//返回第一个左孩子</span></span><br><span class="line">    <span class="keyword">return</span> pChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">TreeNode&lt;T&gt; *TreeNode&lt;T&gt;::RightSibling() &#123;    <span class="comment">//返回右兄弟</span></span><br><span class="line">    <span class="keyword">return</span> pSibling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setValue(T &amp;value) &#123;</span><br><span class="line">    <span class="comment">//设置结点的值</span></span><br><span class="line">    m_Value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setChild(TreeNode&lt;T&gt; *pointer) &#123;  <span class="comment">//设置左孩子</span></span><br><span class="line">    pChild = pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::setSibling(TreeNode&lt;T&gt; *pointer) &#123;  <span class="comment">//设置右兄弟</span></span><br><span class="line">    pSibling = pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::InsertFirst(TreeNode&lt;T&gt; *node) &#123;</span><br><span class="line">    <span class="comment">//以第一个孩子的身份插入结点</span></span><br><span class="line">    <span class="keyword">if</span> (pChild)</span><br><span class="line">        node-&gt;pSibling = pChild;</span><br><span class="line">    pChild = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> TreeNode&lt;T&gt;::InsertNext(TreeNode&lt;T&gt; *node) &#123; <span class="comment">//以右兄弟的身份插入结点</span></span><br><span class="line">    <span class="keyword">if</span> (pSibling)</span><br><span class="line">        node-&gt;pSibling = pSibling;</span><br><span class="line">    pSibling = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tree-h"><a href="#Tree-h" class="headerlink" title="Tree.h"></a>Tree.h</h3><p><a herf="#TreeNode-h">#include “TreeNode.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;queue&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TreeNode.h</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">using namespace std;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">class Tree &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">private:</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *root;                         //树根结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void DestroyNodes(TreeNode &lt;T&gt; *root);       //删除以root为根的子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">public:</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    Tree();                                        //构造函数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    virtual ~Tree();                            //析构函数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *getRoot();                        //返回树中的根结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void CreateRoot(const T &amp;rootValue);     //创建树中的根结点，使根结点元素的值为rootValue</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    bool isEmpty();                             //判断是否为空树，如果是则返回true</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *Parent(TreeNode &lt;T&gt; *current);        //返回current结点的父结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *PrevSibling(TreeNode &lt;T&gt; *current); //返回current结点的前一个邻居结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void DeleteSubTree(TreeNode &lt;T&gt; *subroot);        //删除以subroot为根的子树的所有结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void RootFirstTraverse(TreeNode &lt;T&gt; *root);        //先根深度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void RootLastTraverse(TreeNode &lt;T&gt; *root);        //后根深度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void WidthTraverse(TreeNode &lt;T&gt; *root);            //广度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    void Visit(T Value) &#123;                            //访问</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        cout &lt;&lt; Value;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">Tree&lt;T&gt;::Tree() &#123;                            //构造函数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    root = NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">Tree&lt;T&gt;::~Tree() &#123;                            //析构函数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (root)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        DeleteSubTree(root);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">TreeNode &lt;T&gt; *Tree&lt;T&gt;::getRoot() &#123;            //返回树中的根结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return root;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::CreateRoot(const T &amp;rootValue) &#123;//创建树中的根结点，使根结点元素的值为rootValue</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (!root)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        root = new TreeNode&lt;T&gt;(rootValue);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">bool Tree&lt;T&gt;::isEmpty() &#123;         //判断是否为空树，如果是则返回true</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (root)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        return false;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return true;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">TreeNode &lt;T&gt; *Tree&lt;T&gt;::PrevSibling(TreeNode &lt;T&gt; *current) &#123;//返回current结点的前一个邻居结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    using std::queue;                                //使用STL队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    queue&lt;TreeNode &lt; T&gt; * &gt; aQueue;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *pointer = root;                        //标识当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *prev = NULL;                        //标识当前结点的前一个兄弟结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    //当前结点为空，树为空或所求结点为根结点时，返回NULL	</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if ((current == NULL) || (pointer == NULL) || (current == root))</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        return NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (pointer) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        if (pointer == current)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            return prev;                            //找到当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        prev = pointer;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;pSibling;                    //沿当前结点右兄弟结点链寻找</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (!aQueue.empty()) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        prev = NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = aQueue.front();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        aQueue.pop();                                //出队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;LeftMostChild();            //下降到左子结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (pointer) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            if (pointer == current)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                return prev;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            prev = pointer;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;pSibling;                //沿当前结点右兄弟结点链寻找</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">TreeNode &lt;T&gt; *Tree&lt;T&gt;::Parent(TreeNode &lt;T&gt; *current) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    using std::queue;                                // 使用STL队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    queue&lt;TreeNode &lt; T&gt; * &gt; aQueue;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *pointer = root;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *upperlevelpointer = NULL;            // 用于记录parent结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (current != NULL &amp;&amp; pointer != current) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (pointer) &#123;                            // 森林中所有根结点进队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            if (current == pointer)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                return NULL;                    // 根的父结点指针为空，返回</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (!aQueue.empty()) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = aQueue.front();                    // 取队列首结点指针</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            aQueue.pop();                            // 出队列	</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            upperlevelpointer = pointer;                    // 指向上一层的结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;LeftMostChild();        // 指向当前结点的最左孩子</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            while (pointer) &#123;                        // 当前结点的子结点进队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                if (current == pointer)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                    return upperlevelpointer;        // 返回父结点指针</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                else &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                    aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                    pointer = pointer-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;//end if</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    return NULL;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::DestroyNodes(TreeNode &lt;T&gt; *root) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    //删除以root为根的子树的所有结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (root) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        DestroyNodes(root-&gt;LeftMostChild());    //递归删除第一子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        DestroyNodes(root-&gt;RightSibling());        //递归删除其他子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        delete root;                            //删除根结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::DeleteSubTree(TreeNode &lt;T&gt; *subroot) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    // 删除以subroot为根的子树的所有结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (subroot == NULL) return;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *pointer = Parent(subroot);    // 找subroot的父结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if (pointer == NULL)                            // subroot就是森林第一个树根</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        root = subroot-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    else if (pointer-&gt;LeftMostChild() == subroot)        // subroot为最左子结点的情况</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer-&gt;setChild(subroot-&gt;RightSibling());</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    else &#123;                                    // subroot有左兄弟</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;LeftMostChild();        // 下降到最左兄弟</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (pointer-&gt;RightSibling() != subroot)    // 顺右链找到直接左兄弟</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer-&gt;setSibling(subroot-&gt;RightSibling());</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    subroot-&gt;setSibling(NULL);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    DestroyNodes(subroot);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">//树的深度、广度周游算法</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::RootFirstTraverse(TreeNode &lt;T&gt; *root) &#123;    //先根深度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (NULL != root) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        Visit(root-&gt;Value());                      //访问当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        RootFirstTraverse(root-&gt;LeftMostChild());   //周游头一棵树树根的子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        root = root-&gt;RightSibling();                  //周游其他的树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::RootLastTraverse(TreeNode &lt;T&gt; *root) &#123;    //后根深度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (NULL != root) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        RootLastTraverse(root-&gt;LeftMostChild());  //周游头一棵树树根的子树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        Visit(root-&gt;Value());                    //访问当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        root = root-&gt;RightSibling();                //周游其他的树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">template&lt;class T&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void Tree&lt;T&gt;::WidthTraverse(TreeNode &lt;T&gt; *root) &#123;  // 广度优先周游树</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    using std::queue;                             // 使用STL队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    queue&lt;TreeNode &lt; T&gt; * &gt; aQueue;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    TreeNode &lt;T&gt; *pointer = root;                // 根作为当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (pointer) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        aQueue.push(pointer);                  // 当前结点进入队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;RightSibling();         // 指向当前结点的右兄弟</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    while (!aQueue.empty()) &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = aQueue.front();                // 取队列首结点指针</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        aQueue.pop();                         // 出队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        Visit(pointer-&gt;Value());                 // 访问当前结点</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        pointer = pointer-&gt;LeftMostChild();       // 指向当前结点的最左孩子</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while (pointer) &#123;                       // 当前结点的子结点进队列</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            aQueue.push(pointer);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            pointer = pointer-&gt;RightSibling();</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;//end while</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br></pre></td></tr></table></figure>
<h3 id="ParTreeNode-h"><a href="#ParTreeNode-h" class="headerlink" title="ParTreeNode.h"></a>ParTreeNode.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类ParTreeNode描述了树的结点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParTreeNode</span> &#123;</span>                        <span class="comment">//树结点定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;                    <span class="comment">//结点的值</span></span><br><span class="line">    ParTreeNode&lt;T&gt; *parent;                    <span class="comment">//父结点指针</span></span><br><span class="line">    <span class="keyword">int</span> nCount;                            <span class="comment">//以此结点为根的子树的总结点个数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ParTreeNode();                            <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ParTreeNode() &#123;&#125;;                <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span></span>;                            <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span></span>;            <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function">ParTreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">()</span></span>;            <span class="comment">//返回父结点指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(ParTreeNode&lt;T&gt; *par)</span></span>;    <span class="comment">//设置父结点指针</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;                        <span class="comment">//返回结点数目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> count)</span></span>;        <span class="comment">//设置结点数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ParTreeNode抽象数据类型成员函数的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode&lt;T&gt;::ParTreeNode() &#123;            <span class="comment">//构造函数</span></span><br><span class="line">    parent = <span class="literal">NULL</span>;</span><br><span class="line">    nCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T ParTreeNode&lt;T&gt;::getValue() &#123;                <span class="comment">//返回结点的值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setValue(<span class="keyword">const</span> T &amp;val) &#123;            <span class="comment">//设置结点的值</span></span><br><span class="line">    value = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode&lt;T&gt; *ParTreeNode&lt;T&gt;::getParent() &#123;            <span class="comment">//返回父结点指针</span></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setParent(ParTreeNode&lt;T&gt; *par) &#123;   <span class="comment">//设置父结点指针</span></span><br><span class="line">    parent = par;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> ParTreeNode&lt;T&gt;::getCount() &#123;                        <span class="comment">//返回结点数目</span></span><br><span class="line">    <span class="keyword">return</span> nCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTreeNode&lt;T&gt;::setCount(<span class="keyword">const</span> <span class="keyword">int</span> count) &#123;        <span class="comment">//设置结点数目</span></span><br><span class="line">    nCount = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ParTree-h"><a href="#ParTree-h" class="headerlink" title="ParTree.h"></a>ParTree.h</h3><p><a herf="#ParTreeNode-h">#include “ParTreeNode.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类ParTree描述了树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParTree</span> &#123;</span>                                <span class="comment">//树定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ParTreeNode &lt;T&gt; *<span class="built_in">array</span>;                        <span class="comment">//存储树结点的数组</span></span><br><span class="line">    <span class="keyword">int</span> Size;                                    <span class="comment">//数组大小</span></span><br><span class="line">    ParTree(<span class="keyword">const</span> <span class="keyword">int</span> size);                    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ParTree();                            <span class="comment">//析构函数</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *Find(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span>;<span class="comment">//查找node结点的根结点</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *FindPC(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span>; <span class="comment">// 带压缩</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                    <span class="comment">//把下标为i，j的结点合并成一棵子树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnionPC</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                 <span class="comment">//带压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Different</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;                <span class="comment">//判定下标为i，j的结点是否在一棵树中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的成员函数的实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTree&lt;T&gt;::ParTree(<span class="keyword">const</span> <span class="keyword">int</span> size) &#123;            <span class="comment">//构造函数</span></span><br><span class="line">    Size = size;</span><br><span class="line">    <span class="built_in">array</span> = <span class="keyword">new</span> ParTreeNode&lt;T&gt;[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTree&lt;T&gt;::~ParTree() &#123;                        <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：找到目标结点的根结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode &lt;T&gt; *ParTree&lt;T&gt;::Find(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span> &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointer = node;</span><br><span class="line">    <span class="keyword">while</span> (pointer-&gt;getParent() != <span class="literal">NULL</span>)</span><br><span class="line">        pointer = pointer-&gt;getParent();</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：带路径压缩的Find算法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ParTreeNode &lt;T&gt; *ParTree&lt;T&gt;::FindPC(ParTreeNode &lt;T&gt; *node) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;getParent() == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    node-&gt;setParent(FindPC(node-&gt;getParent()));</span><br><span class="line">    <span class="keyword">return</span> node-&gt;getParent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：判定下标为i，j的结点是否在一棵树中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> ParTree&lt;T&gt;::Different(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = Find(&amp;<span class="built_in">array</span>[i]);        <span class="comment">//找到结点i的根</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = Find(&amp;<span class="built_in">array</span>[j]);        <span class="comment">//找到结点j的根</span></span><br><span class="line">    <span class="keyword">return</span> pointeri != pointerj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把下标为i，j的结点合并成一棵子树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTree&lt;T&gt;::Union(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = Find(&amp;<span class="built_in">array</span>[i]);        <span class="comment">//找到结点i的根</span></span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = Find(&amp;<span class="built_in">array</span>[j]);        <span class="comment">//找到结点j的根</span></span><br><span class="line">    <span class="keyword">if</span> (pointeri != pointerj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointeri-&gt;getCount() &gt;= pointerj-&gt;getCount()) &#123;</span><br><span class="line">            pointerj-&gt;setParent(pointeri);</span><br><span class="line">            pointeri-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pointeri-&gt;setParent(pointerj);</span><br><span class="line">            pointerj-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：归并两个集合， 带压缩</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> ParTree&lt;T&gt;::UnionPC(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointeri = FindPC(&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    ParTreeNode &lt;T&gt; *pointerj = FindPC(&amp;<span class="built_in">array</span>[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointeri != pointerj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointeri-&gt;getCount() &gt;= pointerj-&gt;getCount()) &#123;</span><br><span class="line">            pointerj-&gt;setParent(pointeri);</span><br><span class="line">            pointeri-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pointeri-&gt;setParent(pointerj);</span><br><span class="line">            pointerj-&gt;setCount(pointeri-&gt;getCount() + pointerj-&gt;getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DualTagTree-cpp"><a href="#DualTagTree-cpp" class="headerlink" title="DualTagTree.cpp"></a>DualTagTree.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;TreeNode.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10                             <span class="comment">//结点数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>           <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带“双标记”的先根次序 结点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualTagTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T info;                   <span class="comment">//树结点信息</span></span><br><span class="line">    <span class="keyword">int</span> ltag;                   <span class="comment">//左标记</span></span><br><span class="line">    <span class="keyword">int</span> rtag;                 <span class="comment">//右标记</span></span><br><span class="line"></span><br><span class="line">    DualTagTreeNode() &#123;&#125;;               <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~DualTagTreeNode() &#123;&#125;;      <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结点类的ADT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line">        m_Value = value;</span><br><span class="line">        pChild = <span class="literal">NULL</span>;</span><br><span class="line">        pSibling = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Value; &#125;;                     <span class="comment">// 获得结点的信息</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pChild; &#125;;   <span class="comment">// 返回第一个左子树</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pSibling; &#125;;  <span class="comment">// 返回第一个右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;value)</span> </span>&#123; m_Value = value; &#125;;      <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pChild = pointer; &#125;;   <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pSibling = pointer; &#125;;  <span class="comment">//设置右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树类ADT，只写出了相关的变量及函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode&lt;T&gt; *root;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">(TreeNode&lt;T&gt; *root, TreeNode&lt;T&gt; *current)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree() &#123; root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    Tree(DualTagTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count); <span class="comment">//带双标记先根次序构造算法</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;          <span class="comment">//返回树中的根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; Value; &#125;;           <span class="comment">//访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RootFirstTraverse</span><span class="params">(TreeNode&lt;T&gt; *root)</span></span>;      <span class="comment">//先根次序周游，作为测试使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：带双标记先根次序构造算法 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Tree&lt;T&gt;::Tree(DualTagTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count) &#123;</span><br><span class="line"><span class="comment">//利用带双标记位的先根次序表示的树构造左孩子右兄弟方式表示的树</span></span><br><span class="line">    <span class="comment">//使用STL中的stack</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span> &lt; TreeNode&lt;T&gt; * &gt; aStack;</span><br><span class="line">    <span class="comment">//准备建立根结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">    root = pointer;</span><br><span class="line">    <span class="comment">//处理一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pointer-&gt;setValue(nodeArray[i].info);</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].rtag == <span class="number">0</span>)</span><br><span class="line">            aStack.push(pointer);                        <span class="comment">//将结点压栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pointer-&gt;setSibling(<span class="literal">NULL</span>);                    <span class="comment">//右兄弟设为空</span></span><br><span class="line">        TreeNode&lt;T&gt; *temppointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].ltag == <span class="number">0</span>)</span><br><span class="line">            pointer-&gt;setChild(temppointer);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pointer-&gt;setChild(<span class="literal">NULL</span>);                    <span class="comment">//左孩子设为空</span></span><br><span class="line">            pointer = aStack.top();</span><br><span class="line">            aStack.pop();</span><br><span class="line">            pointer-&gt;setSibling(temppointer);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer = temppointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理最后一个结点</span></span><br><span class="line">    pointer-&gt;setValue(nodeArray[count - <span class="number">1</span>].info);</span><br><span class="line">    pointer-&gt;setChild(<span class="literal">NULL</span>);</span><br><span class="line">    pointer-&gt;setSibling(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：先根深度遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::RootFirstTraverse(TreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Visit(root-&gt;Value());</span><br><span class="line">        RootFirstTraverse(root-&gt;LeftMostChild());</span><br><span class="line">        root = root-&gt;RightSibling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构.图6.5(a)所示的森林</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;      A              G      \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   /  |  \\         /   \\   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  B   C    D      H     I   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;     / \\          |         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    E   F         J         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  0 , there is    a right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  1 , there isn&#x27;t a right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  0 , there is    a left child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  1 , there isn&#x27;t a left child&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构的带双标记先根次序表示 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayNode</span><span class="params">(<span class="keyword">char</span> *Info, <span class="keyword">int</span> *nRtag, <span class="keyword">int</span> *nLtag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;info   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Info[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nRtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nRtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nLtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：周游树，在这里只列举一种（先根次序）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Tree&lt;<span class="keyword">char</span>&gt; *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;FirstRoot traverse:  &quot;</span>;</span><br><span class="line">    tree-&gt;RootFirstTraverse(tree-&gt;getRoot()); <span class="comment">// 先根深度优先周游</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示森林结构</span></span><br><span class="line">    DisplayTree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带双标记先根次序构造算法，图6.5(a)所示的森林的带双标记位的先根次序表示为例</span></span><br><span class="line">    <span class="keyword">char</span> strInfo[N] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;I&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nRtag[N] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nLtag[N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dualtag_FirstRoot create tree.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//打印带双标记位的先根次序表示</span></span><br><span class="line">    DisplayNode(strInfo, nRtag, nLtag);</span><br><span class="line"></span><br><span class="line">    DualTagTreeNode&lt;<span class="keyword">char</span>&gt; *nodeArray = <span class="keyword">new</span> DualTagTreeNode&lt;<span class="keyword">char</span>&gt;[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;                <span class="comment">//设置带双标记位的先根次序结点类</span></span><br><span class="line">        nodeArray[i].info = strInfo[i];</span><br><span class="line">        nodeArray[i].rtag = nRtag[i];</span><br><span class="line">        nodeArray[i].ltag = nLtag[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Tree&lt;<span class="keyword">char</span>&gt; <span class="title">aTree</span><span class="params">(nodeArray, N)</span></span>; <span class="comment">// 建树</span></span><br><span class="line">    Traverse(&amp;aTree);               <span class="comment">// 周游树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DualTagWidthTree-cpp"><a href="#DualTagWidthTree-cpp" class="headerlink" title="DualTagWidthTree.cpp"></a>DualTagWidthTree.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10                             <span class="comment">// 结点数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>;</span>           <span class="comment">//声明树类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带“双标记”的次序结点类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualTagWidthTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T info;                   <span class="comment">//树结点信息</span></span><br><span class="line">    <span class="keyword">int</span> ltag;                  <span class="comment">//左标记</span></span><br><span class="line">    <span class="keyword">int</span> rtag;                 <span class="comment">//右标记</span></span><br><span class="line"></span><br><span class="line">    DualTagWidthTreeNode() &#123;&#125;;               <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~DualTagWidthTreeNode() &#123;&#125;;      <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结点类的ADT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_Value;                                <span class="comment">//树结点的值</span></span><br><span class="line">    TreeNode&lt;T&gt; *pChild;                    <span class="comment">//左子结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pSibling;                <span class="comment">//右兄弟结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">const</span> T &amp;value) &#123;</span><br><span class="line">        m_Value = value;</span><br><span class="line">        pChild = <span class="literal">NULL</span>;</span><br><span class="line">        pSibling = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">Value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Value; &#125;;                     <span class="comment">// 获得结点的信息</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">LeftMostChild</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pChild; &#125;;   <span class="comment">// 返回第一个左子树</span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">RightSibling</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> pSibling; &#125;;  <span class="comment">// 返回第一个右兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T &amp;value)</span> </span>&#123; m_Value = value; &#125;;      <span class="comment">//设置结点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pChild = pointer; &#125;;   <span class="comment">//设置左孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSibling</span><span class="params">(TreeNode&lt;T&gt; *pointer)</span> </span>&#123; pSibling = pointer; &#125;;  <span class="comment">//设置右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树类ADT，只写出了相关的变量及函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode&lt;T&gt; *root;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getParent</span><span class="params">(TreeNode&lt;T&gt; *root, TreeNode&lt;T&gt; *current)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tree() &#123; root = <span class="literal">NULL</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    Tree(DualTagWidthTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count); <span class="comment">//带双标记先根次序构造算法 </span></span><br><span class="line">    <span class="function">TreeNode&lt;T&gt; *<span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;;          <span class="comment">//返回树中的根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(T Value)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; Value; &#125;;           <span class="comment">//访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RootFirstTraverse</span><span class="params">(TreeNode&lt;T&gt; *root)</span></span>;      <span class="comment">//先根次序周游，作为测试使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：带双标记层次次序构造算法 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Tree&lt;T&gt;::Tree(DualTagWidthTreeNode&lt;T&gt; *nodeArray, <span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="comment">//由带双标记位的层次次序表示构造左孩子右兄弟方式表示的树</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;                                 <span class="comment">//使用STL队列</span></span><br><span class="line">    <span class="built_in">queue</span> &lt; TreeNode&lt;T&gt; * &gt; aQueue;</span><br><span class="line">    <span class="comment">//准备建立根结点</span></span><br><span class="line">    TreeNode&lt;T&gt; *pointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">    root = pointer;</span><br><span class="line">    <span class="comment">//处理一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pointer-&gt;setValue(nodeArray[i].info);</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].ltag == <span class="number">0</span>)</span><br><span class="line">            aQueue.push(pointer);                       <span class="comment">//将结点入队</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pointer-&gt;setChild(<span class="literal">NULL</span>);                   <span class="comment">//左孩子设为空</span></span><br><span class="line">        TreeNode&lt;T&gt; *temppointer = <span class="keyword">new</span> TreeNode&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].rtag == <span class="number">0</span>)</span><br><span class="line">            pointer-&gt;setSibling(temppointer);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pointer-&gt;setSibling(<span class="literal">NULL</span>);                    <span class="comment">//右兄弟设为空</span></span><br><span class="line">            pointer = aQueue.front();                     <span class="comment">//取队列首结点指针</span></span><br><span class="line">            aQueue.pop();                            <span class="comment">//队首元素出队列</span></span><br><span class="line">            pointer-&gt;setChild(temppointer);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer = temppointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理最后一个结点</span></span><br><span class="line">    pointer-&gt;setValue(nodeArray[count - <span class="number">1</span>].info);</span><br><span class="line">    pointer-&gt;setChild(<span class="literal">NULL</span>);</span><br><span class="line">    pointer-&gt;setSibling(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：先根深度遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Tree&lt;T&gt;::RootFirstTraverse(TreeNode&lt;T&gt; *root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Visit(root-&gt;Value());</span><br><span class="line">        RootFirstTraverse(root-&gt;LeftMostChild());</span><br><span class="line">        root = root-&gt;RightSibling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：周游树，在这里只列举一种（先根次序）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(Tree&lt;<span class="keyword">char</span>&gt; *tree)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;FirstRoot traverse:  &quot;</span>;</span><br><span class="line">    tree-&gt;RootFirstTraverse(tree-&gt;getRoot()); <span class="comment">// 先根深度优先周游</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构.图6.5(a)所示的森林</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;      A              G      \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   /  |  \\         /   \\   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  B   C    D      H     I   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;     / \\          |         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;    E   F         J         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  0  have right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag =  1  havn&#x27;t right sibling&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  0  have left child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag =  1  havn&#x27;t left child&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示森林结构的带双标记层次次序表示 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayNode</span><span class="params">(<span class="keyword">char</span> *Info, <span class="keyword">int</span> *nRtag, <span class="keyword">int</span> *nLtag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Info != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;info   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Info[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nRtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rtag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nRtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nLtag != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ltag   &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; nLtag[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示森林结构</span></span><br><span class="line">    DisplayTree();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带双标记层次次序构造算法，图6.5(a)所示的森林的带双标记位的层次次序表示为例</span></span><br><span class="line">    <span class="keyword">char</span> strInfo[N] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;J&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nRtag[N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> nLtag[N] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dualtag_Width create tree.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//打印带双标记位的层次次序表示 </span></span><br><span class="line">    DisplayNode(strInfo, nRtag, nLtag);</span><br><span class="line"></span><br><span class="line">    DualTagWidthTreeNode&lt;<span class="keyword">char</span>&gt; *nodeArray = <span class="keyword">new</span> DualTagWidthTreeNode&lt;<span class="keyword">char</span>&gt;[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;                <span class="comment">//设置带双标记位的层次次序结点类 </span></span><br><span class="line">        nodeArray[i].info = strInfo[i];</span><br><span class="line">        nodeArray[i].rtag = nRtag[i];</span><br><span class="line">        nodeArray[i].ltag = nLtag[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Tree&lt;<span class="keyword">char</span>&gt; <span class="title">aTree</span><span class="params">(nodeArray, N)</span></span>; <span class="comment">// 建树</span></span><br><span class="line">    Traverse(&amp;aTree);               <span class="comment">// 周游树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="七-图"><a href="#七-图" class="headerlink" title="七    图"></a>七    图</h2><h3 id="Graph-h"><a href="#Graph-h" class="headerlink" title="Graph.h"></a>Graph.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//***********   Graph.h   ************//</span></span><br><span class="line"><span class="comment">//图的基类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Edge类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> weight;    <span class="comment">//weight是边的权</span></span><br><span class="line">    <span class="keyword">int</span> from;      <span class="comment">//from是边的始点</span></span><br><span class="line">    <span class="keyword">int</span> to;        <span class="comment">//to是边的终点</span></span><br><span class="line">    Edge() &#123;        <span class="comment">// 构造函数</span></span><br><span class="line">        from = <span class="number">-1</span>;</span><br><span class="line">        to = <span class="number">-1</span>;</span><br><span class="line">        weight = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Edge(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">int</span> w) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">        from = f;</span><br><span class="line">        to = t;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &lt; arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight == arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &gt; arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &lt;= arg.weight); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Edge &amp;arg) &#123; <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;weight &gt;= arg.weight); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> numVertex;             <span class="comment">//图的顶点的个数</span></span><br><span class="line">    <span class="keyword">int</span> numEdge;                <span class="comment">//图的边的数目</span></span><br><span class="line">    <span class="keyword">int</span> *Mark;                    <span class="comment">/*Mark指针指向保存有图的顶点的标志位的数组,标志位用来标记某顶点是否被访问过*/</span></span><br><span class="line">    <span class="keyword">int</span> *Indegree;                <span class="comment">//Indegree指针指向保存有图的顶点的入度的数组</span></span><br><span class="line">    Graph(<span class="keyword">int</span> numVert) &#123;        <span class="comment">//构造函数</span></span><br><span class="line">        numVertex = numVert;      <span class="comment">//确定图的顶点的个数</span></span><br><span class="line">        numEdge = <span class="number">0</span>;                <span class="comment">//确定图的边的数目</span></span><br><span class="line">        Indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex]; <span class="comment">/*为保存图的顶点的入度申请数组,Indegree为数组指针*/</span></span><br><span class="line">        Mark = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex];     <span class="comment">/*为图的顶点的标志位申请数组,Mark为数组指针*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;    <span class="comment">/*确定图的顶点的标志位和入度,即所有顶点的标志位初始化为未被访问过,入度初始化为0*/</span></span><br><span class="line">            Mark[i] = UNVISITED;</span><br><span class="line">            Indegree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graph() &#123;                <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] Mark;</span><br><span class="line">        <span class="keyword">delete</span>[] Indegree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;    <span class="comment">// 返回与顶点oneVertex相关联的第一条边</span></span><br><span class="line">        Edge myEdge;</span><br><span class="line">        myEdge.from = oneVertex;</span><br><span class="line">        myEdge.to = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> myEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123;      <span class="comment">// 返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        <span class="keyword">return</span> preEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">VerticesNum</span><span class="params">()</span> </span>&#123;        <span class="comment">//返回图的顶点个数</span></span><br><span class="line">        <span class="keyword">return</span> numVertex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">EdgesNum</span><span class="params">()</span> </span>&#123;            <span class="comment">//返回图的边数</span></span><br><span class="line">        <span class="keyword">return</span> numEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FromVertex</span><span class="params">(Edge oneEdge)</span> </span>&#123;  <span class="comment">// 返回oneEdge的始点</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ToVertex</span><span class="params">(Edge oneEdge)</span> </span>&#123;    <span class="comment">// 返回oneEdge的终点</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Weight</span><span class="params">(Edge oneEdge)</span> </span>&#123;        <span class="comment">// 返回oneEdge的权值</span></span><br><span class="line">        <span class="keyword">return</span> oneEdge.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEdge</span><span class="params">(Edge oneEdge)</span> </span>&#123;    <span class="comment">//如果oneEdge是边则返回TRUE，否则返回FALSE</span></span><br><span class="line">        <span class="keyword">if</span> (oneEdge.weight &gt; <span class="number">0</span> &amp;&amp; oneEdge.weight &lt; INFINITE &amp;&amp; oneEdge.to &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Graphl-h"><a href="#Graphl-h" class="headerlink" title="Graphl.h"></a>Graphl.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*************** Link.h **************//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listUnit</span> &#123;</span>    <span class="comment">//邻接表表目中数据部分的结构定义</span></span><br><span class="line">    <span class="keyword">int</span> vertex;      <span class="comment">//边的终点</span></span><br><span class="line">    <span class="keyword">int</span> weight;      <span class="comment">//边的权</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span>   <span class="comment">//链表元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Elem element;      <span class="comment">//表目的数据</span></span><br><span class="line">    Link *next;        <span class="comment">//表目指针，指向下一个表目</span></span><br><span class="line">    Link(<span class="keyword">const</span> Elem &amp;elemval, Link *nextval = <span class="literal">NULL</span>) &#123; <span class="comment">//构造函数</span></span><br><span class="line">        element = elemval;</span><br><span class="line">        next = nextval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Link(Link *nextval = <span class="literal">NULL</span>) &#123;                    <span class="comment">//构造函数</span></span><br><span class="line">        next = nextval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span>   <span class="comment">//链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Link&lt;Elem&gt; *head;  <span class="comment">//head指针并不储存任何实际元素，其存在只是为了操作方便</span></span><br><span class="line">    LList() &#123;          <span class="comment">//构造函数</span></span><br><span class="line">        head = <span class="keyword">new</span> Link&lt;Elem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeall</span><span class="params">()</span> </span>&#123;  <span class="comment">//释放边表所有表目占据的空间</span></span><br><span class="line">        Link&lt;Elem&gt; *fence;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123; <span class="comment">//逐步释放每个表目占据的空间</span></span><br><span class="line">            fence = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> fence;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~LList() &#123;                <span class="comment">//析构函数</span></span><br><span class="line">        removeall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphl</span> :</span> <span class="keyword">public</span> Graph &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LList&lt;listUnit&gt; *graList;  <span class="comment">//graList是保存所有边表的数组	</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graphl(<span class="keyword">int</span> numVert) : Graph(numVert) &#123; <span class="comment">//构造函数</span></span><br><span class="line">        graList = <span class="keyword">new</span> LList&lt;listUnit&gt;[numVertex]; <span class="comment">/*为graList数组申请空间，图有</span></span><br><span class="line"><span class="comment">										  numVertex个顶点，则有numVertex个边表*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graphl() &#123;                        <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] graList;                   <span class="comment">//释放空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;   <span class="comment">//返回顶点oneVertex的第一条边</span></span><br><span class="line">        Edge myEdge;                   <span class="comment">//边myEdge将作为函数的返回值</span></span><br><span class="line">        myEdge.from = oneVertex;       <span class="comment">//将顶点oneVertex作为边myEdge的始点</span></span><br><span class="line">        <span class="comment">/*graList[oneVertex].head保存的是顶点oneVertex的边表，</span></span><br><span class="line"><span class="comment">        temp-&gt;next指向顶点oneVertex的第一条边(如果temp-&gt;next</span></span><br><span class="line"><span class="comment">        不为null)*/</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[oneVertex].head;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;        <span class="comment">//如果顶点oneVertex的第一条边确实存在</span></span><br><span class="line">            myEdge.to = temp-&gt;next-&gt;element.vertex;</span><br><span class="line">            myEdge.weight = temp-&gt;next-&gt;element.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果找到了顶点oneVertex的第一条边,则返回的myEdge确实是一条边;如果没有</span></span><br><span class="line"><span class="comment">        找到顶点oneVertex的第一条边,则myEdge的成员变量to为-1,根据IsEdge函数判</span></span><br><span class="line"><span class="comment">        断可知myEdge不是一条边*/</span></span><br><span class="line">        <span class="keyword">return</span> myEdge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123;  <span class="comment">// 返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        Edge myEdge;                    <span class="comment">// myEdge的初始成员变量to为-1</span></span><br><span class="line">        myEdge.from = preEdge.from;        <span class="comment">// 将边的始点置为与上一条边的相同</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[preEdge.from].head;        <span class="comment">// temp指向边表头一个</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt;= preEdge.to)</span><br><span class="line">            temp = temp-&gt;next;            <span class="comment">// 确定边preEdge的位置</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;        <span class="comment">// 边preEdge的下一条边存在</span></span><br><span class="line">            myEdge.to = temp-&gt;next-&gt;element.vertex;</span><br><span class="line">            myEdge.weight = temp-&gt;next-&gt;element.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge;                    <span class="comment">// 如果没有找到第一条边，myEdge.to=-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;  <span class="comment">//为图设定一条边</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[from].head;  <span class="comment">/*graList[from].head保存的是顶点from的</span></span><br><span class="line"><span class="comment">													边表，temp-&gt;next指向顶点from的第一条边</span></span><br><span class="line"><span class="comment">													(如果temp-&gt;next不为null)*/</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt; to)</span><br><span class="line">            temp = temp-&gt;next;   <span class="comment">/*确定边(from,to)或&lt;from,to&gt;在边表中的位置,如果不存在,</span></span><br><span class="line"><span class="comment">									则边(from,to)或&lt;from,to&gt;为新加的一条边*/</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;  <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中不存在且在边表中其后</span></span><br><span class="line"><span class="comment">									已无其它边,则在边表中加入这条边*/</span></span><br><span class="line">            temp-&gt;next = <span class="keyword">new</span> Link&lt;listUnit&gt;;</span><br><span class="line">            temp-&gt;next-&gt;element.vertex = to;</span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex == to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中已存在,</span></span><br><span class="line"><span class="comment">												故只需要改变边的权值*/</span></span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex &gt; to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中不存在,但在边表中</span></span><br><span class="line"><span class="comment">												其后存在其它边,则在边表中插入这条边*/</span></span><br><span class="line">            Link&lt;listUnit&gt; *other = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = <span class="keyword">new</span> Link&lt;listUnit&gt;;</span><br><span class="line">            temp-&gt;next-&gt;element.vertex = to;</span><br><span class="line">            temp-&gt;next-&gt;element.weight = weight;</span><br><span class="line">            temp-&gt;next-&gt;next = other;</span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;          <span class="comment">//删掉图的一条边</span></span><br><span class="line">        Link&lt;listUnit&gt; *temp = graList[from].head;  <span class="comment">/*graList[from].head保存的是顶点from的边表，temp-&gt;next指向顶点from的第一条边(如果temp-&gt;next不为null)*/</span></span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;element.vertex &lt; to)</span><br><span class="line">            temp = temp-&gt;next;    <span class="comment">/*确定边(from,to)或&lt;from,to&gt;在边表中的位置(如果该边存在)*/</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;        <span class="comment">//边(from,to)或&lt;from,to&gt;在边表中不存在,则不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex &gt; to)</span><br><span class="line">            <span class="keyword">return</span>;        <span class="comment">//边(from,to)或&lt;from,to&gt;在边表中不存在,则不需要做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next-&gt;element.vertex == to) &#123; <span class="comment">/*边(from,to)或&lt;from,to&gt;在边表中存在且确</span></span><br><span class="line"><span class="comment">											   定了该边在边表中的位置,则从边表中将其删掉*/</span></span><br><span class="line">            Link&lt;listUnit&gt; *other = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp-&gt;next;</span><br><span class="line">            temp-&gt;next = other;</span><br><span class="line">            numEdge--;</span><br><span class="line">            Indegree[to]--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IniGraphl</span><span class="params">(Graphl *Graphl, <span class="keyword">int</span> A[N][N])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::IniGraphl</span><span class="params">(Graphl *Graphl, <span class="keyword">int</span> A[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                Graphl-&gt;setEdge(i, j, A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：深度优先搜索算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;    <span class="comment">//深度优先搜索算法实现</span></span><br><span class="line">    G.Mark[v] = VISITED;       <span class="comment">//访问顶点v，并标记其标志位</span></span><br><span class="line">    Visit(G, v);</span><br><span class="line">    <span class="comment">//访问V邻接到的未被访问过的顶点，并递归地按照深度优先的方式进行周游</span></span><br><span class="line">    <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED)</span><br><span class="line">            DFS(G, G.ToVertex(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;           <span class="comment">// 广度优先搜索算法的实现</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;                    <span class="comment">// 初始化广度优先周游要用到的队列</span></span><br><span class="line">    Visit(G, v);                       <span class="comment">// 问顶点v，并标记其标志位</span></span><br><span class="line">    G.Mark[v] = VISITED;</span><br><span class="line">    Q.push(v);                       <span class="comment">// v入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">// 如果队列仍然有元素</span></span><br><span class="line">        <span class="keyword">int</span> u = Q.front();              <span class="comment">// 队列顶部元素</span></span><br><span class="line">        Q.pop();                     <span class="comment">// 队列顶部元素出队</span></span><br><span class="line">        <span class="comment">// 该顶点邻接到的每一个未访问顶点都入队</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(u); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED) &#123;</span><br><span class="line">                Visit(G, G.ToVertex(e));</span><br><span class="line">                G.Mark[G.ToVertex(e)] = VISITED;</span><br><span class="line">                Q.push(G.ToVertex(e));  <span class="comment">// 入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示顶点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphl::Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;V&#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Graphm-h"><a href="#Graphm-h" class="headerlink" title="Graphm.h"></a>Graphm.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的相邻矩阵表示法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphm</span> :</span> <span class="keyword">public</span> Graph &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> **matrix;                <span class="comment">//指向相邻矩阵的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IniGraphm</span><span class="params">(Graphm *Graphm, <span class="keyword">int</span> A[N][N])</span></span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;            <span class="comment">// 深度优先搜索  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;            <span class="comment">// 广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span></span>;        <span class="comment">// 访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graphm(<span class="keyword">int</span> numVert) : Graph(numVert) &#123;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">int</span> i, j;            <span class="comment">//i, j作为for循环中的计数器</span></span><br><span class="line">        matrix = (<span class="keyword">int</span> **) <span class="keyword">new</span> <span class="keyword">int</span> *[numVertex]; <span class="comment">/*申请matrix数组,该数组有numVertex个元素,每个元素是整型指针类型*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numVertex; i++)        <span class="comment">/*matrix数组的每个元素,都指向一个具有numVertex个元素的数组*/</span></span><br><span class="line">            matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span>[numVertex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">             i &lt; numVertex; i++)       <span class="comment">/*相邻矩阵的所有元素都初始化为0,如果矩阵元素matrix[i][j]不为0,则表明顶点i与顶点j之间有一条边,边的权即为matrix[i][j]的值*/</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numVertex; j++)</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Graphm() &#123;                            <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++)</span><br><span class="line">            <span class="keyword">delete</span>[] matrix[i];            <span class="comment">//释放每个matrix[i]申请的空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] matrix;                <span class="comment">//释放matrix指针指向的空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">FirstEdge</span><span class="params">(<span class="keyword">int</span> oneVertex)</span> </span>&#123;    <span class="comment">//返回顶点oneVertex的第一条边</span></span><br><span class="line">        Edge myEdge;                        <span class="comment">//边myEdge将作为函数的返回值</span></span><br><span class="line">        myEdge.from = oneVertex;            <span class="comment">//将顶点oneVertex作为边myEdge的始点</span></span><br><span class="line">        <span class="comment">//  myEdge.to = -1; </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numVertex; i++) &#123;<span class="comment">/* 下面寻找第一个使得matrix[oneVertex][i]</span></span><br><span class="line"><span class="comment">												不为0的i值，那么边(oneVertex,i)或者</span></span><br><span class="line"><span class="comment">												弧&lt;oneVertex,i&gt;即为顶点oneVertex</span></span><br><span class="line"><span class="comment">												的第一条边，将顶点i作为边myEdge的终点边myEdge</span></span><br><span class="line"><span class="comment">			                                    的权为矩阵元素matrix[oneVertex][i]的值*/</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[oneVertex][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                myEdge.to = i;</span><br><span class="line">                myEdge.weight = matrix[oneVertex][i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge;<span class="comment">/*如果找到了顶点oneVertex的第一条边,则返回的myEdge确实是一条边；</span></span><br><span class="line"><span class="comment">		              如果没有找到顶点oneVertex的第一条边,则myEdge的成员变量to为-1，</span></span><br><span class="line"><span class="comment">		              根据IsEdge函数判断可知myEdge不是一条边*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Edge <span class="title">NextEdge</span><span class="params">(Edge preEdge)</span> </span>&#123; <span class="comment">//返回与边PreEdge有相同关联顶点的下一条边</span></span><br><span class="line">        Edge myEdge;</span><br><span class="line">        myEdge.from = preEdge.from; <span class="comment">/*将边myEdge的始点置为与上一条边preEdge的始点相同*/</span></span><br><span class="line">        <span class="keyword">if</span> (preEdge.to &lt; numVertex) &#123;</span><br><span class="line">            <span class="comment">//如果preEdge.to+1&gt;=numVertex,那么就不存在下一条边了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = preEdge.to + <span class="number">1</span>; i &lt; numVertex; i++) &#123;</span><br><span class="line">                <span class="comment">/*寻找下一个使得//matrix[preEdge.from][i]不为0的i值,那么</span></span><br><span class="line"><span class="comment">                (preEdge.from,i)或者&lt;preEdge.from,i&gt;即为顶点preEdge.from的下一条边*/</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[preEdge.from][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    myEdge.to = i;</span><br><span class="line">                    myEdge.weight = matrix[preEdge.from][i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myEdge; <span class="comment">/*如果找到了顶点preEdge.from的下一条边，则返回的myEdge确实是一条边；</span></span><br><span class="line"><span class="comment">					   如果没有找到顶点preEdge.from的下一条边，则myEdge的成员变量to为-1，</span></span><br><span class="line"><span class="comment">						根据IsEdge函数判断可知myEdge不是一条边*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;    <span class="comment">//为图设定一条边</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[from][to] &lt;= <span class="number">0</span>) &#123;  <span class="comment">/*如果matrix[from][to]&lt;=0，则边(from,to) 或者&lt;from,to&gt;</span></span><br><span class="line"><span class="comment">			                       将是新增的一条边，否则该边已经存在（现在只是对该边进行修改）*/</span></span><br><span class="line">            numEdge++;</span><br><span class="line">            Indegree[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[from][to] = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;     <span class="comment">//删除图的一条边</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[from][to] &gt; <span class="number">0</span>) &#123; <span class="comment">/*如果matrix[from][to]&gt;0，则边(from,to)或者&lt;from,to&gt;确实存在，</span></span><br><span class="line"><span class="comment">			                      否则该边实际上并不存在（从而不必对图的边数和顶点to的入度进行修改）*/</span></span><br><span class="line">            numEdge--;</span><br><span class="line">            Indegree[to]--;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix[from][to] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::IniGraphm</span><span class="params">(Graphm *Graphm, <span class="keyword">int</span> A[N][N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                Graphm-&gt;setEdge(i, j, A[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能：深度优先搜索算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::DFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;    <span class="comment">//深度优先搜索算法实现</span></span><br><span class="line">    G.Mark[v] = VISITED;       <span class="comment">//访问顶点v，并标记其标志位</span></span><br><span class="line">    Visit(G, v);</span><br><span class="line">    <span class="comment">//访问V邻接到的未被访问过的顶点，并递归地按照深度优先的方式进行周游</span></span><br><span class="line">    <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED)</span><br><span class="line">            DFS(G, G.ToVertex(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::BFS</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">// 广度优先搜索算法的实现</span></span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;                    <span class="comment">// 初始化广度优先周游要用到的队列</span></span><br><span class="line">    Visit(G, v);                       <span class="comment">// 问顶点v，并标记其标志位</span></span><br><span class="line">    G.Mark[v] = VISITED;</span><br><span class="line">    Q.push(v);                       <span class="comment">// v入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">// 如果队列仍然有元素</span></span><br><span class="line">        <span class="keyword">int</span> u = Q.front();              <span class="comment">// 队列顶部元素</span></span><br><span class="line">        Q.pop();                     <span class="comment">// 队列顶部元素出队</span></span><br><span class="line">        <span class="comment">// 该顶点邻接到的每一个未访问顶点都入队</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(u); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] == UNVISITED) &#123;</span><br><span class="line">                Visit(G, G.ToVertex(e));</span><br><span class="line">                G.Mark[G.ToVertex(e)] = VISITED;</span><br><span class="line">                Q.push(G.ToVertex(e));  <span class="comment">// 入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示顶点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graphm::Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;V&#x27;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="TopsortbyQueue-cpp"><a href="#TopsortbyQueue-cpp" class="headerlink" title="TopsortbyQueue.cpp"></a>TopsortbyQueue.cpp</h3><p><a herf="#Graphm-h">#include “Graphm.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的相邻矩阵表示存储图，实现图的拓扑排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：显示排序后的序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***************************************************************</span></span><br><span class="line"><span class="comment">//[算法7.7] 队列实现的图拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopsortbyQueue</span><span class="params">(Graph &amp;G)</span> </span>&#123;      <span class="comment">//队列方式实现的拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)    <span class="comment">//初始化Mark数组</span></span><br><span class="line">        G.Mark[i] = UNVISITED;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Q.push(i);                <span class="comment">//图中入度为0的顶点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;              <span class="comment">//如果队列中还有图的顶点</span></span><br><span class="line">        <span class="keyword">int</span> V = Q.front();</span><br><span class="line">        Q.pop();                     <span class="comment">//一个顶点出队</span></span><br><span class="line">        Visit(G, V);</span><br><span class="line">        G.Mark[V] = VISITED;</span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(V); G.IsEdge(e); e = G.NextEdge(e)) &#123;</span><br><span class="line">            G.Indegree[G.ToVertex(e)]--;  <span class="comment">//所有与之相邻的顶点入度-1</span></span><br><span class="line">            <span class="keyword">if</span> (G.Indegree[G.ToVertex(e)] == <span class="number">0</span>)</span><br><span class="line">                Q.push(G.ToVertex(e));   <span class="comment">//入度为0的顶点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[i] == UNVISITED) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 此图有环！&quot;</span>;        <span class="comment">//图有环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//C0  C1  C2  C3  C4  C5  C6  C7  C8	</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;  <span class="comment">//该图为图7.18表示课程优先关系的有向无环图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>;              <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Top sort by Queue is : &quot;</span>;</span><br><span class="line">    TopsortbyQueue(aGraphm);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\nOK! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra-cpp"><a href="#Dijkstra-cpp" class="headerlink" title="Dijkstra.cpp"></a>Dijkstra.cpp</h3><p><a herf="#Graphm-h">#include “Graphm.h”</a></p>
<p><a herf="#MinHeap-h">#include “MinHeap.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的相邻矩阵表示方法,还要用到最小值堆</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 9999    <span class="comment">//设置最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graph_matrix.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[代码7.8] Dijkstra算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span>  &#123;</span>      <span class="comment">//定义Dist类，下面的Dijkstra算法和Floyd算法要用到</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	 <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">	 <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">	 <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">	 Dist() &#123;&#125;;</span><br><span class="line">	 ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Dist &amp; arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length==arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&gt;arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(<span class="keyword">const</span> Dist &amp;arg)  &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&lt;=arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">		 <span class="keyword">return</span> (length&gt;=arg.length);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra算法，其中参数G是图，参数s是源顶点，D是保存最短距离及其路径的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; G, <span class="keyword">int</span> s, Dist* &amp;D)</span>  </span>&#123;</span><br><span class="line">	D = <span class="keyword">new</span> Dist[G. VerticesNum()];          	<span class="comment">// D数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;   	<span class="comment">// 初始化Mark数组、D数组</span></span><br><span class="line">		G.Mark[i] = UNVISITED;</span><br><span class="line">        D[i].index = i;</span><br><span class="line">        D[i].length = INFINITE;</span><br><span class="line">        D[i].pre = s;</span><br><span class="line">    &#125;</span><br><span class="line">    D[s].length = <span class="number">0</span>; </span><br><span class="line">    <span class="function">MinHeap&lt;Dist&gt; <span class="title">H</span><span class="params">(G. EdgesNum())</span></span>;       	<span class="comment">// 最小值堆（minheap）</span></span><br><span class="line">    H.Insert(D[s]);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;</span><br><span class="line">		<span class="keyword">bool</span> FOUND = <span class="literal">false</span>;</span><br><span class="line">        Dist d;</span><br><span class="line">        <span class="keyword">while</span> (!H.isEmpty())  &#123;</span><br><span class="line">			d = H.RemoveMin(); </span><br><span class="line">			<span class="keyword">if</span>(G.Mark[d.index]==UNVISITED) &#123;                <span class="comment">//打印出路径信息</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;vertex index: &quot;</span> &lt;&lt;d.index&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;vertex pre  : &quot;</span> &lt;&lt;d.pre  &lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;V0 --&gt; V&quot;</span> &lt;&lt; d.index &lt;&lt;<span class="string">&quot;  length    : &quot;</span> &lt;&lt;d.length&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (G.Mark[d.index] == UNVISITED) &#123; <span class="comment">//找到距离s最近的顶点</span></span><br><span class="line">				FOUND = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span> (!FOUND)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> v = d.index;</span><br><span class="line">		G.Mark[v] = VISITED;           		<span class="comment">// 把该点加入已访问组</span></span><br><span class="line">		<span class="comment">// 因为v的加入，需要刷新v邻接点的D值</span></span><br><span class="line">		<span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e);e = G.NextEdge(e))</span><br><span class="line">			<span class="keyword">if</span> (D[G.ToVertex(e)].length &gt; (D[v].length+G.Weight(e))) &#123;</span><br><span class="line">				D[G.ToVertex(e)].length = D[v].length+G.Weight(e);</span><br><span class="line">				D[G.ToVertex(e)].pre = v;</span><br><span class="line">				H.Insert(D[G.ToVertex(e)]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] =  &#123;          <span class="comment">//图7.20  单源最短路径的示例</span></span><br><span class="line"><span class="comment">//  v0  v1  v2  v3  v4  </span></span><br><span class="line">	 <span class="number">0</span>, <span class="number">10</span>,  <span class="number">0</span>, <span class="number">30</span>, <span class="number">100</span>,</span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>, <span class="number">50</span>,  <span class="number">0</span>,  <span class="number">0</span>, </span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, <span class="number">10</span>, </span><br><span class="line">     <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>,  <span class="number">0</span>, <span class="number">60</span>, </span><br><span class="line">     <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line"> aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"> Dist *D;</span><br><span class="line"> Dijkstra(aGraphm, <span class="number">0</span>, D);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Floyd-h"><a href="#Floyd-h" class="headerlink" title="Floyd.h"></a>Floyd.h</h3><p><a herf="#Graphm-h">#include “Graphm.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图用相邻矩阵表示方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************************************************</span></span><br><span class="line"><span class="comment">//这里要注意 图类中的边为无穷大的时候也应该看成是一条边</span></span><br><span class="line"><span class="comment">//所以要修改一下IsEdge函数的定义</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3 <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 0xffff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span> &#123;</span>      <span class="comment">//定义Dist类，下面的Dijkstra算法和Floyd算法要用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">    <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">    Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//[算法7.9] Floyd算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(Graph &amp;G, Dist **&amp;D)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, v;                               <span class="comment">// i,j,v是计数器</span></span><br><span class="line">    D = <span class="keyword">new</span> Dist *[G.VerticesNum()];          <span class="comment">// 为数组D申请空间</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        D[i] = <span class="keyword">new</span> Dist[G.VerticesNum()];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)          <span class="comment">// 初始化数组D</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.VerticesNum(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                D[i][j].length = <span class="number">0</span>;</span><br><span class="line">                D[i][j].pre = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                D[i][j].length = INFINITE;</span><br><span class="line">                D[i][j].pre = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.VerticesNum(); v++)</span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e)) &#123;</span><br><span class="line">            D[v][G.ToVertex(e)].length = G.Weight(e);</span><br><span class="line">            D[v][G.ToVertex(e)].pre = v;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果两个顶点间的最短路径经过顶点v，则更新最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.VerticesNum(); v++)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.VerticesNum(); j++)</span><br><span class="line">                <span class="keyword">if</span> (D[i][j].length &gt; (D[i][v].length + D[v][j].length)) &#123;</span><br><span class="line">                    D[i][j].length = D[i][v].length + D[v][j].length;</span><br><span class="line">                    D[i][j].pre = D[v][j].pre;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line"><span class="comment">//	V0    V1    V2</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">3</span>, INFINITE, <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Dist **D;</span><br><span class="line">    Floyd(aGraphm, D);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; D[i][j].length &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Prim-cpp"><a href="#Prim-cpp" class="headerlink" title="Prim.cpp"></a>Prim.cpp</h3><p><a herf="#Graphm-h">#include “Graphm.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7         <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dist</span> &#123;</span>      <span class="comment">//定义Dist类，下面的Prim算法要用到</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> index;      <span class="comment">//顶点的索引值，仅Dijkstra算法会用到</span></span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">//顶点之间的距离</span></span><br><span class="line">    <span class="keyword">int</span> pre;       <span class="comment">//路径最后经过的顶点</span></span><br><span class="line">    Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ~Dist() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graphm &amp;G, <span class="keyword">int</span> s, Dist *&amp;D)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length == c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt; arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &lt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> Dist &amp;arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> (length &gt;= arg.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minVertex</span><span class="params">(Graph &amp;G, Dist *&amp;D)</span> </span>&#123;            <span class="comment">// 在Dist数组中找最小值</span></span><br><span class="line">    <span class="keyword">int</span> i, v;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G.Mark[i] == UNVISITED) &#123;</span><br><span class="line">            v = i;                        <span class="comment">// 让v为随意一个未访问的定义</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)</span><br><span class="line">        <span class="keyword">if</span> ((G.Mark[i] == UNVISITED) &amp;&amp; (D[i] &lt; D[v]))</span><br><span class="line">            v = i;                        <span class="comment">// 保存目前发现的具有最小距离的顶点</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//最小支撑树的Prim算法，</span></span><br><span class="line"><span class="comment">//参数G是图，参数s是开始顶点，参数MST是保存最小支撑树中所有边的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdgetoMST</span><span class="params">(Edge e, Edge *&amp;MST, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MST[n] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(Graph &amp;G, <span class="keyword">int</span> s, Edge *&amp;MST)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MSTtag = <span class="number">0</span>;                       <span class="comment">// 最小生成树边的标号</span></span><br><span class="line">    MST = <span class="keyword">new</span> Edge[G.VerticesNum() - <span class="number">1</span>];</span><br><span class="line">    Dist *D;</span><br><span class="line">    D = <span class="keyword">new</span> Dist[G.VerticesNum()];            <span class="comment">// D数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++) &#123;    <span class="comment">// 初始化Mark数组、D数组</span></span><br><span class="line">        G.Mark[i] = UNVISITED;</span><br><span class="line">        D[i].index = i;</span><br><span class="line">        D[i].length = INFINITE;</span><br><span class="line">        D[i].pre = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    D[s].length = <span class="number">0</span>;</span><br><span class="line">    G.Mark[s] = VISITED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.VerticesNum() - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (D[v] == INFINITY) <span class="keyword">return</span>;        <span class="comment">// 非连通，有不可达顶点，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为v的加入，需要刷新v邻接点的D值</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(v); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.Mark[G.ToVertex(e)] != VISITED &amp;&amp; (D[G.ToVertex(e)].length &gt; e.weight)) &#123;</span><br><span class="line">                D[G.ToVertex(e)].length = e.weight;</span><br><span class="line">                D[G.ToVertex(e)].pre = v;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        v = minVertex(G, D);</span><br><span class="line"></span><br><span class="line">        G.Mark[v] = VISITED;</span><br><span class="line">        <span class="function">Edge <span class="title">edge</span><span class="params">(D[v].pre, D[v].index, D[v].length)</span></span>;</span><br><span class="line"></span><br><span class="line">        AddEdgetoMST(edge, MST, MSTtag++);  <span class="comment">// 将边e加到MST中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//   v0  v1  v2  v3  v4  v5  v6     </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">20</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;                                    <span class="comment">//图7.24 带权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Edge *D;</span><br><span class="line">    Prim(aGraphm, <span class="number">0</span>, D);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;V&quot;</span> &lt;&lt; D[i].from &lt;&lt; <span class="string">&quot;-&gt;V&quot;</span> &lt;&lt; D[i].to &lt;&lt; <span class="string">&quot;   Weight is : &quot;</span> &lt;&lt; D[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal-cpp"><a href="#Kruskal-cpp" class="headerlink" title="Kruskal.cpp"></a>Kruskal.cpp</h3><p><a herf="#Graphm-h">#include “Graphm.h”</a></p>
<p><a herf="#MinHeap-h">#include “MinHeap.h”</a></p>
<p><a herf="#ParTree-h">#include “ParTree.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITE 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7         <span class="comment">// 定义图的顶点数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Graphm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ParTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最小支撑树的Kruskal算法，</span></span><br><span class="line"><span class="comment">//参数G是图，参数MST是保存最小支撑树中所有边的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdgetoMST</span><span class="params">(Edge e, Edge *&amp;MST, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MST[n] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Graph &amp;G, Edge *&amp;MST)</span> </span>&#123;</span><br><span class="line">    <span class="function">ParTree&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(G.VerticesNum())</span></span>;           <span class="comment">//等价类</span></span><br><span class="line">    <span class="function">MinHeap&lt;Edge&gt; <span class="title">H</span><span class="params">(G.EdgesNum())</span></span>;        <span class="comment">//最小值堆（minheap）    </span></span><br><span class="line">    MST = <span class="keyword">new</span> Edge[G.VerticesNum() - <span class="number">1</span>];      <span class="comment">//最小支撑树</span></span><br><span class="line">    <span class="keyword">int</span> MSTtag = <span class="number">0</span>;                         <span class="comment">//最小支撑树边的标号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.VerticesNum(); i++)  <span class="comment">//将图的所有边插入最小值堆H中</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e = G.FirstEdge(i); G.IsEdge(e); e = G.NextEdge(e))</span><br><span class="line">            <span class="keyword">if</span> (G.FromVertex(e) &lt; G.ToVertex(e))  <span class="comment">//因为是无向图，所以应防止重复插入</span></span><br><span class="line">                H.Insert(e);</span><br><span class="line">    <span class="keyword">int</span> EquNum = G.VerticesNum();              <span class="comment">//开始时有|V|个等价类</span></span><br><span class="line">    <span class="keyword">while</span> (EquNum &gt; <span class="number">1</span>) &#123;                     <span class="comment">//合并等价类</span></span><br><span class="line">        Edge e = H.RemoveMin();               <span class="comment">//获得下一条权最小的边</span></span><br><span class="line">        <span class="keyword">if</span> (e.weight == INFINITE) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不存在最小支撑树.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] MST;                     <span class="comment">//释放空间</span></span><br><span class="line">            MST = <span class="literal">NULL</span>;                   <span class="comment">//MST是空数组</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> from = G.FromVertex(e);            <span class="comment">//记录该条边的信息</span></span><br><span class="line">        <span class="keyword">int</span> to = G.ToVertex(e);</span><br><span class="line">        <span class="keyword">if</span> (A.Different(from, to)) &#123;            <span class="comment">//如果边e的两个顶点不在一个等价类</span></span><br><span class="line">            A.Union(from, to);     <span class="comment">//将边e的两个顶点所在的两个等价类合并为一个</span></span><br><span class="line">            AddEdgetoMST(e, MST, MSTtag++); <span class="comment">//将边e加到MST</span></span><br><span class="line">            EquNum--;                     <span class="comment">//将等价类的个数减1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N] = &#123;</span><br><span class="line">        <span class="comment">//   v0  v1  v2  v3  v4  v5  v6     </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">20</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;                                    <span class="comment">//图7.24 带权图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graphm <span class="title">aGraphm</span><span class="params">(N)</span></span>; <span class="comment">// 建立图</span></span><br><span class="line">    aGraphm.IniGraphm(&amp;aGraphm, A); <span class="comment">// 初始化图</span></span><br><span class="line"></span><br><span class="line">    Edge *D;</span><br><span class="line">    Kruskal(aGraphm, D);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;V&quot;</span> &lt;&lt; D[i].from &lt;&lt; <span class="string">&quot;-&gt;V&quot;</span> &lt;&lt; D[i].to &lt;&lt; <span class="string">&quot;   Weight is : &quot;</span> &lt;&lt; D[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八-内排序"><a href="#八-内排序" class="headerlink" title="八    内排序"></a>八    内排序</h2><h3 id="InsertSort-h"><a href="#InsertSort-h" class="headerlink" title="InsertSort.h"></a>InsertSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接插入排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    Record TempRecord;                        <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;                    <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        TempRecord = Array[i];                    <span class="comment">// 先把记录Array[i]保留在临时记录变量中</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                            <span class="comment">// 内存循环变量从j从i-1开始</span></span><br><span class="line">        <span class="comment">// 往前寻找记录i的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; TempRecord &lt; Array[j]) &#123;</span><br><span class="line">            Array[j + <span class="number">1</span>] = Array[j];                <span class="comment">// 将那些大于等于记录i的记录后移</span></span><br><span class="line">            j = j - <span class="number">1</span>;                        <span class="comment">// 下标j前移</span></span><br><span class="line">        &#125;</span><br><span class="line">        Array[j + <span class="number">1</span>] = TempRecord;                <span class="comment">// 此时j+1就是记录i的正确位置，回填</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShellSort-h"><a href="#ShellSort-h" class="headerlink" title="ShellSort.h"></a>ShellSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;            <span class="comment">// Shell排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> delta = n / <span class="number">2</span>; delta &gt; <span class="number">0</span>; delta /= <span class="number">2</span>)        <span class="comment">// 增量delta每次除以2递减</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++)            <span class="comment">// 分别对delta个子序列进行插入排序</span></span><br><span class="line">            ModInsSort(&amp;Array[i], n - i, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModInsSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> delta)</span> </span>&#123;    <span class="comment">// 修改的插入排序算法，参数delta表示当前的增量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = delta; i &lt; n; i += delta)            <span class="comment">// 对子序列中第i个记录，寻找合适的插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= delta; j -= delta) &#123;        <span class="comment">//  j以dealta为步长向前寻找逆置对进行调整</span></span><br><span class="line">            <span class="keyword">if</span> (Array[j] &lt; Array[j - delta])        <span class="comment">//  Array[j] &lt; Array[j-delta]，则二者为逆置对</span></span><br><span class="line">                swap(Array, j, j - delta);        <span class="comment">// 交换Array[j]和Array[j-delta]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SelectSort-h"><a href="#SelectSort-h" class="headerlink" title="SelectSort.h"></a>SelectSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;    <span class="comment">// 直接选择排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;            <span class="comment">// 依次选出第i小的记录，即剩余记录中最小的那个</span></span><br><span class="line">        <span class="keyword">int</span> Smallest = i;                <span class="comment">// 首先假设记录i就是最小的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)            <span class="comment">// 开始向后扫描所有剩余记录</span></span><br><span class="line">            <span class="keyword">if</span> (Array[j] &lt; Array[Smallest])</span><br><span class="line">                Smallest = j;            <span class="comment">// 如果发现更小的记录，记录它的位置</span></span><br><span class="line">        swap(Array, i, Smallest);            <span class="comment">// 交换Array[i]和 Array[Smallest]，第i小的记录到位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    SelectSort(Array, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MaxHeap-h"><a href="#MaxHeap-h" class="headerlink" title="MaxHeap.h"></a>MaxHeap.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heapArray;                            <span class="comment">//存放堆数据的数组</span></span><br><span class="line">    <span class="keyword">int</span> CurrentSize;                        <span class="comment">//当前堆中元素数目</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                            <span class="comment">//堆所能容纳的最大元素数目</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(T *<span class="built_in">array</span>, <span class="keyword">int</span> num, <span class="keyword">int</span> max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~MaxHeap() &#123;&#125;;                    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//如果是叶结点，返回TRUE</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leftchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回左孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rightchild</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;            <span class="comment">//返回右孩子位置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;                <span class="comment">//返回父结点位置</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> pos, T &amp;node)</span></span>;            <span class="comment">//删除给定下标的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftDown</span><span class="params">(<span class="keyword">int</span> left)</span></span>;                <span class="comment">//筛选法函数，参数left表示开始处理的数组下标</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SiftUp</span><span class="params">(<span class="keyword">int</span> position)</span></span>;                <span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T &amp;newNode)</span></span>;            <span class="comment">//向堆中插入新元素newNode</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveMax</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶移动最大值到尾部</span></span><br><span class="line">    <span class="function">T &amp;<span class="title">RemoveMax</span><span class="params">()</span></span>;                            <span class="comment">//从堆顶删除最大值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">MaxHeap&lt;T&gt;::MaxHeap(T *<span class="built_in">array</span>, <span class="keyword">int</span> num, <span class="keyword">int</span> max) &#123;</span><br><span class="line">    heapArray = <span class="built_in">array</span>;</span><br><span class="line">    CurrentSize = num;</span><br><span class="line">    MaxSize = max;</span><br><span class="line">    BuildHeap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::BuildHeap() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = CurrentSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        SiftDown(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::isLeaf(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pos &gt;= CurrentSize / <span class="number">2</span>) &amp;&amp; (pos &lt; CurrentSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::leftchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">1</span>;                        <span class="comment">//返回左孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::rightchild(<span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">2</span>;                        <span class="comment">//返回右孩子位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> MaxHeap&lt;T&gt;::parent(<span class="keyword">int</span> pos) <span class="keyword">const</span>    <span class="comment">//返回父节点位置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (pos - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::SiftDown(<span class="keyword">int</span> left) &#123;</span><br><span class="line">    <span class="comment">//准备</span></span><br><span class="line">    <span class="keyword">int</span> i = left;                            <span class="comment">//标识父结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>;                        <span class="comment">//标识关键值较小的子结点		</span></span><br><span class="line">    T temp = heapArray[i];                <span class="comment">//保存父结点</span></span><br><span class="line">    <span class="comment">//过筛</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; CurrentSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((j &lt; CurrentSize) &amp;&amp; (heapArray[j] &lt; heapArray[j + <span class="number">1</span>]))</span><br><span class="line">            j++;                        <span class="comment">//j指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; heapArray[j]) &#123;</span><br><span class="line">            heapArray[i] = heapArray[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * j + <span class="number">1</span>;                    <span class="comment">//向下继续</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::SiftUp(<span class="keyword">int</span> position) &#123;<span class="comment">//从position向上开始调整，使序列成为堆</span></span><br><span class="line">    <span class="keyword">int</span> temppos = position;</span><br><span class="line">    T temp = heapArray[temppos];</span><br><span class="line">    <span class="keyword">int</span> parentpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (temppos &gt; <span class="number">0</span>)</span><br><span class="line">        parentpos = parent(temppos);</span><br><span class="line">    <span class="keyword">while</span> ((temppos &gt; <span class="number">0</span>) &amp;&amp; (heapArray[parentpos] &lt; temp)) &#123;</span><br><span class="line">        heapArray[temppos] = heapArray[parentpos];</span><br><span class="line">        temppos = parentpos;</span><br><span class="line">        parentpos = parent(temppos);</span><br><span class="line">    &#125;</span><br><span class="line">    heapArray[temppos] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::Insert(<span class="keyword">const</span> T &amp;newNode) &#123;<span class="comment">//向堆中插入一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == MaxSize)                <span class="comment">//堆空间已经满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    heapArray[CurrentSize] = newNode;</span><br><span class="line">    SiftUp(CurrentSize);                    <span class="comment">//向上调整</span></span><br><span class="line">    CurrentSize++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T &amp;MaxHeap&lt;T&gt;::RemoveMax() &#123;</span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//AfxMessageBox(&quot;Can&#x27;t Delete&quot;);</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T temp = heapArray[<span class="number">0</span>];                    <span class="comment">//取堆顶元素</span></span><br><span class="line">        heapArray[<span class="number">0</span>] = heapArray[CurrentSize - <span class="number">1</span>];    <span class="comment">//堆末元素上升至堆顶</span></span><br><span class="line">        CurrentSize--;</span><br><span class="line">        SiftDown(<span class="number">0</span>);                            <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MaxHeap&lt;T&gt;::MoveMax() &#123;</span><br><span class="line">    <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//堆为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T temp = heapArray[<span class="number">0</span>];                    <span class="comment">//取堆顶元素</span></span><br><span class="line">        heapArray[<span class="number">0</span>] = heapArray[CurrentSize - <span class="number">1</span>];    <span class="comment">//堆末元素上升至堆顶</span></span><br><span class="line">        CurrentSize--;</span><br><span class="line">        SiftDown(<span class="number">0</span>);                            <span class="comment">//从堆顶开始筛选</span></span><br><span class="line">        heapArray[CurrentSize] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> MaxHeap&lt;T&gt;::Remove(<span class="keyword">int</span> pos, T &amp;node) &#123;<span class="comment">// 删除给定下标的元素</span></span><br><span class="line">    <span class="keyword">if</span> ((pos &lt; <span class="number">0</span>) || (pos &gt; CurrentSize))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    heapArray[pos] = heapArray[--CurrentSize];    <span class="comment">//指定元素置于最后</span></span><br><span class="line">    SiftUp(pos);                                <span class="comment">//上升筛</span></span><br><span class="line">    SiftDown(pos);                                <span class="comment">//向下筛	</span></span><br><span class="line">    node = heapArray[CurrentSize];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Heapsort-h"><a href="#Heapsort-h" class="headerlink" title="Heapsort.h"></a>Heapsort.h</h3><p><a herf="#MaxHeap-h">#include “MaxHeap.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MaxHeap.h&quot;</span></span></span><br><span class="line"><span class="comment">//堆排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapsort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    MaxHeap&lt;Record&gt; max_heap = MaxHeap&lt;Record&gt;(Array, n, n);    <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)         <span class="comment">// 依次找出剩余记录中的最大记录，即堆顶</span></span><br><span class="line">        max_heap.MoveMax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BubbleSort-h"><a href="#BubbleSort-h" class="headerlink" title="BubbleSort.h"></a>BubbleSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span>  </span>&#123;	<span class="comment">// 优化的冒泡排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">	<span class="keyword">bool</span> NoSwap;			<span class="comment">// 是否发生了交换的标志</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)  &#123;</span><br><span class="line">	NoSwap = <span class="literal">true</span>;		<span class="comment">// 标志初始为真</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;=i; j--)</span><br><span class="line">	  <span class="keyword">if</span> (Array[j] &lt; Array[j<span class="number">-1</span>])  &#123;	<span class="comment">// 判断（Array[j-1]，Array[j]）是否逆置</span></span><br><span class="line">		swap(Array, j, j<span class="number">-1</span>);	<span class="comment">// 交换逆置对Array[j]，Array[j-1]</span></span><br><span class="line">		NoSwap = <span class="literal">false</span>;		<span class="comment">// 发生了交换，标志变为假</span></span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">if</span> (NoSwap)  			<span class="comment">// 如果没发生过交换，表示已排好序，结束算法</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="QuickSort-h"><a href="#QuickSort-h" class="headerlink" title="QuickSort.h"></a>QuickSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;                <span class="comment">// 选择轴值，参数left,right分别表示序列的左右端下标</span></span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2</span>;                        <span class="comment">// 选择中间记录作为轴值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// Array[]为待排序数组，left,right分别为数组两端</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;                    <span class="comment">// 如果子序列中只有0或1个记录，就不需排序</span></span><br><span class="line">    <span class="keyword">int</span> pivot = ::SelectPivot(left, right);            <span class="comment">// 选择轴值</span></span><br><span class="line">    swap(Array, pivot, right);                <span class="comment">// 分割前先将轴值放到数组末端</span></span><br><span class="line">    pivot = Partition(Array, left, right);            <span class="comment">// 分割后轴值已到达正确位置</span></span><br><span class="line">    QuickSort(Array, left, pivot - <span class="number">1</span>);                <span class="comment">// 对轴值左边的子序列进行递归快速排序</span></span><br><span class="line">    QuickSort(Array, pivot + <span class="number">1</span>, right);            <span class="comment">// 对轴值右边的子序列进行递归快速排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// 分割函数，分割后轴值已到达正确位置</span></span><br><span class="line">    <span class="keyword">int</span> l = left;                                <span class="comment">//  l为左指针，r为右指针</span></span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    Record TempRecord = Array[r];                <span class="comment">// 将轴值存放在临时变量中</span></span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;                            <span class="comment">// 开始分割，l,r不断向中间移动，直到相遇</span></span><br><span class="line">        <span class="comment">// l指针向右移动，直到找到一个大于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[l] &lt;= TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把&quot;&lt;=&quot;改写为&quot;&lt;&quot;，反正不稳定</span></span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到右边的空位</span></span><br><span class="line">            Array[r] = Array[l];</span><br><span class="line">            r--;                            <span class="comment">//  r指针向左移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r指针向左移动，直到找到一个小于等于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[r] &gt; TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把&quot;&gt;&quot;改写为&quot;&gt;=&quot;，减少记录移动</span></span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到左边的空位</span></span><br><span class="line">            Array[l] = Array[r];</span><br><span class="line">            l++;                            <span class="comment">// l指针向右移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">//end while</span></span><br><span class="line">    Array[l] = TempRecord;                    <span class="comment">// 把轴值回填到分界位置l上</span></span><br><span class="line">    <span class="keyword">return</span> l;                                <span class="comment">// 返回分界位置l</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ModQuickSort-h"><a href="#ModQuickSort-h" class="headerlink" title="ModQuickSort.h"></a>ModQuickSort.h</h3><p><a herf="#InsertSort-h">#include “InsertSort.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;            <span class="comment">// 选择轴值，参数left,right分别表示序列的左右端下标</span></span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2</span>;                    <span class="comment">// 选择中间纪录作为轴值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModQuickSort</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;  <span class="comment">// 优化的快速排序，</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;            <span class="comment">// 如果序列中只有0或1个记录，就不用排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; THRESHOLD) &#123;        <span class="comment">// 对长度大于阈值(28最佳)的长子串处理</span></span><br><span class="line">        <span class="keyword">int</span> pivot = ::SelectPivot(left, right);        <span class="comment">// 选择轴值	</span></span><br><span class="line">        swap(Array, pivot, right);        <span class="comment">// 将轴值放在数组末端</span></span><br><span class="line">        pivot = Partition(Array, left, right);        <span class="comment">// 分割后轴值已到达正确位置</span></span><br><span class="line">        ModQuickSort(Array, left, pivot - <span class="number">1</span>);        <span class="comment">// 对轴值左边的子序列进行递归快速排序</span></span><br><span class="line">        ModQuickSort(Array, pivot + <span class="number">1</span>, right);        <span class="comment">// 对轴值右边的子序列进行递归快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(Record Array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;        <span class="comment">// 分割函数，分割后轴值已到达正确位置</span></span><br><span class="line">    <span class="keyword">int</span> l = left;                                <span class="comment">//  l为左指针，r为右指针</span></span><br><span class="line">    <span class="keyword">int</span> r = right;</span><br><span class="line">    Record TempRecord = Array[r];                <span class="comment">// 将轴值存放在临时变量中</span></span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;                            <span class="comment">// 开始分割，l,r不断向中间移动，直到相遇</span></span><br><span class="line">        <span class="comment">// l指针向右移动，直到找到一个大于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[l] &lt;= TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把“&lt;=”改写为“&lt;”，反正不稳定</span></span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到右边的空位</span></span><br><span class="line">            Array[r] = Array[l];</span><br><span class="line">            r--;                            <span class="comment">//  r指针向左移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r指针向左移动，直到找到一个小于等于轴值的记录</span></span><br><span class="line">        <span class="keyword">while</span> (Array[r] &gt; TempRecord &amp;&amp; r &gt; l)    <span class="comment">// 这里也可以把“&gt;”改写为“&gt;=”，减少记录移动</span></span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;                        <span class="comment">// 若l,r尚未相遇，将逆置元素换到左边的空位</span></span><br><span class="line">            Array[l] = Array[r];</span><br><span class="line">            l++;                            <span class="comment">// l指针向右移动一步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">//end while</span></span><br><span class="line">    Array[l] = TempRecord;                    <span class="comment">// 把轴值回填到分界位置l上</span></span><br><span class="line">    <span class="keyword">return</span> l;                                <span class="comment">// 返回分界位置l</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ModQuickSort(Array, <span class="number">0</span>, n - <span class="number">1</span>);            <span class="comment">// 调用优化的递归快排，不处理小子串</span></span><br><span class="line">    InsertSort(Array, n);                <span class="comment">// 最后这个序列进行扫尾插入排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MergeSort-h"><a href="#MergeSort-h" class="headerlink" title="MergeSort.h"></a>MergeSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两路归并排序，Array[]为待排序数组，left，right分别为数组两端</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;                            <span class="comment">// 如果序列中只有0或1个记录，就不用排序</span></span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;                    <span class="comment">//从中间划分为两个子序列</span></span><br><span class="line">        MergeSort(Array, TempArray, left, middle);        <span class="comment">//对左边一半进行递归</span></span><br><span class="line">        MergeSort(Array, TempArray, middle + <span class="number">1</span>, right);    <span class="comment">//对右边一半进行递归</span></span><br><span class="line">        Merge(Array, TempArray, left, right, middle);        <span class="comment">// 进行归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> middle)</span> </span>&#123;  <span class="comment">//归并过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; j++)                    <span class="comment">// 将数组暂存入临时数组</span></span><br><span class="line">        TempArray[j] = Array[j];</span><br><span class="line">    <span class="keyword">int</span> index1 = left;                                <span class="comment">// 左边子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> index2 = middle + <span class="number">1</span>;                            <span class="comment">// 右边子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> i = left;                                    <span class="comment">// 从左开始归并</span></span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= middle &amp;&amp; index2 &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//取较小者插入合并数组中</span></span><br><span class="line">        <span class="keyword">if</span> (TempArray[index1] &lt;= TempArray[index2])    <span class="comment">// 为保证稳定性，相等时左边优先</span></span><br><span class="line">            Array[i++] = TempArray[index1++];</span><br><span class="line">        <span class="keyword">else</span> Array[i++] = TempArray[index2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index1 &lt;= middle)                        <span class="comment">// 只剩左序列，可以直接复制</span></span><br><span class="line">        Array[i++] = TempArray[index1++];</span><br><span class="line">    <span class="keyword">while</span> (index2 &lt;= right)                        <span class="comment">// 与上个循环互斥，直接复制剩余的右序列</span></span><br><span class="line">        Array[i++] = TempArray[index2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Record *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) temp = <span class="keyword">new</span> Record[n];            <span class="comment">// 申请辅助数组</span></span><br><span class="line">    MergeSort(<span class="built_in">array</span>, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../SortMain.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ModMergeSort-h"><a href="#ModMergeSort-h" class="headerlink" title="ModMergeSort.h"></a>ModMergeSort.h</h3><p><a herf="#InsertSort-h">#include “InsertSort.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接插入排序，Array[]为待排序数组，n为数组长度</span></span><br><span class="line">    Record TempRecord;                        <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;                    <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        TempRecord = Array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从i开始往前寻找记录i的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; TempRecord &lt; Array[j]) &#123;</span><br><span class="line">            Array[j + <span class="number">1</span>] = Array[j];                <span class="comment">// 将那些大于等于记录i的记录后移</span></span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Array[j + <span class="number">1</span>] = TempRecord;                <span class="comment">// 此时j后面就是记录i的正确位置，回填</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModMergeSort</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	if (right &lt;= left)	return;						// 如果只含有一个元素，直接返回		  </span></span><br><span class="line">    <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; THRESHOLD) &#123;                <span class="comment">//如果序列长度大于阈值(16最佳)，跳出递归</span></span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;                    <span class="comment">// 从中间划分为两个子序列</span></span><br><span class="line">        ModMergeSort(Array, TempArray, left, middle);    <span class="comment">// 对左边一半进行递归</span></span><br><span class="line">        ModMergeSort(Array, TempArray, middle + <span class="number">1</span>, right);    <span class="comment">// 对右边一半进行递归</span></span><br><span class="line">        ModMerge(Array, TempArray, left, right, middle);    <span class="comment">// 进行归并</span></span><br><span class="line">    &#125; <span class="keyword">else</span> InsertSort(&amp;Array[left], right - left + <span class="number">1</span>);            <span class="comment">// 若长度小于等于阈值，采用直接插入排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModMerge</span><span class="params">(Record Array[], Record TempArray[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> middle)</span> </span>&#123;    <span class="comment">//归并过程</span></span><br><span class="line">    <span class="keyword">int</span> index1, index2;                            <span class="comment">// 两个子序列的起始位置</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt;= middle; i++)                        <span class="comment">// 复制左边的子序列</span></span><br><span class="line">        TempArray[i] = Array[i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= right - middle; j++)                    <span class="comment">// 复制右边的子序列，但顺序颠倒过来</span></span><br><span class="line">        TempArray[right - j + <span class="number">1</span>] = Array[j + middle];</span><br><span class="line">    <span class="comment">// 开始归并，取较小者插入合并数组中</span></span><br><span class="line">    <span class="keyword">for</span> (index1 = left, index2 = right, k = left; k &lt;= right; k++)</span><br><span class="line">        <span class="keyword">if</span> (TempArray[index1] &lt;= TempArray[index2])    <span class="comment">// 为保证稳定性，相等时左边优先</span></span><br><span class="line">            Array[k] = TempArray[index1++];</span><br><span class="line">        <span class="keyword">else</span> Array[k] = TempArray[index2--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *<span class="built_in">array</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Record *temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) temp = <span class="keyword">new</span> Record[n];                <span class="comment">// 申请辅助数组</span></span><br><span class="line">    ModMergeSort(<span class="built_in">array</span>, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BucketSort-h"><a href="#BucketSort-h" class="headerlink" title="BucketSort.h"></a>BucketSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 桶式排序，Array[]为待排序数组，数组长度为n，所有记录都位于区间[0,max)上</span></span><br><span class="line">    <span class="keyword">int</span> *TempArray = <span class="keyword">new</span> Record[n];        <span class="comment">// 临时数组</span></span><br><span class="line">    <span class="keyword">int</span> *count = <span class="keyword">new</span> <span class="keyword">int</span>[max];            <span class="comment">// 小于或等于i的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)                    <span class="comment">// 把序列复制到临时数组</span></span><br><span class="line">        TempArray[i] = Array[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++)                <span class="comment">// 所有计数器初始都为0</span></span><br><span class="line">        count[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)                    <span class="comment">// 统计每个取值出现的次数</span></span><br><span class="line">        count[Array[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; max; i++)                <span class="comment">// 统计小于等于i的元素个数</span></span><br><span class="line">        count[i] = count[i - <span class="number">1</span>] + count[i];</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)                <span class="comment">// 从尾部开始按顺序输出有序序列，保证排序的稳定性</span></span><br><span class="line">        Array[--count[TempArray[i]]] = TempArray[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Record *Array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    BucketSort(Array, n, <span class="number">80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RadixSort-h"><a href="#RadixSort-h" class="headerlink" title="RadixSort.h"></a>RadixSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(Record Array[], <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> r)</span>  </span>&#123;</span><br><span class="line">	<span class="comment">//数组实现的基数排序，n为数组长度，d为排序码个数，r为基数</span></span><br><span class="line">	Record *TempArray =<span class="keyword">new</span> Record[n];		<span class="comment">// 辅助排序的临时数组</span></span><br><span class="line">	<span class="keyword">int</span>* count = <span class="keyword">new</span> <span class="keyword">int</span>[r];				<span class="comment">// 桶容量计数器，count[i] 存储了第i个桶中的记录数</span></span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	<span class="keyword">int</span> Radix = <span class="number">1</span>;							<span class="comment">// 模保持进位，用来取Array[j]的第i位排序码</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;d; i++)  &#123;					<span class="comment">// 分别对第i个排序码进行分配</span></span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;r; j++)					<span class="comment">// 初始计数器均为0</span></span><br><span class="line">			count[j] = <span class="number">0</span>;    </span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)	 &#123;				<span class="comment">// 统计每个桶中的记录数</span></span><br><span class="line">			k = (Array[j] / Radix) % r;		<span class="comment">// 取Array[j]的第i位排序码</span></span><br><span class="line">			count[k]++;						<span class="comment">// 相应计数器加1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;r; j++)					<span class="comment">// 将TempArray中的位置依次分配给r个桶</span></span><br><span class="line">			count[j] = count[j<span class="number">-1</span>] + count[j];</span><br><span class="line">		<span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;			<span class="comment">// 从数字尾部，把记录收集到相应桶 </span></span><br><span class="line">			k = (Array[j] / Radix ) % r;	<span class="comment">// 取Array[j]的第i位排序码</span></span><br><span class="line">			count[k]--;						<span class="comment">// 使用了第k个桶的一个位置，桶剩余量的计数器减1</span></span><br><span class="line">			TempArray[count[k]] = Array[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)					<span class="comment">// 将临时数组中的内容复制到Array中</span></span><br><span class="line">			Array[j] = TempArray[j];         </span><br><span class="line">		Radix *= r;							<span class="comment">// 往左进一位，修改模Radix</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StaticQueue-RadixSort-h"><a href="#StaticQueue-RadixSort-h" class="headerlink" title="StaticQueue_RadixSort.h"></a>StaticQueue_RadixSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//基于静态链的基数排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结点类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Elem int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Elem key;    <span class="comment">//结点的关键码值</span></span><br><span class="line">    <span class="keyword">int</span> next;    <span class="comment">//下一个结点在数组中的下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态队列类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链实现的基数排序，n为数组长度，d为排序码个数，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(Record *Array, <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>;                        <span class="comment">// first指向静态链中第一个记录</span></span><br><span class="line">    StaticQueue *<span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span> = <span class="keyword">new</span> StaticQueue[r];            <span class="comment">// 存放r个桶的静态队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)            <span class="comment">// 建链，初始为next域指向下一个记录</span></span><br><span class="line">        Array[i].next = i + <span class="number">1</span>;</span><br><span class="line">    Array[n - <span class="number">1</span>].next = <span class="number">-1</span>;                <span class="comment">// 链尾next为空</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; d; i++) &#123;            <span class="comment">// 对第i个排序码进行分配和收集，一共d趟</span></span><br><span class="line">        Distribute(Array, first, i, r, <span class="built_in">queue</span>);</span><br><span class="line">        Collect(Array, first, r, <span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">queue</span>;</span><br><span class="line"><span class="comment">//    PrintArray(Array, first);</span></span><br><span class="line">    AddrSort(Array, n, first);            <span class="comment">// 线性时间整理静态链表，使得数组按下标有序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配过程,A中存放待排序记录，first为静态链中的第一个记录,i为第i个排序码，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Distribute</span><span class="params">(Record *Array, <span class="keyword">int</span> first, <span class="keyword">int</span> i, <span class="keyword">int</span> r, StaticQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r; j++)                <span class="comment">// 初始化r个队列</span></span><br><span class="line">        <span class="built_in">queue</span>[j].head = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="number">-1</span>) &#123;                <span class="comment">// 对整个静态链进行分配	   </span></span><br><span class="line">        <span class="keyword">int</span> k = Array[first].key;        <span class="comment">// 取第i位排序码数字k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; i; a++)</span><br><span class="line">            k = k / r;</span><br><span class="line">        k = k % r;</span><br><span class="line">        <span class="comment">// 把Array[first]分配到第k个子序列中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[k].head == <span class="number">-1</span>)        <span class="comment">// 如果子序列为空，Array[first]就是第一个记录</span></span><br><span class="line">            <span class="built_in">queue</span>[k].head = first;</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">// 否则加到子序列的尾部</span></span><br><span class="line">            Array[<span class="built_in">queue</span>[k].tail].next = first;</span><br><span class="line">        <span class="built_in">queue</span>[k].tail = first;            <span class="comment">// first为子序列的尾部</span></span><br><span class="line">        first = Array[first].next;        <span class="comment">// 继续分配下一个记录 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集过程，Array中存放待排序记录，first为静态链中的第一个记录，r为基数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span><span class="params">(Record *Array, <span class="keyword">int</span> &amp;first, <span class="keyword">int</span> r, StaticQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last, k = <span class="number">0</span>;                        <span class="comment">// 已收集到的最后一个记录</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">queue</span>[k].head == <span class="number">-1</span>)        <span class="comment">// 找到第一个非空队列</span></span><br><span class="line">        k++;</span><br><span class="line">    first = <span class="built_in">queue</span>[k].head;</span><br><span class="line">    last = <span class="built_in">queue</span>[k].tail;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; r - <span class="number">1</span>) &#123;                    <span class="comment">// 继续收集下一个非空队列，若k==r-1则已是最后一个	</span></span><br><span class="line">        <span class="comment">// 找下一个非空队列</span></span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; r - <span class="number">1</span> &amp;&amp; <span class="built_in">queue</span>[k].head == <span class="number">-1</span>)    <span class="comment">// 当前队列k为空，而且k还不是最后的队列r-1</span></span><br><span class="line">            k++;                    <span class="comment">// 试探下一个队列</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[k].head != <span class="number">-1</span>) &#123;        <span class="comment">// 将这个非空序列与上一个非空序列连接起来		</span></span><br><span class="line">            Array[last].next = <span class="built_in">queue</span>[k].head;</span><br><span class="line">            last = <span class="built_in">queue</span>[k].tail;        <span class="comment">// 此时最后一个记录为这个序列的尾部记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Array[last].next = <span class="number">-1</span>;                <span class="comment">// 收集完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddrSort</span><span class="params">(Record *Array, <span class="keyword">int</span> n, <span class="keyword">int</span> first)</span> </span>&#123;    <span class="comment">// 线性时间整理静态链表，使得数组按下标有序</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    j = first;                    <span class="comment">// j待处理数据下标，第一次为first</span></span><br><span class="line">    Record TempRec;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;            <span class="comment">// 循环n-1次，每次处理第i大记录</span></span><br><span class="line">        TempRec = Array[j];        <span class="comment">// 暂存第i大的纪录</span></span><br><span class="line">        Array[j] = Array[i];            <span class="comment">// 当前下标i的数据存放到j位置</span></span><br><span class="line">        Array[i] = TempRec;        <span class="comment">// 第i大记录入位</span></span><br><span class="line">        Array[i].next = j;            <span class="comment">// 第i大的记录的next链要保留调换轨迹j</span></span><br><span class="line">        j = TempRec.next;            <span class="comment">//  j移动到下一位</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= i)            <span class="comment">// 若j比当前下标i小，则是轨迹，顺链找到数据</span></span><br><span class="line">            j = Array[j].next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="IndexSort-h"><a href="#IndexSort-h" class="headerlink" title="IndexSort.h"></a>IndexSort.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array[]为待排序数组，IndexArray[]为索引数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexSort</span><span class="params">(Record Array[], <span class="keyword">int</span> IndexArray[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) IndexArray[i] = i;    <span class="comment">// 初始化索引下标</span></span><br><span class="line">    <span class="comment">// 简单插入排序的地址排序过程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)                <span class="comment">// 依次插入第i个记录</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--)                <span class="comment">// 依次比较，发现逆置就交换</span></span><br><span class="line">            <span class="keyword">if</span> (Array[IndexArray[j]] &lt; Array[IndexArray[j - <span class="number">1</span>]])</span><br><span class="line">                swap(IndexArray, j, j - <span class="number">1</span>);  <span class="comment">// 交换Array[IndexArray[j]]和Array[IndexArray[j-1]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;                <span class="comment">// 此时i前面记录已排序</span></span><br><span class="line">    AdjustRecord(Array, IndexArray, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据IndexArray整理Array，IndexArray[]为索引数组，n为数组长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustRecord</span><span class="params">(Record Array[], <span class="keyword">int</span> IndexArray[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Record TempRec;                <span class="comment">// 只需要一个临时存储空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;            <span class="comment">// 循环n-1次，每次处理数组中第i个记录</span></span><br><span class="line">        <span class="keyword">int</span> j = i;                    <span class="comment">// j为临时变量，是循环链中的当前元素</span></span><br><span class="line">        TempRec = Array[i];            <span class="comment">// 暂存i下标中目前的纪录</span></span><br><span class="line">        <span class="keyword">while</span> (IndexArray[j] != i) &#123;    <span class="comment">// 如果循环链中索引下标还不是i，则顺链循环调整</span></span><br><span class="line">            <span class="keyword">int</span> k = IndexArray[j];        <span class="comment">// k为链接j指向的下标</span></span><br><span class="line">            Array[j] = Array[k];        <span class="comment">// 把k下标中的值复制到j位置，第j大元素正确归位</span></span><br><span class="line">            IndexArray[j] = j;        <span class="comment">// 因为是正确归位，索引j就是自身</span></span><br><span class="line">            j = k;                    <span class="comment">// j换到下一个，继续处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        Array[j] = TempRec;            <span class="comment">// 最后找到的j，它的索引下标值为i，因此第i大元素正确入位</span></span><br><span class="line">        IndexArray[j] = j;                <span class="comment">// 因为是正确归位，索引j就是自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九-文件管理和外排序"><a href="#九-文件管理和外排序" class="headerlink" title="九    文件管理和外排序"></a>九    文件管理和外排序</h2><h3 id="Buffer-h"><a href="#Buffer-h" class="headerlink" title="Buffer.h"></a>Buffer.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************  Buffer.h  *****************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE  100  <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T *L;        <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> nLen;    <span class="comment">// 缓冲大小</span></span><br><span class="line">    <span class="keyword">int</span> nCurr;   <span class="comment">// 当前指针，初始化为0</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Buffer() &#123;</span><br><span class="line">        L = <span class="literal">NULL</span>;</span><br><span class="line">        nLen = <span class="number">0</span>;</span><br><span class="line">        nCurr = <span class="number">0</span>;</span><br><span class="line">    &#125;;  <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                             <span class="comment">//空否</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;                              <span class="comment">//满否</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T e)</span></span>;                            <span class="comment">//插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(FILE *fp)</span></span>;                       <span class="comment">//将缓冲区写回到文件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Buffer&lt;T&gt;::isEmpty() &#123;  <span class="comment">//空否</span></span><br><span class="line">    <span class="keyword">if</span> (nCurr == nLen)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Buffer&lt;T&gt;::isFull() &#123;   <span class="comment">//满否</span></span><br><span class="line">    <span class="keyword">if</span> (nLen == BUFFER_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::insert(T e) &#123;  <span class="comment">//插入数据</span></span><br><span class="line">    <span class="keyword">if</span> (nLen &lt; BUFFER_SIZE)</span><br><span class="line">        L[nLen++] = e;</span><br><span class="line"><span class="comment">// 	cout&lt;&lt;&quot;buffer insert!&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::read(T &amp;e) &#123;     <span class="comment">//读出数据</span></span><br><span class="line">    e = L[nCurr++];</span><br><span class="line"><span class="comment">//	cout&lt;&lt; &quot;Buffer read out.&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Buffer&lt;T&gt;::flush(FILE *fp) &#123;  <span class="comment">//将缓冲区写回到文件</span></span><br><span class="line">    fwrite(L, <span class="keyword">sizeof</span>(T), nLen, fp);</span><br><span class="line">    nLen = <span class="number">0</span>;</span><br><span class="line">    nCurr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillBuffer</span><span class="params">(FILE *fp, Buffer&lt;T&gt; b)</span> </span>&#123;    <span class="comment">//填充数据</span></span><br><span class="line">    b.nLen = fread(b.L, <span class="keyword">sizeof</span>(T), BUFFER_SIZE, fp);</span><br><span class="line">    b.nCurr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ReplacementSelection-cpp"><a href="#ReplacementSelection-cpp" class="headerlink" title="ReplacementSelection.cpp"></a>ReplacementSelection.cpp</h3><p><a herf="#MinHeap-h">#include “MinHeap.h”</a></p>
<p><a herf="#Buffer-h">#include “Buffer.h”</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX   7  <span class="comment">// 堆大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************  file operation ****************//</span></span><br><span class="line"><span class="comment">// 函数功能：初始化文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initFiles</span><span class="params">(FILE *&amp;inputFile, FILE *&amp;outputFile, <span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">const</span> <span class="keyword">char</span> *out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((inputFile = fopen(in, <span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open file!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((outputFile = fopen(out, <span class="string">&quot;rb+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cannot open file!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化堆里的数据，从磁盘文件读n个数据置入数组A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMinHeapArry</span><span class="params">(FILE *inputFile, <span class="keyword">int</span> n, T *A)</span> </span>&#123;</span><br><span class="line">    fread(A, <span class="keyword">sizeof</span>(BYTE), n, inputFile);</span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;file read!!!&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：初始化input buffer, 读入一部分数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;input, FILE *inputFile)</span> </span>&#123;</span><br><span class="line">    input.L = (BYTE *) <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(input.L, <span class="literal">NULL</span>, BUFFER_SIZE);</span><br><span class="line">    input.nLen = fread(input.L, <span class="keyword">sizeof</span>(BYTE), BUFFER_SIZE, inputFile);</span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;InputBuffer initialised!!&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initOutputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;output)</span> </span>&#123;</span><br><span class="line">    output.L = (BYTE *) <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：把mval输出到输出缓冲区，同时出来因缓冲区空或者满的情况</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendToOutputBuffer</span><span class="params">(Buffer&lt;T&gt; &amp;input, Buffer&lt;T&gt; &amp;output, FILE *inputFile, FILE *outputFile, T mval)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出缓冲区满，写文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output.isFull()) &#123;</span><br><span class="line">        output.flush(outputFile); <span class="comment">// 不满，写缓冲</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;&quot;out buffer is full.&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output.insert(mval);         <span class="comment">// 输入缓冲区空，读文件到缓冲</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;output.insert(mval)&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span> (input.isEmpty() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!feof(inputFile)) &#123;</span><br><span class="line">            <span class="comment">// 文件没有结束</span></span><br><span class="line">            fillBuffer(inputFile, input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：比较大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less</span><span class="params">(T r, T mval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; mval)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：算法结束，处理输入输出缓冲区</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endUp</span><span class="params">(Buffer&lt;T&gt; output, FILE *inputFile, FILE *outputFile)</span> </span>&#123;</span><br><span class="line">    fwrite(output.L, <span class="keyword">sizeof</span>(BYTE), output.nLen, outputFile);</span><br><span class="line">    fclose(inputFile);</span><br><span class="line">    fclose(outputFile);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;output file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replacementSelection</span><span class="params">(T *A, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">const</span> <span class="keyword">char</span> *out)</span> </span>&#123;</span><br><span class="line">    T mval;  <span class="comment">//存放最小值堆的最小值</span></span><br><span class="line">    T r;     <span class="comment">//存放从输入缓冲区中读入的元素	</span></span><br><span class="line">    FILE *inputFile;                   <span class="comment">//输入文件句柄</span></span><br><span class="line">    FILE *outputFile;                  <span class="comment">//输出文件句柄	</span></span><br><span class="line">    Buffer&lt;T&gt; input;                   <span class="comment">//输入buffer</span></span><br><span class="line">    Buffer&lt;T&gt; output;                  <span class="comment">//输出buffer	</span></span><br><span class="line"></span><br><span class="line">    initFiles(inputFile, outputFile, in, out);  <span class="comment">//初始化输入输出文件</span></span><br><span class="line">    <span class="comment">//初始化堆的数据，从磁盘文件读入n个数据置入数组A</span></span><br><span class="line">    initMinHeapArry(inputFile, n, A);  <span class="comment">//从磁盘文件读入n个数据到堆数组A</span></span><br><span class="line">    <span class="function">MinHeap&lt;T&gt; <span class="title">H</span><span class="params">(A, n)</span></span>;          <span class="comment">//建立最小值堆</span></span><br><span class="line">    initInputBuffer(input, inputFile);    <span class="comment">//初始化input buffer，读入一部分数据</span></span><br><span class="line">    initOutputBuffer(output);      <span class="comment">//初始化Output buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> last = (n - <span class="number">1</span>); last &gt;= <span class="number">0</span>;) &#123;   <span class="comment">//堆不为空，就做这个循环</span></span><br><span class="line">        mval = H.heapArray[<span class="number">0</span>];       <span class="comment">//堆的最小值</span></span><br><span class="line">        <span class="comment">//mval = H.RemoveMin();</span></span><br><span class="line">        <span class="comment">//把mval送到输出缓冲区，同时处理因缓冲区空或满造成的各种情形</span></span><br><span class="line"></span><br><span class="line">        sendToOutputBuffer(input, output, inputFile, outputFile, mval);</span><br><span class="line"></span><br><span class="line">        input.read(r);  <span class="comment">//从输入缓冲区读入一个记录</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!less(r, mval)) &#123;    <span class="comment">// r值大于等于刚输出值，r入堆根</span></span><br><span class="line">            H.heapArray[<span class="number">0</span>] = r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// r不能入堆，暂存待处理</span></span><br><span class="line">            H.heapArray[<span class="number">0</span>] = H.heapArray[last];  <span class="comment">// 用last位置的记录代替根结点</span></span><br><span class="line">            H.heapArray[last] = r;                <span class="comment">// 把r放到last位置</span></span><br><span class="line">            H.setSize(last);                    <span class="comment">// 堆规模缩小1</span></span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (last != <span class="number">0</span>) &#123;       <span class="comment">//重新排列堆</span></span><br><span class="line">            H.SiftDown(<span class="number">0</span>);  <span class="comment">//把根结点记录下降到合适的位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//endfor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法结束工作：处理输出缓冲区，输入/输出文件</span></span><br><span class="line">    endUp(output, inputFile, outputFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> in[] = <span class="string">&quot;file_in.txt&quot;</span>;   <span class="comment">// 输入文件名称</span></span><br><span class="line">    <span class="keyword">char</span> out[] = <span class="string">&quot;file_out.txt&quot;</span>; <span class="comment">// 输出文件名称</span></span><br><span class="line">    <span class="keyword">int</span> n = MAX; <span class="comment">// 数组元素个数，即内存数目 </span></span><br><span class="line">    BYTE *A = <span class="keyword">new</span> BYTE[MAX];</span><br><span class="line">    replacementSelection(A, n, in, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WinnerTree-h"><a href="#WinnerTree-h" class="headerlink" title="WinnerTree.h"></a>WinnerTree.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//****************   WinnerTree.h   *****************//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 8        <span class="comment">//选手数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WinnerTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WinnerTree(<span class="keyword">int</span> TreeSize = MAX);</span><br><span class="line"></span><br><span class="line">    ~WinnerTree() &#123; <span class="keyword">delete</span>[] B; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;  <span class="comment">//初始化赢者树</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (n) ? B[<span class="number">1</span>] : <span class="number">0</span>; &#125;     <span class="comment">////返回最终胜者的索引，在赢者树中这个索引放在B[1]中</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (i &lt; n) ? B[i] : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RePlay</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>; <span class="comment">//位置i的外部选手改变后重构赢者树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Play</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> MaxSize;     <span class="comment">//允许的最大选手数</span></span><br><span class="line">    <span class="keyword">int</span> n;             <span class="comment">//当前选手数</span></span><br><span class="line">    <span class="keyword">int</span> LowExt;         <span class="comment">//最底层外部结点数</span></span><br><span class="line">    <span class="keyword">int</span> offset;         <span class="comment">//最底层外部结点之上的结点总数</span></span><br><span class="line">    <span class="keyword">int</span> *B;          <span class="comment">//赢者树数组，实际存放的是下标</span></span><br><span class="line">    T *L;            <span class="comment">//元素数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">WinnerTree&lt;T&gt;::WinnerTree(<span class="keyword">int</span> TreeSize) &#123;</span><br><span class="line">    MaxSize = TreeSize;</span><br><span class="line">    B = <span class="keyword">new</span> <span class="keyword">int</span>[MaxSize];</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化赢者树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Initialize(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MaxSize || size &lt; <span class="number">2</span>)   <span class="comment">//能否处理size个选手的数组A[]</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    n = size;                   <span class="comment">//初始化成员变量</span></span><br><span class="line">    L = A;</span><br><span class="line">    <span class="keyword">int</span> i, s;</span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">1</span>; <span class="number">2</span> * s &lt;= n - <span class="number">1</span>; s += s);  <span class="comment">//计算 s = 2^log(n-1)</span></span><br><span class="line">    LowExt = <span class="number">2</span> * (n - s);</span><br><span class="line">    offset = <span class="number">2</span> * s - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= LowExt; i += <span class="number">2</span>)     <span class="comment">//最底层外部结点的比赛</span></span><br><span class="line">        Play((offset + i) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner);</span><br><span class="line"><span class="comment">//处理其余外部结点</span></span><br><span class="line"><span class="comment">//若n为奇数，内部结点和外部结点比赛。这里用L[LowExt+1]和它的父结点比赛</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">        Play(n / <span class="number">2</span>, B[n - <span class="number">1</span>], LowExt + <span class="number">1</span>, winner);</span><br><span class="line">        i = LowExt + <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        i = LowExt + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="number">2</span>)        <span class="comment">//剩余外部结点的比赛</span></span><br><span class="line">        Play((i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从内部结点B[p]处开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Play(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    B[p] = winner(L, lc, rc);        <span class="comment">//胜者索引放在B[p]中</span></span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; p % <span class="number">2</span>) &#123;     <span class="comment">//右孩子，需要沿路径继续向上比赛</span></span><br><span class="line">        B[p / <span class="number">2</span>] = winner(L, B[p - <span class="number">1</span>], B[p]);</span><br><span class="line">        p /= <span class="number">2</span>;  <span class="comment">//父结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数RePlay负责选手i的值改变后重新开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::RePlay(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p, lc, rc;        <span class="comment">//比赛结点极其左右孩子的下标</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= LowExt) &#123;        <span class="comment">//从最底层开始</span></span><br><span class="line">        p = (offset + i) / <span class="number">2</span>;</span><br><span class="line">        lc = <span class="number">2</span> * p - offset; <span class="comment">// left child of p</span></span><br><span class="line">        rc = lc + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * p == n - <span class="number">1</span>) &#123;</span><br><span class="line">            lc = B[<span class="number">2</span> * p];</span><br><span class="line">            rc = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lc = <span class="number">2</span> * p - n + <span class="number">1</span> + LowExt;</span><br><span class="line">            rc = lc + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B[p] = winner(L, lc, rc);     <span class="comment">//B[p]中保存赢者的索引</span></span><br><span class="line">    <span class="comment">//完成剩下的比赛</span></span><br><span class="line">    p /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &gt;= <span class="number">1</span>; p /= <span class="number">2</span>)       <span class="comment">//沿路径向上比赛</span></span><br><span class="line">        B[p] = winner(L, B[<span class="number">2</span> * p], B[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> WinnerTree&lt;T&gt;::Output() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前选手数(size) = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 最底层外部结点数(LowExt) = &quot;</span> &lt;&lt; LowExt</span><br><span class="line">         &lt;&lt; <span class="string">&quot; 最底层外部结点之上的结点总数(Offset) = &quot;</span> &lt;&lt; offset &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;赢者树B:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回赢者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A[b] &lt;= A[c])</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LooserTree-h"><a href="#LooserTree-h" class="headerlink" title="LooserTree.h"></a>LooserTree.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//**************   LooserTree.h   ***************//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：返回赢者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[b] &lt;= A[c] ? b : c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：返回败者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loser</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A[b] &gt; A[c] ? b : c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoserTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LoserTree(<span class="keyword">int</span> Treesize);</span><br><span class="line"></span><br><span class="line">    ~LoserTree() &#123; <span class="keyword">delete</span>[] B; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Winner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RePlay</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Play</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c), <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部结点从右分支向上比赛</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize; <span class="comment">// 最大选手数</span></span><br><span class="line">    <span class="keyword">int</span> n;   <span class="comment">// 当前选手数</span></span><br><span class="line">    <span class="keyword">int</span> LowExt;  <span class="comment">// 最底层外部结点数 lowest-level external nodes</span></span><br><span class="line">    <span class="keyword">int</span> offset;  <span class="comment">// 最底层外部结点之上的结点数 2^k - 1</span></span><br><span class="line">    <span class="keyword">int</span> *B;   <span class="comment">// 赢者数数组 array for winner tree</span></span><br><span class="line">    T *L;   <span class="comment">// 选手数组 element array</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">LoserTree&lt;T&gt;::LoserTree(<span class="keyword">int</span> TreeSize) &#123;</span><br><span class="line">    MaxSize = TreeSize;</span><br><span class="line">    B = <span class="keyword">new</span> <span class="keyword">int</span>[MaxSize];</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Winner，返回最终胜者的索引，在败者树中这个索引存放在B[0]中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> LoserTree&lt;T&gt;::Winner() &#123;  <span class="comment">// 返回最终胜者的索引B[0]</span></span><br><span class="line">    <span class="keyword">return</span> (n) ? B[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Initilalize负责初始化败者树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Initialize(T A[], <span class="keyword">int</span> size, <span class="keyword">int</span>(*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                              <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;<span class="comment">// 初始化败者树</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MaxSize || size &lt; <span class="number">2</span>) &#123;        <span class="comment">//能否处理size个选手的数组a[]</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bad Input!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = size;                    <span class="comment">//初始化成员变量</span></span><br><span class="line">    L = A;</span><br><span class="line">    <span class="keyword">int</span> i, s;</span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">1</span>; <span class="number">2</span> * s &lt;= n - <span class="number">1</span>; s += s);    <span class="comment">//计算s = 2^log(n-1)</span></span><br><span class="line">    LowExt = <span class="number">2</span> * (n - s);</span><br><span class="line">    offset = <span class="number">2</span> * s - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最底层外部结点的比赛</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= LowExt; i += <span class="number">2</span>)     <span class="comment">// 最底层外部结点的比赛</span></span><br><span class="line">        Play((offset + i) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner, loser);</span><br><span class="line">    <span class="comment">//处理其余外部结点</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;           <span class="comment">// n为奇数，内部结点和外部结点比一次</span></span><br><span class="line">        Play(n / <span class="number">2</span>, B[(n - <span class="number">1</span>) / <span class="number">2</span>], LowExt + <span class="number">1</span>, winner, loser);<span class="comment">//暂存在父结点的左胜者与外部右子结点比</span></span><br><span class="line">        i = LowExt + <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        i = LowExt + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; i += <span class="number">2</span>)   <span class="comment">// 剩余外部结点的比赛</span></span><br><span class="line">        Play((i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>, i - <span class="number">1</span>, i, winner, loser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数Play负责在内部结点B[p]处开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Play(<span class="keyword">int</span> p, <span class="keyword">int</span> lc, <span class="keyword">int</span> rc, <span class="keyword">int</span>(*winner)(T A[],</span><br><span class="line">                                                            <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                        <span class="keyword">int</span>(*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;  <span class="comment">// 在内部结点从右分支向上比赛</span></span><br><span class="line">    B[p] = loser(L, lc, rc);       <span class="comment">//败者索引放在B[p]中			</span></span><br><span class="line">    <span class="keyword">int</span> temp1, temp2;</span><br><span class="line">    temp1 = winner(L, lc, rc);    <span class="comment">//p处的胜者索引</span></span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">1</span> &amp;&amp; p % <span class="number">2</span>) &#123;       <span class="comment">// p为奇数右孩子，沿路径继续向上比赛</span></span><br><span class="line">        temp2 = winner(L, temp1, B[p / <span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//p的胜者和p的父结点比较，赢者暂存在temp2中</span></span><br><span class="line">        B[p / <span class="number">2</span>] = loser(L, temp1, B[p / <span class="number">2</span>]);                <span class="comment">//败者索引放入B[p/2]</span></span><br><span class="line">        temp1 = temp2;         <span class="comment">// 胜者放入temp1</span></span><br><span class="line">        p /= <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    B[p / <span class="number">2</span>] = temp1;             <span class="comment">// B[p]是左孩子或者p=1，结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数RePlay负责选手i的值改变后重新开始比赛</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::RePlay(<span class="keyword">int</span> i, <span class="keyword">int</span> (*winner)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c),</span><br><span class="line">                          <span class="keyword">int</span> (*loser)(T A[], <span class="keyword">int</span> b, <span class="keyword">int</span> c)) &#123;  <span class="comment">// 选手i的值改变后，重新开始比赛</span></span><br><span class="line">    <span class="keyword">int</span> p;               <span class="comment">// 用于计算父结点索引的临时变量</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || i &gt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Out of Bounds!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确定父结点的位置</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= LowExt)</span><br><span class="line">        p = (i + offset) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p = (i - LowExt + n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    B[<span class="number">0</span>] = winner(L, i, B[p]);         <span class="comment">//B[0]中始终保存胜者的索引</span></span><br><span class="line">    B[p] = loser(L, i, B[p]);          <span class="comment">//B[p]中保存败者的索引</span></span><br><span class="line">    <span class="keyword">for</span> (; (p / <span class="number">2</span>) &gt;= <span class="number">1</span>; p /= <span class="number">2</span>) &#123;          <span class="comment">//沿路径向上比赛</span></span><br><span class="line">        <span class="keyword">int</span> temp;<span class="comment">//临时存放赢者的索引</span></span><br><span class="line">        temp = winner(L, B[p / <span class="number">2</span>], B[<span class="number">0</span>]);</span><br><span class="line">        B[p / <span class="number">2</span>] = loser(L, B[p / <span class="number">2</span>], B[<span class="number">0</span>]);</span><br><span class="line">        B[<span class="number">0</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数功能：输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> LoserTree&lt;T&gt;::Output() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前选手数(size) = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 最底层外部结点数(LowExt) = &quot;</span> &lt;&lt; LowExt</span><br><span class="line">         &lt;&lt; <span class="string">&quot; 最底层外部结点之上的结点总数(Offset) = &quot;</span> &lt;&lt; offset &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;败者树B（B0存放胜者下标）: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十-检索"><a href="#十-检索" class="headerlink" title="十    检索"></a>十    检索</h2><h3 id="Search-cpp"><a href="#Search-cpp" class="headerlink" title="Search.cpp"></a>Search.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Item(Type value) : key(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;         <span class="comment">//获取关键码值;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(Type k)</span> </span>&#123;</span><br><span class="line">        key = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type key;                           <span class="comment">//关键码域</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//其它域;                              //其它域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = length;</span><br><span class="line">    datavector[<span class="number">0</span>]-&gt;setKey(k);        <span class="comment">//将第0个元素设为待检索值</span></span><br><span class="line">    <span class="keyword">while</span> (datavector[i]-&gt;getKey() != k)</span><br><span class="line">        i--;     <span class="comment">//从后往前逐个比较</span></span><br><span class="line">    <span class="keyword">return</span> i;           <span class="comment">//返回元素位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SimpleSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (datavector[i]-&gt;getKey() != k &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">        i--;     <span class="comment">//从后往前逐个比较</span></span><br><span class="line">    <span class="keyword">return</span> i;           <span class="comment">//返回元素位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinSearch</span><span class="params">(<span class="built_in">vector</span>&lt;Item&lt;Type&gt; *&gt; &amp;datavector, <span class="keyword">int</span> length, Type k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = length, mid;   <span class="comment">//low, high分别记录数组首尾位置</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; datavector[mid]-&gt;getKey())</span><br><span class="line">            high = mid - <span class="number">1</span>;               <span class="comment">//右缩检索区间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; datavector[mid]-&gt;getKey())</span><br><span class="line">            low = mid + <span class="number">1</span>;           <span class="comment">//左缩检索区间</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;                            <span class="comment">//检索成功，返回元素位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                 <span class="comment">//检索失败，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间变量与时间函数</span></span><br><span class="line"><span class="keyword">clock_t</span> tstart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Settime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tstart = clock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Gettime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>) ((<span class="keyword">double</span>) clock() - (<span class="keyword">double</span>) tstart) / (<span class="keyword">double</span>) CLOCKS_PER_SEC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt; Item&lt;<span class="keyword">int</span>&gt; * &gt; datavector(<span class="number">200001</span>);</span><br><span class="line"></span><br><span class="line">    Item&lt;<span class="keyword">int</span>&gt; *darray[<span class="number">200001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200001</span>; j++)</span><br><span class="line">        darray[j] = <span class="keyword">new</span> Item&lt;<span class="keyword">int</span>&gt;(j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Item&lt;<span class="keyword">int</span>&gt; *&gt;::iterator outputIterator = datavector.begin();</span><br><span class="line">    copy(darray, darray + <span class="number">200001</span>, outputIterator);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Settime();<span class="comment">//开始计时</span></span><br><span class="line">    k = SeqSearch(datavector, datavector.size() - <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&gt;监视哨顺序检索耗时 : &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Gettime() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Settime();<span class="comment">//开始计时</span></span><br><span class="line">    k = SimpleSearch(datavector, datavector.size() - <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&gt;一般顺序检索耗时 : &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Gettime() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>
<h3 id="BitSet-cpp"><a href="#BitSet-cpp" class="headerlink" title="BitSet.cpp"></a>BitSet.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySet</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ulong;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        NB = <span class="number">8</span> * <span class="keyword">sizeof</span>(ulong),            <span class="comment">//unsigned long数据类型的位的数目</span></span><br><span class="line">        LI = N == <span class="number">0</span> ? <span class="number">0</span> : (N - <span class="number">1</span>) / NB        <span class="comment">//数组最后一个元素的下标</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ulong A[LI + <span class="number">1</span>];                        <span class="comment">//存放位向量的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tidy</span><span class="params">(ulong X = <span class="number">0</span>)</span></span>;                    <span class="comment">//将数组中的每个元素设成X</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Trim</span><span class="params">()</span></span>;                            <span class="comment">//将不使用的位设成0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    mySet();                                <span class="comment">//构造函数</span></span><br><span class="line">    mySet(ulong X);</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">set</span><span class="params">()</span></span>;                        <span class="comment">//设置元素属性</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">set</span><span class="params">(<span class="keyword">size_t</span> P, <span class="keyword">bool</span> X = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">reset</span><span class="params">()</span></span>;                        <span class="comment">//把集合设为空</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">reset</span><span class="params">(<span class="keyword">size_t</span> P)</span></span>;                <span class="comment">//删除元素P</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">at</span><span class="params">(<span class="keyword">size_t</span> P)</span> <span class="keyword">const</span></span>;                <span class="comment">//属于运算</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> P) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">flip</span><span class="params">()</span></span>;                        <span class="comment">//求反</span></span><br><span class="line">    <span class="function">mySet&lt;N&gt; &amp;<span class="title">flip</span><span class="params">(<span class="keyword">size_t</span> P)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ulong <span class="title">to_ulong</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">to_string</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;                    <span class="comment">//计算集合内元素数目</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">size_t</span> P)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span> <span class="keyword">const</span></span>;                        <span class="comment">//判断集合是否包含元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">none</span><span class="params">()</span> <span class="keyword">const</span></span>;                        <span class="comment">//判断集合是否为空</span></span><br><span class="line"></span><br><span class="line">    mySet&lt;N&gt; <span class="keyword">operator</span>~() <span class="keyword">const</span>;                    <span class="comment">//非运算</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//交等于</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>|=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//并等于</span></span><br><span class="line">    mySet&lt;N&gt; &amp;<span class="keyword">operator</span>^=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R);    <span class="comment">//异或等于</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//等于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//不等</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//包含于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//真包含于</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//包含</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span>;    <span class="comment">//真包含</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//交运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) &amp;= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>|(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//并运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) |= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//差运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) &amp; ~R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> mySet&lt;N&gt; <span class="keyword">operator</span>^(<span class="keyword">const</span> mySet&lt;N&gt; &amp;L, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//异或运算</span></span><br><span class="line">        <span class="keyword">return</span> (mySet&lt;N&gt;(L) ^= R);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;O, <span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;        <span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> P = <span class="number">0</span>; P &lt; N; P++)</span><br><span class="line">            O &lt;&lt; (R.test(P) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (O);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> mySet&lt;N&gt;::Tidy(ulong X) &#123;   <span class="comment">//将数组中的每个元素设成X</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] = X;</span><br><span class="line">    <span class="keyword">if</span> (X != <span class="number">0</span>)</span><br><span class="line">        Trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> mySet&lt;N&gt;::Trim() &#123;            <span class="comment">//将不使用的位设成0</span></span><br><span class="line">    <span class="keyword">if</span> (N % NB != <span class="number">0</span>)</span><br><span class="line">        A[LI] &amp;= ((ulong) <span class="number">1</span> &lt;&lt; N % NB) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt;::mySet() &#123;                <span class="comment">//构造函数</span></span><br><span class="line">    Tidy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt;::mySet(ulong X) &#123;</span><br><span class="line">    Tidy();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> P = <span class="number">0</span>; X != <span class="number">0</span> &amp;&amp; P &lt; N; X &gt;&gt;= <span class="number">1</span>, ++P)</span><br><span class="line">        <span class="keyword">if</span> (X &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">set</span>(P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="built_in">set</span>() &#123;        <span class="comment">//设置元素属性</span></span><br><span class="line">    Tidy(~(ulong) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;size_t N&gt;	mySet&lt;N&gt;&amp; mySet&lt;N&gt;::set(size_t P)&#123;</span></span><br><span class="line"><span class="comment">	A[P / NB] |= (ulong)1 &lt;&lt; P % NB;</span></span><br><span class="line"><span class="comment">	return (*this); </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="built_in">set</span>(<span class="keyword">size_t</span> P, <span class="keyword">bool</span> X) &#123;</span><br><span class="line">    <span class="keyword">if</span> (X)                                    <span class="comment">// X为真，位向量中相应值设为1</span></span><br><span class="line">        A[P / NB] |= (ulong) <span class="number">1</span> &lt;&lt; (P % NB);        <span class="comment">// P对应的元素进行按位或运算</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A[P / NB] &amp;= ~((ulong) <span class="number">1</span> &lt;&lt; (P % NB));    <span class="comment">// X为假，位向量中相应值设为0</span></span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::reset() &#123;                <span class="comment">//把集合设置为空</span></span><br><span class="line">    Tidy();</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::reset(<span class="keyword">size_t</span> P) &#123;        <span class="comment">//把具体元素设置为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(P, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::at(<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;        <span class="comment">//属于运算</span></span><br><span class="line">    <span class="keyword">return</span> (test(P));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (test(P));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::flip() &#123;                <span class="comment">//求非运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] = ~A[I];</span><br><span class="line">    Trim();</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::flip(<span class="keyword">size_t</span> P) &#123;      <span class="comment">// 取反</span></span><br><span class="line">    A[P / NB] ^= (ulong) <span class="number">1</span> &lt;&lt; P % NB;</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mySet&lt;N&gt;::to_ulong() <span class="keyword">const</span> &#123; <span class="comment">// 转换为ulong类型</span></span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> mySet&lt;N&gt;::to_string() <span class="keyword">const</span> &#123;   <span class="comment">// 用0，1形式把集合内容输出到字符串</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> S;</span><br><span class="line">    S.reserve(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> P = N; <span class="number">0</span> &lt; P;)</span><br><span class="line">        S += test(--P) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> (S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">size_t</span> mySet&lt;N&gt;::count() <span class="keyword">const</span> &#123;      <span class="comment">//计算集合元素数目</span></span><br><span class="line">    <span class="keyword">size_t</span> V = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">for</span> (ulong X = A[I]; X != <span class="number">0</span>; X &gt;&gt;= <span class="number">4</span>)</span><br><span class="line">            V += <span class="string">&quot;\0\1\1\2\1\2\2\3&quot;</span>                        <span class="comment">//&quot;\0\1\1\2\1\2\2\3\1\2\2\3\2\3\3\4&quot;代表十六进制数0-F所包含1的数目的数组</span></span><br><span class="line">                 <span class="string">&quot;\1\2\2\3\2\3\3\4&quot;</span>[X &amp; <span class="number">0xF</span>];</span><br><span class="line">    <span class="keyword">return</span> (V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">size_t</span> mySet&lt;N&gt;::size() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::test(<span class="keyword">size_t</span> P) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((A[P / NB] &amp; ((ulong) <span class="number">1</span> &lt;&lt; P % NB)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::any() <span class="keyword">const</span> &#123;           <span class="comment">//判断集合是否包含元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">if</span> (A[I] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::none() <span class="keyword">const</span> &#123;          <span class="comment">//判断集合是否为空</span></span><br><span class="line">    <span class="keyword">return</span> (!any());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; mySet&lt;N&gt;::<span class="keyword">operator</span>~() <span class="keyword">const</span> &#123;    <span class="comment">//非运算</span></span><br><span class="line">    <span class="keyword">return</span> (mySet&lt;N&gt;(*<span class="keyword">this</span>).flip());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>&amp;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123; <span class="comment">//赋值交</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)            <span class="comment">// 从低位到高位</span></span><br><span class="line">        A[I] &amp;= R.A[I];                        <span class="comment">// 以ulong元素为单位按位交</span></span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>|=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123; <span class="comment">//并等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] |= R.A[I];</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line">mySet&lt;N&gt; &amp;mySet&lt;N&gt;::<span class="keyword">operator</span>^=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) &#123;  <span class="comment">//异或等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        A[I] ^= R.A[I];</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>==(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//等于运算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> I = LI; I &gt;= <span class="number">0</span>; I--)</span><br><span class="line">        <span class="keyword">if</span> (A[I] != R.A[I])</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>!=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//不等运算</span></span><br><span class="line">    <span class="keyword">return</span> (!(*<span class="keyword">this</span> == R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//包含于运算</span></span><br><span class="line">    <span class="keyword">return</span> ((mySet(*<span class="keyword">this</span>) |= R) == R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;   <span class="comment">//真包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((*<span class="keyword">this</span> &lt;= R) &amp;&amp; (*<span class="keyword">this</span> != R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;  <span class="comment">//包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((mySet(*<span class="keyword">this</span>) &amp;= R) == R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> mySet&lt;N&gt;::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> mySet&lt;N&gt; &amp;R) <span class="keyword">const</span> &#123;   <span class="comment">//真包含运算</span></span><br><span class="line">    <span class="keyword">return</span> ((*<span class="keyword">this</span> &gt;= R) &amp;&amp; (*<span class="keyword">this</span> != R));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  &amp;运算只是friend, LI属于未定义</span></span><br><span class="line"><span class="comment">template&lt;size_t N&gt;	 mySet&lt;N&gt; operator&amp;( const mySet&lt;N&gt;&amp; L,  const mySet&lt;N&gt;&amp; R) &#123;//交运算</span></span><br><span class="line"><span class="comment">	mySet&lt;N&gt; s = L;</span></span><br><span class="line"><span class="comment">	for (int I = LI; I &gt;= 0; I--)</span></span><br><span class="line"><span class="comment">		s.A[I] &amp;= R.A[I];</span></span><br><span class="line"><span class="comment">	return s; 	</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="hashtomb-h"><a href="#hashtomb-h" class="headerlink" title="hashtomb.h"></a>hashtomb.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashdict</span> </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Elem* HT;     <span class="comment">// 散列表</span></span><br><span class="line">  <span class="keyword">int</span> M;       <span class="comment">// 散列表大小</span></span><br><span class="line">   Elem TOMB;    <span class="comment">//墓碑</span></span><br><span class="line">  <span class="keyword">int</span> currcnt;  <span class="comment">// 现有元素数目</span></span><br><span class="line">  Elem EMPTY;  <span class="comment">// 空槽</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(Key K, <span class="keyword">int</span> i)</span> <span class="keyword">const</span> <span class="comment">// 探查函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> linear(i); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x % M; &#125; <span class="comment">// 散列函数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">char</span>* x)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 字符串散列函数</span></span><br><span class="line">    <span class="keyword">int</span> i, sum;</span><br><span class="line">    <span class="keyword">for</span> (sum=<span class="number">0</span>, i=<span class="number">0</span>; x[i] != <span class="string">&#x27;\0&#x27;</span>; i++) sum += (<span class="keyword">int</span>) x[i];</span><br><span class="line">    <span class="keyword">return</span>(sum % M);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">linear</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> i;&#125;        <span class="comment">//线性探查</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;                  <span class="comment">//二次探查</span></span><br><span class="line">	  <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> -(i*i/<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">else</span>       <span class="keyword">return</span> (i+<span class="number">1</span>)*(i+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">rehash</span> <span class="params">(Key K, <span class="keyword">int</span> i)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> x )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span>  x % M; &#125;  <span class="comment">//除余法</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ELFhash</span> <span class="params">( <span class="keyword">char</span>*  key )</span><span class="keyword">const</span> </span>&#123;</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">			  <span class="keyword">while</span>(*key) &#123; </span><br><span class="line">                      h = ( h &lt;&lt; <span class="number">4</span> ) + *key++;</span><br><span class="line">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> g = h&amp;<span class="number">0xF0000000</span>L;</span><br><span class="line">                      <span class="keyword">if</span> (g) h^= g &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                      h  = ~g;</span><br><span class="line">                        &#125;</span><br><span class="line">                  <span class="keyword">return</span> h % M;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   hashdict(<span class="keyword">int</span> sz, Elem e, Elem t)&#123;<span class="comment">// 构造函数, e用来定义空槽</span></span><br><span class="line">          M=sz; EMPTY= e; TOMB=t;</span><br><span class="line">          currcnt=<span class="number">0</span>; HT=<span class="keyword">new</span> Elem[sz];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++) HT[i]= EMPTY; </span><br><span class="line">&#125;</span><br><span class="line">  ~hashdict() &#123; <span class="keyword">delete</span> HT; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hashInsert</span><span class="params">(<span class="keyword">const</span> Elem&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hashSearch</span><span class="params">(<span class="keyword">const</span> Key&amp;, Elem&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Elem <span class="title">hashDelete</span><span class="params">(<span class="keyword">const</span> Key&amp; K)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> currcnt; &#125; <span class="comment">// 散列表中现有元素数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="hashtomb-cpp"><a href="#hashtomb-cpp" class="headerlink" title="hashtomb.cpp"></a>hashtomb.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Int.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../COMPARE.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HASHDICT.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> hashdict&lt;Key, Elem, KEComp, EEComp&gt;::</span><br><span class="line">hashSearch(<span class="keyword">const</span> Key &amp;K, Elem &amp;e) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(K);            <span class="comment">// home 保存K的基地址</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;           <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KEComp::eq(K, HT[pos])) &#123;  <span class="comment">// 发现目标</span></span><br><span class="line">            e = HT[pos];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(K, i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据元素e插入到散列表 HT</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> hashdict&lt;Key, Elem, KEComp, EEComp&gt;::hashInsert(<span class="keyword">const</span> Elem &amp;e) &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(getkey(e));        <span class="comment">// home记录基位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, insplace;</span><br><span class="line">    <span class="keyword">bool</span> tomb_pos = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;                <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (EEComp::eq(e, HT[pos]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不允许重复关键码</span></span><br><span class="line">        <span class="keyword">if</span> (EEComp::eq(TOMB, HT[pos]) &amp;&amp; !tomb_pos) &#123;</span><br><span class="line">            insplace = pos;                 <span class="comment">//记录第一个墓碑的位置   </span></span><br><span class="line">            tomb_pos = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(getkey(e), i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!tomb_pos)</span><br><span class="line">        insplace = pos;      <span class="comment">//如果没有墓碑，插入空位置</span></span><br><span class="line">    HT[insplace] = e;                  <span class="comment">//插入e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除算法：在检索函数的基础上进行了修改。</span></span><br><span class="line"><span class="comment">// 若检索失败，则无值可删；检索成功则将其设为墓碑。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Elem</span>, <span class="keyword">class</span> <span class="title">KEComp</span>, <span class="keyword">class</span> <span class="title">EEComp</span>&gt;</span></span><br><span class="line">Elem hashdict&lt;Key, Elem, KEComp, EEComp&gt;::hashDelete(<span class="keyword">const</span> Key &amp;K) &#123;</span><br><span class="line">    <span class="keyword">int</span> home = h(K);<span class="comment">// home记录基位置</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = home;        <span class="comment">// 探查序列的初始位置</span></span><br><span class="line">    Elem temp;</span><br><span class="line">    <span class="keyword">while</span> (!EEComp::eq(EMPTY, HT[pos])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KEComp::eq(K, HT[pos])) &#123;</span><br><span class="line">            temp = HT[pos];</span><br><span class="line">            HT[pos] = TOMB; <span class="comment">//设置墓碑</span></span><br><span class="line">            <span class="keyword">return</span> temp;    <span class="comment">//返回目标</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        pos = (home + p(K, i)) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EMPTY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getkey</span><span class="params">(Int *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;key();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getkey</span><span class="params">(<span class="keyword">char</span> *e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Intkey</span><span class="params">(Int &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e.key();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">charkey</span><span class="params">(<span class="keyword">char</span> *&amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    hashdict&lt;int, Int *, intIntsCompare, IntsIntsCompare&gt; dict(100, new Int(-1), new Int(-2));</span><br><span class="line">    Int *val;</span><br><span class="line"></span><br><span class="line">    dict.hashInsert(<span class="keyword">new</span> Int(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">if</span> (dict.hashSearch(<span class="number">10</span>, val))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;发现值 &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; 匹配关键码10\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有发现匹配关键码10的元素\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="十一-索引技术"><a href="#十一-索引技术" class="headerlink" title="十一    索引技术"></a>十一    索引技术</h2><h2 id="十二-高级数据结构"><a href="#十二-高级数据结构" class="headerlink" title="十二    高级数据结构"></a>十二    高级数据结构</h2><h3 id="SMatrix-h"><a href="#SMatrix-h" class="headerlink" title="SMatrix.h"></a>SMatrix.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用十字链表实现稀疏矩阵</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxtempl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> //(行、列、元素)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先定义节点类.T是节点存储的数据类型</span></span><br><span class="line"><span class="comment">//如果是头结点则不存储任何数值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;<span class="comment">//矩阵的行和列</span></span><br><span class="line">    T element;<span class="comment">//矩阵中存储的数据</span></span><br><span class="line">    OLNode&lt;T&gt; *right, *down;<span class="comment">//指向下一个节点的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OLNode() &#123;</span><br><span class="line">        right = <span class="literal">NULL</span>;</span><br><span class="line">        down = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏矩阵</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rownum, colnum;<span class="comment">//行列数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateMatrix</span><span class="params">(CArray &lt;Element, Element&gt; &amp;Data)</span></span>;<span class="comment">//only for local use</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    OLNode&lt;T&gt; **rowhead, **colhead;<span class="comment">//矩阵的第一个非零元素</span></span><br><span class="line">    SMatrix();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MallocMem</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>; <span class="comment">//为矩阵收集内存</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetRownum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetColnum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateMatrix</span><span class="params">()</span></span>;<span class="comment">//建立矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FreeMem</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SMatrix&lt;<span class="keyword">int</span>&gt; *<span class="title">MatrixMutil</span><span class="params">(SMatrix&lt;<span class="keyword">int</span>&gt; *left, SMatrix&lt;<span class="keyword">int</span>&gt; *right)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SMatrix&lt;T&gt;::SMatrix() &#123;</span><br><span class="line">    rowhead = colhead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SMatrix&lt;T&gt;::GetRownum() &#123;</span><br><span class="line">    <span class="keyword">return</span> rownum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> SMatrix&lt;T&gt;::GetColnum() &#123;</span><br><span class="line">    <span class="keyword">return</span> colnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::MallocMem(<span class="keyword">int</span> row, <span class="keyword">int</span> col) &#123;</span><br><span class="line">    rownum = row;</span><br><span class="line">    colnum = col;</span><br><span class="line">    rowhead = <span class="keyword">new</span> OLNode&lt;T&gt; *[row + <span class="number">1</span>];</span><br><span class="line">    colhead = <span class="keyword">new</span> OLNode&lt;T&gt; *[col + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt;= row; count++) &#123;<span class="comment">//初始化为头结点</span></span><br><span class="line">        rowhead[count] = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        rowhead[count]-&gt;row = <span class="number">-1</span>;</span><br><span class="line">        rowhead[count]-&gt;col = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt;= col; count++) &#123;</span><br><span class="line">        colhead[count] = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        colhead[count]-&gt;row = <span class="number">-1</span>;</span><br><span class="line">        colhead[count]-&gt;col = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::CreateMatrix() &#123;</span><br><span class="line">    <span class="comment">//首先</span></span><br><span class="line">    <span class="keyword">if</span> ((rowhead != <span class="literal">NULL</span>) || (colnum != <span class="literal">NULL</span>))</span><br><span class="line">        FreeMem();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入矩阵的行数:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; rownum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入矩阵的列数:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; colnum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//为行列指针收集空间</span></span><br><span class="line">    MallocMem(rownum, colnum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入矩阵的元素，格式&lt;行，列，数据&gt;+回车,结束输入请输入-1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    T ele;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ele;</span><br><span class="line">        <span class="keyword">if</span> ((i &gt; rownum) || (j &gt; colnum) || (i &lt; <span class="number">1</span>) || (j &lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不正确的行，列号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OLNode&lt;T&gt; *temp = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">        temp-&gt;row = i;</span><br><span class="line">        temp-&gt;col = j;</span><br><span class="line">        temp-&gt;element = ele;</span><br><span class="line">        <span class="comment">//处理行指针</span></span><br><span class="line">        <span class="comment">//查找位置</span></span><br><span class="line">        OLNode&lt;T&gt; *t2 = rowhead[i];</span><br><span class="line">        OLNode&lt;T&gt; *t1 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (j &gt; t2-&gt;col)) &#123;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = t2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (t2-&gt;col == j)) &#123;<span class="comment">//修改值</span></span><br><span class="line">            t2-&gt;element = temp-&gt;element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入新的指针</span></span><br><span class="line">            t1-&gt;right = temp;</span><br><span class="line">            temp-&gt;right = t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理列指针</span></span><br><span class="line">        <span class="comment">//查找位置</span></span><br><span class="line">        t2 = colhead[j];</span><br><span class="line">        t1 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (i &gt; t2-&gt;row)) &#123;</span><br><span class="line">            t1 = t2;</span><br><span class="line">            t2 = t2-&gt;down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((t2 != <span class="literal">NULL</span>) &amp;&amp; (t2-&gt;row == i)) &#123;<span class="comment">//修改值</span></span><br><span class="line">            t2-&gt;element = temp-&gt;element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;     <span class="comment">//插入新的指针</span></span><br><span class="line">            t1-&gt;down = temp;</span><br><span class="line">            temp-&gt;down = t2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//end of while</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::PrintAll() &#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= rownum; i++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *temp = rowhead[i]-&gt;right;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= colnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;col == j)) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; temp-&gt;element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                temp = temp-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 0 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SMatrix&lt;T&gt;::FreeMem() &#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= rownum; i++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *temp = rowhead[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= colnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;col == j)) &#123;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> rowhead;</span><br><span class="line">    <span class="keyword">delete</span> colhead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">SMatrix&lt;<span class="keyword">int</span>&gt; *SMatrix&lt;T&gt;::MatrixMutil(SMatrix&lt;<span class="keyword">int</span>&gt; *left, SMatrix&lt;<span class="keyword">int</span>&gt; *right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left-&gt;GetColnum() != right-&gt;GetRownum())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//行列不匹配不能相乘</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> I = <span class="number">0</span>; <span class="comment">//第一个矩阵的行数</span></span><br><span class="line">    <span class="keyword">int</span> J = <span class="number">0</span>; <span class="comment">//第二个矩阵的列数</span></span><br><span class="line">    SMatrix&lt;T&gt; *ResultMatrix = <span class="keyword">new</span> SMatrix&lt;T&gt;();</span><br><span class="line">    ResultMatrix-&gt;MallocMem(left-&gt;GetRownum(), right-&gt;GetColnum());</span><br><span class="line">    <span class="keyword">for</span> (I = <span class="number">1</span>; I &lt;= left-&gt;GetRownum(); I++) &#123;</span><br><span class="line">        OLNode&lt;T&gt; *RowNext = ResultMatrix-&gt;rowhead[I];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (J = <span class="number">1</span>; J &lt;= right-&gt;GetColnum(); J++) &#123;</span><br><span class="line">            OLNode&lt;T&gt; *ColNext = ResultMatrix-&gt;colhead[J];</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            OLNode&lt;<span class="keyword">int</span>&gt; *rows = left-&gt;rowhead[I]-&gt;right;</span><br><span class="line">            OLNode&lt;<span class="keyword">int</span>&gt; *cols = right-&gt;colhead[J]-&gt;down;</span><br><span class="line">            <span class="keyword">if</span> ((rows == <span class="literal">NULL</span>) || (cols == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//新行没有非零元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((rows != <span class="literal">NULL</span>) &amp;&amp; (cols != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows-&gt;col &lt; cols-&gt;row) &#123;</span><br><span class="line">                    rows = rows-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rows-&gt;col &gt; cols-&gt;row) &#123;</span><br><span class="line">                    cols = cols-&gt;down;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//都有元素可以相乘</span></span><br><span class="line">                    result = result + cols-&gt;element * rows-&gt;element;</span><br><span class="line">                    cols = cols-&gt;down;</span><br><span class="line">                    rows = rows-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//插入到结果矩阵中</span></span><br><span class="line">            OLNode&lt;T&gt; *temp = <span class="keyword">new</span> OLNode&lt;T&gt;();</span><br><span class="line">            temp-&gt;row = I;</span><br><span class="line">            temp-&gt;col = J;</span><br><span class="line">            temp-&gt;element = result;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入一个新的元素到下一个位置</span></span><br><span class="line">            RowNext-&gt;right = temp;</span><br><span class="line">            RowNext = RowNext-&gt;right;</span><br><span class="line">            <span class="comment">//调转到合适的位置</span></span><br><span class="line">            <span class="keyword">while</span> (ColNext-&gt;down != <span class="literal">NULL</span>)</span><br><span class="line">                ColNext = ColNext-&gt;down;</span><br><span class="line">            ColNext-&gt;down = temp;</span><br><span class="line">            ColNext = ColNext-&gt;down;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//计算出一个元素，放入ResultMatrix</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/////////////////乘法做完，生成新的矩阵</span></span><br><span class="line">    <span class="keyword">return</span> ResultMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GenList-h"><a href="#GenList-h" class="headerlink" title="GenList.h"></a>GenList.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广义表的链表实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATOM 0  <span class="comment">//表中存储的是原子元素</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST 1  <span class="comment">//表中存储的是子表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD -1  <span class="comment">//是否是表头结点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VISITED 1  <span class="comment">//已经访问过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNVISITED 0  <span class="comment">//未访问过</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BACKTRACE 1  <span class="comment">//需要回溯</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTBACKTRACE 0  <span class="comment">//不需要回溯</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxName 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广义表的结点类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> type;   <span class="comment">//表示该结点是ATOM or LIST</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> ref;   <span class="comment">//如果是表头结点则，存储该结点被几个结点所指向</span></span><br><span class="line">            <span class="keyword">char</span> *Name;  <span class="comment">// 表头名称</span></span><br><span class="line">            <span class="keyword">int</span> mark;   <span class="comment">// 本子表是否被访问过</span></span><br><span class="line">        &#125; headNode;</span><br><span class="line">        GenListNode&lt;T&gt; *child;<span class="comment">//如果是LIST ,则指向它的元素的首结点</span></span><br><span class="line">        T element; <span class="comment">//如果是ATOM，则存储它的值</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    GenListNode&lt;T&gt; *next;<span class="comment">//指向下一个结点</span></span><br><span class="line">    GenListNode(T element);<span class="comment">//构造函数</span></span><br><span class="line">    GenListNode();</span><br><span class="line"></span><br><span class="line">    GenListNode(GenListNode&lt;T&gt; *<span class="built_in">list</span>);<span class="comment">//</span></span><br><span class="line">    ~GenListNode();<span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destory</span><span class="params">(GenListNode&lt;T&gt; *node)</span></span>;<span class="comment">//释放所有内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ViewAll</span><span class="params">()</span></span>;<span class="comment">//遍历该结点的子孙和兄弟</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenListTraversal</span><span class="params">()</span></span>;<span class="comment">//遍历该结点的子孙和兄弟，张铭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(GenListNode&lt;T&gt; *node, GenListNode&lt;T&gt; *prenode, <span class="keyword">int</span> &amp;flag)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenListTraversalHelp</span><span class="params">(GenListNode&lt;T&gt; *node)</span></span>;  <span class="comment">// 张铭</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//GenList是一个原子元素类型为T的广义表</span></span><br><span class="line"><span class="comment">//如果要实现能够存储多种数据类型的广义</span></span><br><span class="line"><span class="comment">//表，只需要嵌套的使用它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GenListNode&lt;T&gt; *head;<span class="comment">//整个广义表的头结点,不存储任何信息</span></span><br><span class="line">    GenListNode&lt;T&gt; *current;<span class="comment">//当前指针的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    GenList(<span class="keyword">char</span> *Name);</span><br><span class="line"></span><br><span class="line">    ~GenList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T element)</span></span>;<span class="comment">//在尾部加入一个元素结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(GenList&lt;T&gt; *gl)</span></span>;<span class="comment">//在尾部插入一个子表</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetHead</span><span class="params">()</span></span>;<span class="comment">//得到头结点的指针</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetNext</span><span class="params">()</span></span>;<span class="comment">//得到当前结点的下一个结点</span></span><br><span class="line">    <span class="function">GenListNode&lt;T&gt; *<span class="title">GetPrev</span><span class="params">()</span></span>;<span class="comment">//得到当前结点的前一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveToFirst</span><span class="params">()</span></span>;<span class="comment">//当前指针指向head</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Remove</span><span class="params">()</span></span>;<span class="comment">//删除当前结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">View</span><span class="params">()</span></span>;<span class="comment">//遍历广义表，伍赛</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ViewList</span><span class="params">()</span></span>;<span class="comment">//遍历广义表, 张铭</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="GenListFunction-h"><a href="#GenListFunction-h" class="headerlink" title="GenListFunction.h"></a>GenListFunction.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广义表的类实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GenList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//GenListNode的构造函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">GenListNode&lt;T&gt;::GenListNode(GenListNode&lt;T&gt; *list)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	//</span></span><br><span class="line"><span class="comment">	type=LIST;</span></span><br><span class="line"><span class="comment">    child=list;</span></span><br><span class="line"><span class="comment">	next=NULL;</span></span><br><span class="line"><span class="comment">	mark=0;</span></span><br><span class="line"><span class="comment">	ref=0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">GenListNode&lt;T&gt;::GenListNode(T element)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	    type=ATOM;</span></span><br><span class="line"><span class="comment">		child=NULL;</span></span><br><span class="line"><span class="comment">		this-&gt;element=element;</span></span><br><span class="line"><span class="comment">		next=NULL;</span></span><br><span class="line"><span class="comment">		mark=0;</span></span><br><span class="line"><span class="comment">		ref=0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt;::GenListNode() &#123;</span><br><span class="line">    type = LIST;</span><br><span class="line">    child = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GenListNode的析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt;::~GenListNode() &#123;</span><br><span class="line">    <span class="comment">//free all the memery </span></span><br><span class="line">    Destroy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::Destory(GenListNode&lt;T&gt; *node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        Destroy(node-&gt;next);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;child != <span class="literal">NULL</span>)</span><br><span class="line">        Destroy(node-&gt;child);</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">void GenListNode&lt;T&gt;::Search(GenListNode&lt;T&gt; *node,GenListNode&lt;T&gt; *prenode,int &amp;flag) </span></span><br><span class="line"><span class="comment">&#123;   //flag 为回溯标志</span></span><br><span class="line"><span class="comment">	if (node-&gt;type==HEAD)	&#123;//进入一个表头结点，准备访问它的子表</span></span><br><span class="line"><span class="comment">		node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		Search(node-&gt;next,node,flag);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	else	&#123;//非表头结点，访问每一个element结点</span></span><br><span class="line"><span class="comment">      if (node-&gt;type==ATOM) &#123;</span></span><br><span class="line"><span class="comment">		cout&lt;&lt;node-&gt;element;</span></span><br><span class="line"><span class="comment">		node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">	    &#125; </span></span><br><span class="line"><span class="comment">      else if(node-&gt;type==LIST) &#123;</span></span><br><span class="line"><span class="comment">			node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">			cout&lt;&lt;&quot;(&quot;;</span></span><br><span class="line"><span class="comment">			Search(node-&gt;child,node,flag);</span></span><br><span class="line"><span class="comment">			cout&lt;&lt;&quot;)&quot;;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">      if((node-&gt;next!=NULL)&amp;&amp;(node-&gt;next-&gt;mark!=VISITED)) &#123;//没有访问过，则继续访问</span></span><br><span class="line"><span class="comment">		  cout&lt;&lt;&quot;,&quot;;</span></span><br><span class="line"><span class="comment">		  node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		  Search(node-&gt;next,node,flag);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	  else if((node-&gt;next!=NULL)&amp;&amp;(node-&gt;type==ATOM))  //否则访问过，回溯</span></span><br><span class="line"><span class="comment">		      flag=BACKTRACE; //mark==VISITED，需要进行回溯</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	  if(flag==BACKTRACE)	&#123;//回溯操作</span></span><br><span class="line"><span class="comment">		  node-&gt;mark=UNVISITED;</span></span><br><span class="line"><span class="comment">		  if(prenode==NULL) 	&#123;//回溯到第一个结点，结束</span></span><br><span class="line"><span class="comment">			 flag=NOTBACKTRACE;</span></span><br><span class="line"><span class="comment">			 return;</span></span><br><span class="line"><span class="comment">		  &#125;</span></span><br><span class="line"><span class="comment">		  if((prenode-&gt;child=node)&amp;&amp;(prenode-&gt;next!=NULL)&amp;&amp;(prenode-&gt;next-&gt;mark==0)) &#123;//回溯到可以进入其他子链的地方</span></span><br><span class="line"><span class="comment">			 flag=NOTBACKTRACE;</span></span><br><span class="line"><span class="comment">			 return;</span></span><br><span class="line"><span class="comment">		  &#125;</span></span><br><span class="line"><span class="comment">	   &#125;	</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	//将刚才进入子链的mark值重新置为UNVISITED</span></span><br><span class="line"><span class="comment">	GenListNode&lt;T&gt;*temp=node;</span></span><br><span class="line"><span class="comment">	while(temp!=NULL)	&#123;</span></span><br><span class="line"><span class="comment">		temp-&gt;mark=UNVISITED;</span></span><br><span class="line"><span class="comment">		temp=temp-&gt;next;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::GenListTraversalHelp(GenListNode&lt;T&gt; *node) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *p;</span><br><span class="line">    node-&gt;headNode.mark = VISITED;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = node-&gt;next; p != <span class="literal">NULL</span>; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//p-&gt;mark=VISITED;</span></span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;type == LIST) &amp;&amp; (p-&gt;child != <span class="literal">NULL</span>)) &#123;    <span class="comment">//进入一个表头结点，准备访问它的子表</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;child-&gt;headNode.Name;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;child-&gt;headNode.mark == UNVISITED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;child-&gt;headNode.Name[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">                GenListTraversalHelp(p-&gt;child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;type == ATOM)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;element;</span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (p-&gt;next-&gt;type != HEAD))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">void GenListNode&lt;T&gt;::GenListTraversalHelp(GenListNode&lt;T&gt; *node) </span></span><br><span class="line"><span class="comment">&#123;   //flag 为回溯标志</span></span><br><span class="line"><span class="comment">	GenListNode&lt;T&gt; *p;</span></span><br><span class="line"><span class="comment">	node-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;(&quot;;</span></span><br><span class="line"><span class="comment">	for (p = node-&gt;next; (p!=NULL)&amp;&amp;(p-&gt;type!=HEAD); p=p-&gt;next) &#123;</span></span><br><span class="line"><span class="comment">		p-&gt;mark=VISITED;</span></span><br><span class="line"><span class="comment">		if ((p-&gt;type==LIST)&amp;&amp;(p-&gt;child!=NULL)) &#123;	//进入一个表头结点，准备访问它的子表</span></span><br><span class="line"><span class="comment">			   cout &lt;&lt; p-&gt;child-&gt;headNode.Name;</span></span><br><span class="line"><span class="comment">			   if (p-&gt;child-&gt;mark == UNVISITED)  &#123;</span></span><br><span class="line"><span class="comment">				  if (p-&gt;child-&gt;headNode.Name[0]!=&#x27;\0&#x27;)</span></span><br><span class="line"><span class="comment">				  cout &lt;&lt;&quot;:&quot;;	</span></span><br><span class="line"><span class="comment">			      GenListTraversalHelp(p-&gt;child);</span></span><br><span class="line"><span class="comment">			   &#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else if (p-&gt;type==ATOM) </span></span><br><span class="line"><span class="comment">		    cout&lt;&lt;p-&gt;element;</span></span><br><span class="line"><span class="comment">		if ((p-&gt;next!=NULL)&amp;&amp;(p-&gt;next-&gt;type!=HEAD))</span></span><br><span class="line"><span class="comment">		    cout &lt;&lt; &quot;, &quot;;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;)&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::ViewAll() &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = NOTBACKTRACE;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    GenListTraversal(<span class="keyword">this</span>, <span class="literal">NULL</span>, flag);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广义表的构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenList&lt;T&gt;::GenList(<span class="keyword">char</span> *Name) &#123;</span><br><span class="line">    head = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;type = HEAD;</span><br><span class="line">    head-&gt;headNode.ref = <span class="number">0</span>;</span><br><span class="line">    head-&gt;headNode.Name = Name;</span><br><span class="line">    current = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//广义表的插入函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::Insert(T element) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    current = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    current-&gt;type = ATOM;</span><br><span class="line">    current-&gt;child = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;element = element;</span><br><span class="line">    temp-&gt;next = current;</span><br><span class="line">    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::Insert(GenList&lt;T&gt; *genlist) &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    GenListNode&lt;T&gt; *n = genlist-&gt;GetHead();</span><br><span class="line">    n-&gt;headNode.mark = UNVISITED;</span><br><span class="line">    n-&gt;headNode.ref++;</span><br><span class="line">    current = <span class="keyword">new</span> GenListNode&lt;T&gt;();</span><br><span class="line">    current-&gt;child = n;</span><br><span class="line">    current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    current-&gt;type = LIST;</span><br><span class="line">    temp-&gt;next = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到头指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetHead() &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到下一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetNext() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到当前结点的前一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenListNode&lt;T&gt; *GenList&lt;T&gt;::GetPrev() &#123;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == current)</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除当前结点,当前结点指针指向下一个结点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> GenList&lt;T&gt;::Remove() &#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (current == head)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    GenListNode&lt;T&gt; *prev = GetPrev();</span><br><span class="line">    GenListNode&lt;T&gt; *next = GetNext();</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">    GenListNode&lt;T&gt; *temp = current;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>)</span><br><span class="line">        current = prev;</span><br><span class="line">    <span class="keyword">else</span> current = next;</span><br><span class="line">    temp-&gt;Destory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move current point to head point</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::MoveToFirst() &#123;</span><br><span class="line">    current = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">GenList&lt;T&gt;::~GenList() &#123;</span><br><span class="line">    current = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (current != head)</span><br><span class="line">        Remove();</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::View() &#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;(&quot;;</span></span><br><span class="line">    MoveToFirst();</span><br><span class="line"><span class="comment">//	GenListNode&lt;T&gt; *temp=GetNext();</span></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    current-&gt;ViewAll();</span><br><span class="line">    <span class="comment">//temp=GetNext();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	cout&lt;&lt;&quot;)&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenList&lt;T&gt;::ViewList() &#123;</span><br><span class="line">    MoveToFirst();</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">    current-&gt;GenListTraversal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> GenListNode&lt;T&gt;::GenListTraversal() &#123;</span><br><span class="line">    GenListTraversalHelp(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVLNode-h"><a href="#AVLNode-h" class="headerlink" title="AVLNode.h"></a>AVLNode.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this is avl tree node </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">avlNode</span>//平衡二叉树结点类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    avlNode(T val);<span class="comment">//构造函数</span></span><br><span class="line">    avlNode(T val, avlNode&lt;T&gt; *left, avlNode&lt;T&gt; *right, <span class="keyword">int</span> bf);</span><br><span class="line"></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">copy</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//复制以当前结点为根的二叉树 ：(写多了，没用上)                           </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;<span class="comment">//删除以当前结点为根的左右子树									</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">(avlNode *)</span></span>;<span class="comment">//把当前结点的左指针修改为函数的参数</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">left</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//左子结点访问，返回左结点的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">(avlNode *v)</span></span>;<span class="comment">//把当前结点的右指针修改为函数的参数</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">right</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//右子结点访问，返回右结点的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(avlNode&lt;T&gt; *&amp;p, T val)</span></span>;<span class="comment">//插入一个值；返回新的avl树的根结点的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorderview</span><span class="params">(avlNode&lt;T&gt; *current, <span class="keyword">int</span> i = <span class="number">-1</span>)</span></span>;<span class="comment">//前序周游</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">remove</span><span class="params">(T val, avlNode&lt;T&gt; *&amp;waste, <span class="keyword">int</span> &amp;flag)</span></span>;<span class="comment">//删除以当前结点的为根的avl树中的val结点</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">findNodeValue</span><span class="params">(T val)</span></span>;<span class="comment">//查找val结点</span></span><br><span class="line">    T value;<span class="comment">//码值</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> bf;<span class="comment">// balance factor</span></span><br><span class="line">    avlNode&lt;T&gt; *leftptr;<span class="comment">//左右指针</span></span><br><span class="line">    avlNode&lt;T&gt; *rightptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//avlNode&lt;T&gt;* restoreLeftBalance(int oldbf);//删除时左子树失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="comment">//avlNode&lt;T&gt;* restoreRightBalance(int oldbf);//删除时右子树失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">removeLeftmostElement</span><span class="params">(avlNode&lt;T&gt; *&amp;childptr, <span class="keyword">int</span> &amp;flag)</span></span>;<span class="comment">//找到最左的结点</span></span><br><span class="line">    <span class="comment">//avlNode&lt;T&gt;* removeBalanceLeft();//从左子树删除的时候判断层数的改变</span></span><br><span class="line">    <span class="comment">//avlNode&lt;T&gt;* removeBalanceRight();//从右子树删除的时候判断层数的改变</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">LL_singleRotation</span><span class="params">()</span></span>;<span class="comment">//在插入时候左子树LL失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">RR_singleRotation</span><span class="params">()</span></span>;<span class="comment">//在插入时候右子树RR失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">LR_doubleRotation</span><span class="params">()</span></span>;<span class="comment">//在插入时候左子树LR失衡的时候调整，返回新的树根的指针</span></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">RL_doubleRotation</span><span class="params">()</span></span>;<span class="comment">//在插入时候右子树RL失衡的时候调整，返回新的树根的指针</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt;::avlNode(T val) &#123;</span><br><span class="line">    value = val;</span><br><span class="line">    leftptr = <span class="literal">NULL</span>;</span><br><span class="line">    rightptr = <span class="literal">NULL</span>;</span><br><span class="line">    bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt;::avlNode(T val, avlNode&lt;T&gt; *left, avlNode&lt;T&gt; *right, <span class="keyword">int</span> bf = <span class="number">0</span>) &#123;</span><br><span class="line">    value = val;</span><br><span class="line">    leftptr = left;</span><br><span class="line">    rightptr = right;</span><br><span class="line">    bf = bf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::copy() <span class="keyword">const</span> &#123;</span><br><span class="line">    avlNode&lt;T&gt; *nl, *nr;</span><br><span class="line">    nl = (leftptr == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : leftptr-&gt;copy());<span class="comment">//递归调用复制左子树</span></span><br><span class="line">    nr = (rightptr == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : rightptr-&gt;copy());<span class="comment">//递归调用复制右子树</span></span><br><span class="line">    avlNode&lt;T&gt; *node = <span class="keyword">new</span> avlNode&lt;T&gt;(value, nl, nr, bf);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)   <span class="comment">//?? ==NULL</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlNode&lt;T&gt;::release() &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftptr) &#123;<span class="comment">//删除左子树中的结点</span></span><br><span class="line">        leftptr-&gt;release();<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">delete</span> leftptr;</span><br><span class="line">        leftptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightptr) &#123;<span class="comment">//删除右子树中的结点</span></span><br><span class="line">        rightptr-&gt;release();<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">delete</span> rightptr;</span><br><span class="line">        rightptr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::left() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlNode&lt;T&gt;::left(avlNode&lt;T&gt; *v) &#123;</span><br><span class="line">    leftptr = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::right() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rightptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlNode&lt;T&gt;::right(avlNode&lt;T&gt; *v) &#123;</span><br><span class="line">    rightptr = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> avlNode&lt;T&gt;::add(avlNode&lt;T&gt; *&amp;rp, T val) &#123;<span class="comment">//返回值表明以当前结点为根的树是否再插入之后增高，0:非增高，非0:增高</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; value) &#123;<span class="comment">//左子树插入</span></span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;left() == <span class="literal">NULL</span>)</span><br><span class="line">            rp-&gt;left(<span class="keyword">new</span> avlNode&lt;T&gt;(val));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;left()-&gt;add(rp-&gt;leftptr, val) == <span class="number">0</span>)<span class="comment">//插入后子树没有增高</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;bf == <span class="number">-1</span>) &#123;<span class="comment">//原来已经倾斜，左边失衡，需要做平衡处理</span></span><br><span class="line">            <span class="keyword">if</span> (rp-&gt;left()-&gt;bf &lt; <span class="number">0</span>)  <span class="comment">//插入在左侧，单旋转</span></span><br><span class="line">                rp = LL_singleRotation();</span><br><span class="line">            <span class="keyword">else</span> rp = LR_doubleRotation();    <span class="comment">//插入在右侧，双旋转</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> --bf;   <span class="comment">// bf=(0, +1)的情况，不需要调整树，只要修改bf</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;right() == <span class="literal">NULL</span>)</span><br><span class="line">            rp-&gt;right(<span class="keyword">new</span> avlNode&lt;T&gt;(val));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;right()-&gt;add(rp-&gt;rightptr, val) == <span class="number">0</span>)<span class="comment">//插入后子树没有增高 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;bf == <span class="number">1</span>) &#123;<span class="comment">//原来已经倾斜，需要做平衡处理</span></span><br><span class="line">            <span class="keyword">if</span> (rp-&gt;right()-&gt;bf &gt; <span class="number">0</span>)    <span class="comment">//插入在右侧，单旋转</span></span><br><span class="line">                rp = RR_singleRotation();</span><br><span class="line">            <span class="keyword">else</span> rp = RL_doubleRotation();  <span class="comment">//插入点在右侧.双旋转</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++bf; <span class="comment">// bf=(0, -1)的情况，不需要调整树，只要修改bf</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::remove(T val, avlNode&lt;T&gt; *&amp;waste, <span class="keyword">int</span> &amp;flag) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val == value) &#123;</span><br><span class="line">        waste = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//当没有右子树的时候返回左子树</span></span><br><span class="line">        <span class="keyword">if</span> (right() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> left();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除右子树中的最小结点</span></span><br><span class="line">        <span class="keyword">int</span> oldbf = right()-&gt;bf;</span><br><span class="line">        avlNode *newroot;</span><br><span class="line">        right(right()-&gt;removeLeftmostElement(newroot, flag));<span class="comment">//找到后返回已经平衡的avl树的根指针</span></span><br><span class="line">        newroot-&gt;left(left());</span><br><span class="line">        newroot-&gt;right(right());</span><br><span class="line">        <span class="keyword">if</span> ((flag == <span class="number">1</span>) &amp;&amp; (bf == <span class="number">1</span>))</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            newroot-&gt;bf = bf--;</span><br><span class="line">        &#125; <span class="keyword">else</span> newroot-&gt;bf = bf;</span><br><span class="line">        <span class="comment">//左树的平衡</span></span><br><span class="line">        avlNode&lt;T&gt; *rightchild = newroot-&gt;right();</span><br><span class="line">        <span class="keyword">if</span> (rightchild == <span class="literal">NULL</span>)</span><br><span class="line">            bf--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rightchild-&gt;bf != oldbf) &amp;&amp; (rightchild-&gt;bf == <span class="number">0</span>))</span><br><span class="line">            bf--;</span><br><span class="line">        <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> newoldbf = newroot-&gt;left()-&gt;bf;</span><br><span class="line">            <span class="keyword">if</span> (newoldbf &gt; <span class="number">0</span>) &#123;<span class="comment">//双旋转</span></span><br><span class="line">                <span class="keyword">return</span> newroot-&gt;LR_doubleRotation();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//单旋转</span></span><br><span class="line">                <span class="keyword">return</span> newroot-&gt;LL_singleRotation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newroot;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; value) &#123;<span class="comment">//从左子树中删除</span></span><br><span class="line">        <span class="keyword">if</span> (left() == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//执行删除</span></span><br><span class="line">        <span class="keyword">int</span> oldbf = left()-&gt;bf;</span><br><span class="line">        left(left()-&gt;remove(val, waste, flag));<span class="comment">//递归调用</span></span><br><span class="line">        <span class="comment">//调整左子树</span></span><br><span class="line">        avlNode&lt;T&gt; *leftchild = left();</span><br><span class="line">        <span class="comment">//	if(flag==1)</span></span><br><span class="line">        <span class="comment">//		bf++;</span></span><br><span class="line">        <span class="comment">//计算删除后的子树对当前的根结点的平衡因子的影响</span></span><br><span class="line">        <span class="keyword">if</span> (leftchild == <span class="literal">NULL</span>)</span><br><span class="line">            bf++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((leftchild-&gt;bf != oldbf) &amp;&amp; (leftchild-&gt;bf == <span class="number">0</span>))</span><br><span class="line">            bf++;</span><br><span class="line">        <span class="keyword">if</span> (bf &gt; <span class="number">1</span>)<span class="comment">//失衡</span></span><br><span class="line">        &#123;<span class="comment">//调整</span></span><br><span class="line">            <span class="keyword">int</span> newoldbf = right()-&gt;bf;</span><br><span class="line">            <span class="keyword">if</span> (newoldbf &lt; <span class="number">0</span>)<span class="comment">//双旋转</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> RL_doubleRotation();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//单旋转</span></span><br><span class="line">                avlNode *temp = RR_singleRotation();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                    bf++;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//从右子树中删除</span></span><br><span class="line">        <span class="keyword">if</span> (right() == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//执行删除</span></span><br><span class="line">        <span class="keyword">int</span> oldbf = right()-&gt;bf;</span><br><span class="line">        right(right()-&gt;remove(val, waste, flag));<span class="comment">//递归调用</span></span><br><span class="line">        <span class="comment">//调整右子树</span></span><br><span class="line">        avlNode&lt;T&gt; *rightchild = right();</span><br><span class="line">        <span class="keyword">if</span> (rightchild == <span class="literal">NULL</span>)</span><br><span class="line">            bf--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rightchild-&gt;bf != oldbf) &amp;&amp; (rightchild-&gt;bf == <span class="number">0</span>))</span><br><span class="line">            bf--;</span><br><span class="line">        <span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> newoldbf = left()-&gt;bf;</span><br><span class="line">            <span class="keyword">if</span> (newoldbf &gt; <span class="number">0</span>) &#123;<span class="comment">//双旋转</span></span><br><span class="line">                <span class="keyword">return</span> LR_doubleRotation();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//单旋转</span></span><br><span class="line">                avlNode *temp = LL_singleRotation();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                    bf--;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::removeLeftmostElement(avlNode&lt;T&gt; *&amp;childptr, <span class="keyword">int</span> &amp;flag) &#123;<span class="comment">//flag 表示子树高度是否变化</span></span><br><span class="line">    avlNode *leftchild = left();</span><br><span class="line">    <span class="comment">//找到最小的值，返回，否则递归调用</span></span><br><span class="line">    <span class="keyword">if</span> (leftchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        childptr = <span class="keyword">this</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> oldbf = leftchild-&gt;bf;</span><br><span class="line">    left(leftchild-&gt;removeLeftmostElement(childptr, flag));<span class="comment">//递归调用</span></span><br><span class="line">    <span class="comment">//调整左子树平衡</span></span><br><span class="line">    avlNode&lt;T&gt; *newleftchild = left();</span><br><span class="line">    <span class="comment">//计算删除后的子树的高度变化</span></span><br><span class="line">    <span class="keyword">if</span> ((newleftchild == <span class="literal">NULL</span>) &amp;&amp; (right() == <span class="literal">NULL</span>))</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算删除后的子树对当前的根结点的平衡因子的影响</span></span><br><span class="line">    <span class="keyword">if</span> (newleftchild == <span class="literal">NULL</span>)</span><br><span class="line">        bf++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newleftchild-&gt;bf != oldbf) &amp;&amp; (newleftchild-&gt;bf == <span class="number">0</span>))</span><br><span class="line">        bf++;</span><br><span class="line">    <span class="keyword">if</span> (bf &gt; <span class="number">1</span>)<span class="comment">//失衡</span></span><br><span class="line">    &#123;<span class="comment">//调整</span></span><br><span class="line">        <span class="keyword">int</span> newoldbf = right()-&gt;bf;</span><br><span class="line">        <span class="keyword">if</span> (newoldbf &lt; <span class="number">0</span>)<span class="comment">//双旋转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> RL_doubleRotation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//单旋转</span></span><br><span class="line">            <span class="keyword">return</span> RR_singleRotation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::findNodeValue(T val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; value) &#123;<span class="comment">//大于的话在右子树中查找</span></span><br><span class="line">        <span class="keyword">if</span> (right() != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> right()-&gt;findNodeValue(val);<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//小于的话在左子树中查找</span></span><br><span class="line">        <span class="keyword">if</span> (left() != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> left()-&gt;findNodeValue(val);<span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlNode&lt;T&gt;::preorderview(avlNode&lt;T&gt; *current, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    i++;<span class="comment">//层计数器</span></span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">8</span>) &lt;&lt; current-&gt;value &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; current-&gt;bf &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        preorderview(current-&gt;left(), i);<span class="comment">//递归调用</span></span><br><span class="line">        preorderview(current-&gt;right(), i);<span class="comment">//递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::LL_singleRotation() &#123;</span><br><span class="line">    avlNode&lt;T&gt; *p;</span><br><span class="line">    p = left();</span><br><span class="line">    left(p-&gt;right());</span><br><span class="line">    bf = <span class="number">0</span>;</span><br><span class="line">    p-&gt;right(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">0</span>)</span><br><span class="line">        p-&gt;bf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::LR_doubleRotation() &#123;</span><br><span class="line">    avlNode&lt;T&gt; *p, *q;</span><br><span class="line">    q = left();</span><br><span class="line">    p = q-&gt;right();</span><br><span class="line">    q-&gt;right(p-&gt;left());</span><br><span class="line">    left(p-&gt;right());</span><br><span class="line">    p-&gt;left(q);</span><br><span class="line">    bf = q-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">-1</span>) bf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">1</span>) q-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">    p-&gt;right(<span class="keyword">this</span>);</span><br><span class="line">    p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::RR_singleRotation() &#123;</span><br><span class="line">    avlNode&lt;T&gt; *p;</span><br><span class="line">    p = right();</span><br><span class="line">    right(p-&gt;left());</span><br><span class="line">    bf = <span class="number">0</span>;</span><br><span class="line">    p-&gt;left(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">0</span>)</span><br><span class="line">        p-&gt;bf = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlNode&lt;T&gt;::RL_doubleRotation() &#123;</span><br><span class="line">    avlNode&lt;T&gt; *p, *q;</span><br><span class="line">    q = right();</span><br><span class="line">    p = q-&gt;left();</span><br><span class="line">    q-&gt;left(p-&gt;right());</span><br><span class="line">    right(p-&gt;left());</span><br><span class="line">    p-&gt;right(q);</span><br><span class="line">    bf = q-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">-1</span>) q-&gt;bf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;bf == <span class="number">1</span>) bf = <span class="number">-1</span>;</span><br><span class="line">    p-&gt;left(<span class="keyword">this</span>);</span><br><span class="line">    p-&gt;bf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVLTree-h"><a href="#AVLTree-h" class="headerlink" title="AVLTree.h"></a>AVLTree.h</h3><p><a herf="#AVLNode-h">#include “AVLNode.h</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this is avl tree class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AVLNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">avlTree</span>//平衡二叉树类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    avlTree();<span class="comment">//构造函数</span></span><br><span class="line">    avlTree(<span class="keyword">const</span> avlTree&lt;T&gt; &amp;source);</span><br><span class="line"></span><br><span class="line">    ~avlTree();<span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAllValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(avlNode&lt;T&gt; *found)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">avlNode&lt;T&gt; *<span class="title">findValue</span><span class="params">(T val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    avlNode&lt;T&gt; *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlTree&lt;T&gt;::avlTree():root(<span class="number">0</span>) &#123;&#125;<span class="comment">//建立空树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlTree&lt;T&gt;::avlTree(<span class="keyword">const</span> avlTree&lt;T&gt; &amp;source) &#123;<span class="comment">//复制构造函数</span></span><br><span class="line">    root = (source.root == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : source.root-&gt;copy());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlTree&lt;T&gt;::~avlTree() &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) deleteAllValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::add(T value) &#123;<span class="comment">//向平衡的avl树添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        root = <span class="keyword">new</span> avlNode&lt;T&gt;(value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;add(root, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::remove(T val) &#123;<span class="comment">//从avl树中删除一个元素</span></span><br><span class="line">    avlNode&lt;T&gt; *eNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">        root = root-&gt;remove(val, eNode, flag);</span><br><span class="line">    <span class="keyword">if</span> (eNode)</span><br><span class="line">        <span class="keyword">delete</span> eNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The avlTree doesn&#x27;t contain the value&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::deleteAllValue() &#123;<span class="comment">//删除avl树的全部元素</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;release();</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::display() &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;节点值&quot;</span> &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;平衡因子&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; <span class="string">&quot;层数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        root-&gt;preorderview(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前树空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">avlNode&lt;T&gt; *avlTree&lt;T&gt;::findValue(T val) &#123;<span class="comment">//查找val的节点值</span></span><br><span class="line">    avlNode&lt;T&gt; *found = root-&gt;findNodeValue(val);</span><br><span class="line">    <span class="keyword">if</span> (found == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> avlTree&lt;T&gt;::display(avlNode&lt;T&gt; *found) &#123;<span class="comment">//显示指针的指向的码值</span></span><br><span class="line">    <span class="keyword">if</span> (found == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sorry,没找到 :(&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; found-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OptimalBST-cpp"><a href="#OptimalBST-cpp" class="headerlink" title="OptimalBST.cpp"></a>OptimalBST.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 动态规划算法求解最优二叉搜索树问题</span></span><br><span class="line"><span class="comment">//输入参数:a[]内部结点的权,b[]外部结点的权,n结点数</span></span><br><span class="line"><span class="comment">//输出参数:**w权的总和,**r结果二叉树,**c构造树的代价</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OptimalBST</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n, <span class="keyword">int</span> c[N + <span class="number">1</span>][N + <span class="number">1</span>], <span class="keyword">int</span> r[N + <span class="number">1</span>][N + <span class="number">1</span>], <span class="keyword">int</span> w[N + <span class="number">1</span>][N + <span class="number">1</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, d;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)                        <span class="comment">// 数组下三角清零</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            c[i][j] = <span class="number">0</span>;</span><br><span class="line">            r[i][j] = <span class="number">0</span>;</span><br><span class="line">            w[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 初始化，确定每一个总权和w[i,j]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        w[i][i] = b[i];</span><br><span class="line">        <span class="comment">//求出权和w[i.j]</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            w[i][j] = w[i][j - <span class="number">1</span>] + a[j] + b[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定一个结点的最佳二叉搜索树，一个结点的c[j-1, j]就是对应的w[j-1, j]</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        c[j - <span class="number">1</span>][j] = w[j - <span class="number">1</span>][j];</span><br><span class="line">        r[j - <span class="number">1</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定d个结点的最佳二叉树</span></span><br><span class="line">    <span class="keyword">int</span> m, k0, k;</span><br><span class="line">    <span class="keyword">for</span> (d = <span class="number">2</span>; d &lt;= n; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = d; j &lt;= n; j++) &#123;</span><br><span class="line">            i = j - d;</span><br><span class="line">            m = c[i + <span class="number">1</span>][j];</span><br><span class="line">            k0 = i + <span class="number">1</span>;                            <span class="comment">// 以Ki+1为根</span></span><br><span class="line">            <span class="keyword">for</span> (k = i + <span class="number">2</span>; k &lt;= j; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[i][k - <span class="number">1</span>] + c[k][j] &lt; m) &#123;        <span class="comment">// 动态规划的核心步骤</span></span><br><span class="line">                    m = c[i][k - <span class="number">1</span>] + c[k][j];        <span class="comment">// 把当前最小记录下来</span></span><br><span class="line">                    k0 = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            c[i][j] = w[i][j] + m;                <span class="comment">// 记录最小权</span></span><br><span class="line">            r[i][j] = k0;                            <span class="comment">// 记录树根</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造新教材图12.27最佳二叉树</span></span><br><span class="line">    <span class="keyword">int</span> a[N + <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[N + <span class="number">1</span>] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> r[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> w[N + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> n = N;</span><br><span class="line">    <span class="comment">//计算最佳二叉树</span></span><br><span class="line">    OptimalBST(a, b, n, c, r, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0 &quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; r[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SplayTree-h"><a href="#SplayTree-h" class="headerlink" title="SplayTree.h"></a>SplayTree.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//****************************  genSplay.h  ****************************</span></span><br><span class="line"><span class="comment">//伸展树类模版</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPLAYING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPLAYING</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayingNode</span> &#123;</span><span class="comment">//伸展树的结点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SplayingNode *left, *right, *parent;<span class="comment">//结点的左右儿子和父亲结点</span></span><br><span class="line">    T info;                     <span class="comment">//存储的数据</span></span><br><span class="line">    SplayingNode() &#123;<span class="comment">//构造函数</span></span><br><span class="line">        left = right = parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SplayingNode(<span class="keyword">const</span> T &amp;el, SplayingNode *l = <span class="number">0</span>, SplayingNode *r = <span class="number">0</span>,</span><br><span class="line">                 SplayingNode *p = <span class="number">0</span>) &#123;<span class="comment">//构造函数</span></span><br><span class="line">        info = el;</span><br><span class="line">        left = l;</span><br><span class="line">        right = r;</span><br><span class="line">        parent = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplayTree</span> &#123;</span><span class="comment">//伸展树类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SplayTree() &#123;</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;<span class="comment">//排序</span></span><br><span class="line">        inorder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">search</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;<span class="comment">//搜索元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;<span class="comment">//插入元素</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    SplayingNode&lt;T&gt; *root; <span class="comment">//根结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotateR</span><span class="params">(SplayingNode&lt;T&gt; *)</span></span>;  <span class="comment">//右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotateL</span><span class="params">(SplayingNode&lt;T&gt; *)</span></span>;  <span class="comment">//左旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">continueRotation</span><span class="params">(SplayingNode&lt;T&gt; *gr, SplayingNode&lt;T&gt; *par,</span></span></span><br><span class="line"><span class="function"><span class="params">                          SplayingNode&lt;T&gt; *ch, SplayingNode&lt;T&gt; *desc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行“之“型或者“一“型旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(SplayingNode&lt;T&gt; *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(SplayingNode&lt;T&gt; *)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">visit</span><span class="params">(SplayingNode&lt;T&gt; *)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::continueRotation(SplayingNode&lt;T&gt; *gr, SplayingNode&lt;T&gt; *par,</span><br><span class="line">                                    SplayingNode&lt;T&gt; *ch, SplayingNode&lt;T&gt; *desc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (gr != <span class="number">0</span>) &#123; <span class="comment">// 结点是否有祖父结点</span></span><br><span class="line">        <span class="keyword">if</span> (gr-&gt;right == ch-&gt;parent)</span><br><span class="line">            gr-&gt;right = ch;</span><br><span class="line">        <span class="keyword">else</span> gr-&gt;left = ch;</span><br><span class="line">    &#125; <span class="keyword">else</span> root = ch;</span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="number">0</span>)</span><br><span class="line">        desc-&gt;parent = par;</span><br><span class="line">    par-&gt;parent = ch;</span><br><span class="line">    ch-&gt;parent = gr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::rotateR(SplayingNode&lt;T&gt; *p) &#123;</span><br><span class="line">    p-&gt;parent-&gt;left = p-&gt;right;</span><br><span class="line">    p-&gt;right = p-&gt;parent;</span><br><span class="line">    continueRotation(p-&gt;parent-&gt;parent, p-&gt;right, p, p-&gt;right-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::rotateL(SplayingNode&lt;T&gt; *p) &#123;</span><br><span class="line">    p-&gt;parent-&gt;right = p-&gt;left;</span><br><span class="line">    p-&gt;left = p-&gt;parent;</span><br><span class="line">    continueRotation(p-&gt;parent-&gt;parent, p-&gt;left, p, p-&gt;left-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::splay(SplayingNode&lt;T&gt; *p) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p != root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parent-&gt;parent == <span class="number">0</span>)    <span class="comment">// 如果结点的父亲是根结点</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent-&gt;left == p)</span><br><span class="line">                rotateR(p);</span><br><span class="line">            <span class="keyword">else</span> rotateL(p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;parent-&gt;left == p) <span class="comment">// 如果结点是左子女</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;parent-&gt;parent-&gt;left == p-&gt;parent) &#123;</span><br><span class="line">                rotateR(p-&gt;parent);</span><br><span class="line">                rotateR(p);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rotateR(p); <span class="comment">// 旋转p和它的父亲</span></span><br><span class="line">                rotateL(p); <span class="comment">// 旋转p和他的新父亲</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>                          <span class="comment">// 如果结点是右子女</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parent-&gt;parent-&gt;right == p-&gt;parent) &#123;</span><br><span class="line">            rotateL(p-&gt;parent);</span><br><span class="line">            rotateL(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rotateL(p); <span class="comment">// 旋转p和它的父亲</span></span><br><span class="line">            rotateR(p); <span class="comment">// 旋转p和他的新父亲</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>)              <span class="comment">// 更新根结点</span></span><br><span class="line">            root = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T *SplayTree&lt;T&gt;::search(<span class="keyword">const</span> T &amp;el) &#123;</span><br><span class="line">    SplayingNode&lt;T&gt; *p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;info == el) &#123;        <span class="comment">// el元素是否在树中</span></span><br><span class="line">            splay(p);</span><br><span class="line">            <span class="keyword">return</span> &amp;p-&gt;info;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el &lt; p-&gt;info)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> p = p-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::insert(<span class="keyword">const</span> T &amp;el) &#123;</span><br><span class="line">    SplayingNode&lt;T&gt; *p = root, *prev = <span class="number">0</span>, *newNode;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>) &#123;  <span class="comment">// 插入一个新的元素</span></span><br><span class="line">        prev = p;</span><br><span class="line">        <span class="keyword">if</span> (el &lt; p-&gt;info)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((newNode = <span class="keyword">new</span> SplayingNode&lt;T&gt;(el, <span class="number">0</span>, <span class="number">0</span>, prev)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;No room for new nodes\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>)    <span class="comment">// 树是空的</span></span><br><span class="line">        root = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (el &lt; prev-&gt;info)</span><br><span class="line">        prev-&gt;left = newNode;</span><br><span class="line">    <span class="keyword">else</span> prev-&gt;right = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> SplayTree&lt;T&gt;::inorder(SplayingNode&lt;T&gt; *p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        inorder(p-&gt;left);</span><br><span class="line">        visit(p);</span><br><span class="line">        inorder(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2021/04/16/PKUAutoEletiveCaptchaHelper/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">利用Tensorflow实现的选课网验证码自动识别AI</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> tetrahedron
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="tetrahedron&#39;s Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->


    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    


<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

</html>