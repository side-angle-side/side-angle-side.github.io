<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tetrahedron&#39;s Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-30T14:47:50.415Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>tetrahedron</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++程序设计笔记</title>
    <link href="http://example.com/2020/12/28/fundamentals-of-Cpp-programming-and-algorithms/"/>
    <id>http://example.com/2020/12/28/fundamentals-of-Cpp-programming-and-algorithms/</id>
    <published>2020-12-28T05:05:23.000Z</published>
    <updated>2020-12-30T14:47:50.415Z</updated>
    
    <content type="html"><![CDATA[<center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/12/28/fundamentals-of-Cpp-programming-and-algorithms/IMG_20201223_235334.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">为了做这句话，我还学了一点HTML。</div></center><a id="more"></a><h2 id="一-从C到C"><a href="#一-从C到C" class="headerlink" title="一    从C到C++"></a>一    从C到C++</h2><h3 id="1-1-C-语言的历史"><a href="#1-1-C-语言的历史" class="headerlink" title="1.1    C++语言的历史"></a>1.1    C++语言的历史</h3><p>1983年诞生的C++对C语言的改进包括面向对象、虚函数、函数和运算符重载、引用等。1989年推出的C++2.0实现了多重继承、抽象类、静态成员、常量成员函数等功能。1990年加入了模板、异常处理、命名空间等机制。1998年诞生的C++98加入了标准模板库（STL），C++从此实现了泛型程序设计。2011年发布的C++11标准支持正则表达式、哈希表以及其他一系列重要的功能。当前最新的C++标准是C++20。</p><h3 id="1-2-输入输出"><a href="#1-2-输入输出" class="headerlink" title="1.2    输入输出"></a>1.2    输入输出</h3><p>C++使用<code>cin</code>和<code>cout</code>实现输入输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; d;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-头文件"><a href="#1-3-头文件" class="headerlink" title="1.3    头文件"></a>1.3    头文件</h3><p>C++头文件不再以”.h”结尾，常用的C++头文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;//标准输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;//STL 通用算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;//参数化输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;//定义数学函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;//字符串处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;//定义关于时间的函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;//STL 动态数组容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;//STL 队列容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;//STL 堆栈容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;//字符串类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;//文件输入／输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;//STL 集合容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;//STL 映射容器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;//定义杂项函数及内存分配函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;//STL 通用模板类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;//基于字符串的流</span></span></span><br></pre></td></tr></table></figure><h3 id="1-4-强制类型转换"><a href="#1-4-强制类型转换" class="headerlink" title="1.4    强制类型转换"></a>1.4    强制类型转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="number">3.5</span>);<span class="comment">//C++通常写成类似函数调用的格式</span></span><br><span class="line"><span class="keyword">double</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">double</span>(a);</span><br><span class="line">(<span class="keyword">int</span>)<span class="number">3.5</span>;<span class="comment">//传统的C格式</span></span><br><span class="line">(<span class="keyword">double</span>)<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="1-5-函数参数的默认值"><a href="#1-5-函数参数的默认值" class="headerlink" title="1.5    函数参数的默认值"></a>1.5    函数参数的默认值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">(<span class="keyword">int</span> x=<span class="number">20</span>)</span></span>;<span class="comment">//函数声明，x默认为20</span></span><br><span class="line">Function1();<span class="comment">//函数调用，等效于Function(20);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用表达式作为函数的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y=Max(a,b),<span class="keyword">int</span> z=a*b)</span><span class="comment">//函数定义处也可以写参数的默认值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Function2(<span class="number">4</span>);<span class="comment">//Function2(4,Max(a,b),a*b)</span></span><br><span class="line">Function2(<span class="number">4</span>,<span class="number">9</span>);<span class="comment">//Function2(4,9,a*b);</span></span><br><span class="line">Function2(<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Function2(<span class="number">4</span>,,<span class="number">3</span>);<span class="comment">//报错，省略的参数一定是最右边连续的几个</span></span><br></pre></td></tr></table></figure><h3 id="1-6-引用和函数参数的传递"><a href="#1-6-引用和函数参数的传递" class="headerlink" title="1.6    引用和函数参数的传递"></a>1.6    引用和函数参数的传递</h3><h4 id="1-6-1-引用"><a href="#1-6-1-引用" class="headerlink" title="1.6.1    引用"></a>1.6.1    引用</h4><p>引用某个变量相当于某个变量的别名。<strong>定义引用时必须初始化，通常用某个变量初始化引用。</strong>引用初始化后会一直引用该变量，不会引用别的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span>&amp; r=n;</span><br></pre></td></tr></table></figure><p>修改变量的值，引用的值也会修改。修改引用的值，变量的值也会修改。多个不同的引用可以引用同一变量。</p><h4 id="1-6-2-引用作为函数返回值"><a href="#1-6-2-引用作为函数返回值" class="headerlink" title="1.6.2    引用作为函数返回值"></a>1.6.2    引用作为函数返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">SetValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetValue()=<span class="number">40</span>;<span class="comment">//返回引用的函数表达式可作为左值使用，等效于n=40;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; r=SetValue();<span class="comment">//r为n的引用，r=40；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-3-值传递和引用传递"><a href="#1-6-3-值传递和引用传递" class="headerlink" title="1.6.3    值传递和引用传递"></a>1.6.3    值传递和引用传递</h4><p>函数传参的形式有两种，一是值传递，二是引用传递。值传递形参是实参的拷贝，形参改变不影响实参。在函数调用过程中，实参的值会被复制到栈中，函数执行过程中对形参的改变只是修改了实参的拷贝，不修改实参。如果函数的形参是引用，那么形参的改变会影响实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//错误</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span><span class="comment">//正确</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-4-常引用"><a href="#1-6-4-常引用" class="headerlink" title="1.6.4    常引用"></a>1.6.4    常引用</h4><p>加上<code>const</code>关键字的引用称为常引用。<strong>不能通过常引用修改其引用的内容。</strong>常引用的类型为<code>const T&amp;</code>。引用和变量可以初始化常引用，但常变量和常引用不能初始化引用，除非进行强制类型转换。</p><h3 id="1-7-内联函数"><a href="#1-7-内联函数" class="headerlink" title="1.7    内联函数"></a>1.7    内联函数</h3><p>进行函数调用时，首先要在栈中开辟形参和局部变量的存储空间，接着把实参的值复制给形参，然后把函数返回地址放入栈中，最后跳转至函数内部执行。函数调用结束时，需要从栈中回收形参和局部变量的空间，取出返回地址才能跳转到该地址继续执行。如果一个函数语句很简单，执行时间很短，又经常被调用，函数调用带来的时间开销就非常大。因此在返回值前加上<code>inline</code>关键字，成为内联函数，编译器编译时就不会将该语句编译成调用指令，而是直接插入代码。这样既可以实现代码复用，又不会造成函数调用的额外开销。调用内联函数前必须出现内联函数的定义而不仅是其声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-函数重载"><a href="#1-8-函数重载" class="headerlink" title="1.8    函数重载"></a>1.8    函数重载</h3><p>多个函数名字相同但参数表不同称为函数重载。编译器可以通过函数调用语句中实参的个数和类型确定应该调用哪个函数。常见的一种重载编译出错是二义性错误。仅返回值不同的函数是重复定义，不是重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Max 1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Max</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Max 2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sum 1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sum 2&quot;</span>&lt;&lt;end</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Max(<span class="number">3</span>,<span class="number">1.5</span>);<span class="comment">//二义性错误</span></span><br><span class="line">    Sum(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//二义性错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-指针和动态内存分配"><a href="#1-9-指针和动态内存分配" class="headerlink" title="1.9    指针和动态内存分配"></a>1.9    指针和动态内存分配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[n];<span class="comment">//编译出错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//动态分配4byte的内存空间</span></span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>* pn=<span class="keyword">new</span> <span class="keyword">int</span>[i*<span class="number">20</span>];<span class="comment">//动态分配i*20*sizeof(int)byte的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//动态分配的内存空间使用完后应当释放，但不能重复delete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> []p;<span class="comment">//释放动态分配的数组内存</span></span><br></pre></td></tr></table></figure><h3 id="1-10-string对象"><a href="#1-10-string对象" class="headerlink" title="1.10    string对象"></a>1.10    string对象</h3><p><code>string</code>是标准模板库中的一个类，需要包含头文件<code>string</code>。处理字符串优先考虑使用<code>string</code>类。<code>string</code>对象只存放字符串地址而不直接存放字符串。</p><h4 id="1-10-1-string对象的定义、输入输出和赋值"><a href="#1-10-1-string对象的定义、输入输出和赋值" class="headerlink" title="1.10.1    string对象的定义、输入输出和赋值"></a>1.10.1    string对象的定义、输入输出和赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> str1;<span class="comment">//没有初始化的值为空串&quot;&quot;</span></span><br><span class="line"><span class="built_in">string</span> city=<span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> as[]=&#123;<span class="string">&quot;Beijing&quot;</span>,<span class="string">&quot;Shanghai&quot;</span>,<span class="string">&quot;Chengdu&quot;</span>&#125;;<span class="comment">//string数组</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;as[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><code>string</code>可以互相赋值，也可以用<code>char[]</code>赋值。</p><h4 id="1-10-2-string的运算"><a href="#1-10-2-string的运算" class="headerlink" title="1.10.2    string的运算"></a>1.10.2    string的运算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;abc&quot;</span>,s3;<span class="comment">//s3==&quot;&quot;</span></span><br><span class="line">s3=s1+s2;<span class="comment">//s3==&quot;123abc&quot;</span></span><br><span class="line">s3+=<span class="string">&quot;de&quot;</span>;<span class="comment">//s3==&quot;123abcde&quot;</span></span><br><span class="line"><span class="keyword">bool</span> b=s1&lt;s3;<span class="comment">//b==true</span></span><br><span class="line"><span class="keyword">char</span> c=s1[<span class="number">2</span>];<span class="comment">//c==&#x27;3&#x27;</span></span><br><span class="line">s1[<span class="number">2</span>]=<span class="string">&#x27;5&#x27;</span>;<span class="comment">//s1=&quot;125&quot;</span></span><br></pre></td></tr></table></figure><h4 id="1-10-3-string类的使用"><a href="#1-10-3-string类的使用" class="headerlink" title="1.10.3    string类的使用"></a>1.10.3    string类的使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;123&quot;</span>,s2=<span class="string">&quot;abcdef&quot;</span>,s3;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2.substr(<span class="number">1</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//bcd</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">s3=s1+s2;</span><br><span class="line"><span class="built_in">strcpy</span>(str,s3.c_str());<span class="comment">//123abcdef</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="二-类和对象初步"><a href="#二-类和对象初步" class="headerlink" title="二    类和对象初步"></a>二    类和对象初步</h2><h3 id="2-1-结构化程序设计的不足"><a href="#2-1-结构化程序设计的不足" class="headerlink" title="2.1    结构化程序设计的不足"></a>2.1    结构化程序设计的不足</h3><p>结构化程序设计也称为面向过程的程序设计，过程用函数实现，因此设计时就要考虑如何把功能分割成一个个函数，不同函数互相调用，每个函数实现各自的功能。结构化程序设计难免会使用一些全局变量，这些变量往往被很多函数访问或修改，这样的程序在规模庞大的情况下就难以进行理解和维护。随着软件规模不断扩大，结构化程序设计已经难以适应开发大型软件的需要，面向对象的程序设计便应运而生。</p><h3 id="2-2-面向对象程序设计的概念和特点"><a href="#2-2-面向对象程序设计的概念和特点" class="headerlink" title="2.2    面向对象程序设计的概念和特点"></a>2.2    面向对象程序设计的概念和特点</h3><p><strong>面向对象的程序设计的基本特点是抽象、封装、继承、多态。</strong></p><p>抽象指把同一类事物的共同特点概括出来。对象的特点包括属性和方法。属性指对象的静态特征，可以用变量表示。方法指对象的行为，可以用函数表示。方法可以对属性进行操作。完成抽象后将数据和操作数据的算法组合在一起，形成形式上的整体，叫做“类”，这个过程称为封装。封装可以把对象的一部分属性和方法隐藏起来，对外界不可见，这样可以减少程序不同部分的耦合度，提高代码扩充修改和复用的效率。继承机制就是在编写一个类时以现有的类作为基础，利用派生达到代码复用的目的 。多态则指的是不同种类的对象具有相同名称的行为，但实现方式有所不同。</p><h3 id="2-3-类的定义和使用"><a href="#2-3-类的定义和使用" class="headerlink" title="2.3    类的定义和使用"></a>2.3    类的定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>//类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//访问范围说明符</span></span><br><span class="line">    <span class="keyword">int</span> a;<span class="comment">//成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func1</span><span class="params">()</span><span class="comment">//成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;<span class="comment">//成员变量和成员函数的先后次序没有规定</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> b)</span><span class="comment">//成员函数可以互相调用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b=Func1();</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>;<span class="comment">//成员函数可以重载，也可以设定参数默认值</span></span><br><span class="line">&#125;;<span class="comment">//以“；”结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Myclass::Func2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c=<span class="number">0</span>)</span></span>;<span class="comment">//成员函数实现可位于类定义以外</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">Myclass m;<span class="comment">//定义某个类的对象</span></span><br></pre></td></tr></table></figure><h3 id="2-4-类的示例"><a href="#2-4-类的示例" class="headerlink" title="2.4    类的示例"></a>2.4    类的示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">perimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRectangle::init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w=w_;</span><br><span class="line">    h=h_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRectangle::area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w*h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Crectangle::perimeter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    return2*(w+h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    CRectangle r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;w&gt;&gt;h;</span><br><span class="line">    r.init(w,h);<span class="comment">//访问成员函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;It&#x27;s area is &quot;</span>&lt;&lt;r.area()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;It&#x27;s perimeter is &quot;</span>&lt;&lt;r.perimeter()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(CRectangle)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//对象占用内存空间大小等于各成员变量占用内存空间大小之和，输出8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-访问对象的成员"><a href="#2-5-访问对象的成员" class="headerlink" title="2.5    访问对象的成员"></a>2.5    访问对象的成员</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CRectangle r1.r2;</span><br><span class="line">CRectangle* p1=&amp;r1;</span><br><span class="line">CRectangle* p2=&amp;r2;</span><br><span class="line">p1-&gt;w=<span class="number">5</span>;</span><br><span class="line">p2-&gt;init(<span class="number">5</span>,<span class="number">4</span>);<span class="comment">//使用指针-&gt;成员名访问成员</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRectangle&amp; rr=r2;</span><br><span class="line">rr.w=<span class="number">5</span>;</span><br><span class="line">rr.init(<span class="number">5</span>,<span class="number">4</span>);<span class="comment">//使用引用名.成员名访问对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CRectangle</span>//用<span class="keyword">struct</span>表示类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w,h;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有成员函数的<code>struct</code>还是称为结构。对象可以使用”=“赋值，但不能进行比较运算。</p><h3 id="2-6-类成员的可访问范围"><a href="#2-6-类成员的可访问范围" class="headerlink" title="2.6    类成员的可访问范围"></a>2.6    类成员的可访问范围</h3><h4 id="2-6-1-private和public访问范围说明符"><a href="#2-6-1-private和public访问范围说明符" class="headerlink" title="2.6.1    private和public访问范围说明符"></a>2.6.1    private和public访问范围说明符</h4><p>private用来指定私有成员，私有成员只有在该类的成员函数内部才能访问。public用来指定公有成员，公有成员可以在任何地方访问。protected用来指定保护成员。三种关键字次数和顺序没有限制。若成员没有访问范围说明符，对于class类默认为私有成员，对于struct类默认为公有成员。</p><h4 id="2-6-2-“隐藏”的作用"><a href="#2-6-2-“隐藏”的作用" class="headerlink" title="2.6.2    “隐藏”的作用"></a>2.6.2    “隐藏”的作用</h4><p>隐藏强制对成员变量的访问通过成员函数进行，如果未来修改了成员变量类型等属性，只需修改成员函数即可。隐藏还可以避免对对象的不正确操作。</p><h2 id="三-类和对象进阶"><a href="#三-类和对象进阶" class="headerlink" title="三    类和对象进阶"></a>三    类和对象进阶</h2><h3 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1    构造函数"></a>3.1    构造函数</h3><h4 id="3-1-1-构造函数的概念和作用"><a href="#3-1-1-构造函数的概念和作用" class="headerlink" title="3.1.1    构造函数的概念和作用"></a>3.1.1    构造函数的概念和作用</h4><p>面向对象的程序设计语言倾向于对象一定要经过初始化后使用起来才比较安全。因此引入构造函数的概念，用于对对象进行初始化。一个类可以有多个构造函数，如果没有写构造函数，编译器会自动生成一个默认的无参构造函数，该函数什么都不做。如果编写了构造函数，就不会再生成默认构造函数。对象生成时一定会调用某个构造函数进行初始化，一旦生成就再也不会执行构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c;<span class="comment">//无参构造函数</span></span><br><span class="line">Complex* p=<span class="keyword">new</span> Complex;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i=<span class="number">0</span>);<span class="comment">//构造函数是特殊的成员函数，名字和类名一样，不写返回值，可以重载</span></span><br><span class="line">&#125;;</span><br><span class="line">Complex::Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)<span class="comment">//构造函数1</span></span><br><span class="line">&#123;</span><br><span class="line">    real=r;</span><br><span class="line">    imag=i;</span><br><span class="line">&#125;</span><br><span class="line">Complex::Complex(Complex c1,Complex c2)<span class="comment">//构造函数2</span></span><br><span class="line">&#123;</span><br><span class="line">    real=c1.real+c2.real;</span><br><span class="line">    imag=c1.imag+c2.imag;</span><br><span class="line">&#125;</span><br><span class="line">Complex c1;<span class="comment">//错误，没有无参构造函数</span></span><br><span class="line">Complex* pc=<span class="keyword">new</span> Complex;<span class="comment">//错误</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//正确，相当于Complex c2(2,0);</span></span><br><span class="line">Complex c3(2,4),c4(3,5);//正确</span><br><span class="line">Complex* pc2=<span class="keyword">new</span> Complex(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//正确</span></span><br><span class="line"><span class="function">Complex <span class="title">c5</span><span class="params">(c3,c4)</span></span>;<span class="comment">//正确，使用构造函数2</span></span><br><span class="line">Complex c6=<span class="number">5</span>;<span class="comment">//正确，使用构造函数1</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-构造函数在数组中的使用"><a href="#3-1-2-构造函数在数组中的使用" class="headerlink" title="3.1.2    构造函数在数组中的使用"></a>3.1.2    构造函数在数组中的使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest(<span class="keyword">int</span> n)&#123;&#125;<span class="comment">//构造函数1</span></span><br><span class="line">    CTest(<span class="keyword">int</span> n,<span class="keyword">int</span> m)&#123;&#125;<span class="comment">//构造函数2</span></span><br><span class="line">    CTest()&#123;&#125;<span class="comment">//构造函数3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest array1[<span class="number">3</span>]=&#123;<span class="number">1</span>,CTest(<span class="number">1</span>,<span class="number">2</span>)&#125;;<span class="comment">//1，2，3</span></span><br><span class="line">    CTest array2[<span class="number">3</span>]=&#123;CTest(<span class="number">2</span>,<span class="number">3</span>),CTest(<span class="number">1</span>,<span class="number">2</span>),<span class="number">1</span>&#125;;<span class="comment">//2，2，1</span></span><br><span class="line">    CTest* pArray[<span class="number">3</span>]=&#123;<span class="keyword">new</span> CTest(<span class="number">4</span>),<span class="keyword">new</span> CTest(<span class="number">1</span>,<span class="number">2</span>)&#125;;<span class="comment">//1，2，只生成了两个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-复制构造函数"><a href="#3-1-3-复制构造函数" class="headerlink" title="3.1.3    复制构造函数"></a>3.1.3    复制构造函数</h4><h5 id="1-复制构造函数的概念"><a href="#1-复制构造函数的概念" class="headerlink" title="1.复制构造函数的概念"></a>1.复制构造函数的概念</h5><p>复制构造函数是构造函数的一种，它只有一个该类的引用作为参数。引用可以是const引用，也可以是非const引用，一般使用前者。默认构造函数不一定存在，但复制构造函数总是存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;&#125;</span><br><span class="line">    Complex(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; c)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;<span class="comment">//用复制构造函数初始化c2</span></span><br></pre></td></tr></table></figure><p>构造函数不能以本类的对象作为唯一参数。</p><h5 id="2-复制构造函数被调用的三种情况"><a href="#2-复制构造函数被调用的三种情况" class="headerlink" title="2.复制构造函数被调用的三种情况"></a>2.复制构造函数被调用的三种情况</h5><ul><li>用一个对象初始化同类的另一个对象</li><li>作为形参的对象用复制构造函数初始化，复制构造函数的参数就是调用函数时的实参。</li><li>作为函数返回值的对象用复制构造函数初始化，复制构造函数的参数就是return语句返回的对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2=c1;<span class="comment">//只有初始化语句才能调用复制构造函数</span></span><br><span class="line">c2=c1;<span class="comment">//赋值语句不能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(A&amp; a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">(A a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function">A <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    Func1(a);<span class="comment">//调用复制构造函数</span></span><br><span class="line">    Func2();<span class="comment">//调用复制构造函数</span></span><br><span class="line">    Func3(a);<span class="comment">//通过引用避免了复制构造函数，同时保证实参的值不会改变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-4-类型转换构造函数"><a href="#3-1-4-类型转换构造函数" class="headerlink" title="3.1.4    类型转换构造函数"></a>3.1.4    类型转换构造函数</h4><p>除复制构造函数外，只有一个参数的构造函数称为类型转换构造函数，这样的构造函数能起到自动类型转换的作用。类型转换构造函数可以在初始化语句和赋值语句被调用。处理赋值语句时，编译器往往会把在等号右侧生成一个临时对象，再赋值给等号左侧。</p><h3 id="3-2-析构函数"><a href="#3-2-析构函数" class="headerlink" title="3.2    析构函数"></a>3.2    析构函数</h3><p>析构函数用于对象消亡前的善后工作，在对象消亡时自动调用。例如在析构函数中调用delete语句即可确保对象运行时动态分配的内存空间被释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~Cdemo()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CDemo <span class="built_in">array</span>[<span class="number">2</span>];<span class="comment">//构造函数调用2次</span></span><br><span class="line">    CDemo* pTest=<span class="keyword">new</span> CDemo;<span class="comment">//构造函数调用</span></span><br><span class="line">    <span class="keyword">delete</span> pTest;<span class="comment">//析构函数调用</span></span><br><span class="line">    pTest=<span class="keyword">new</span> CDemo[<span class="number">2</span>];<span class="comment">//构造函数调用2次</span></span><br><span class="line">    <span class="keyword">delete</span> []pTest;<span class="comment">//析构函数调用2次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//析构函数调用2次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数对象和作为函数返回值的对象消亡时也会引发析构函数调用。</p><h3 id="3-3-构造函数、析构函数和变量的生存期"><a href="#3-3-构造函数、析构函数和变量的生存期" class="headerlink" title="3.3    构造函数、析构函数和变量的生存期"></a>3.3    构造函数、析构函数和变量的生存期</h3><p>全局对象在进入main函数前形成，直到程序结束消亡。临时对象在语句执行完毕后消亡，局部对象在初始化时生成，在最近的大括号处消亡。含static关键字的静态局部对象相当于全局对象。</p><h3 id="3-4-静态成员变量和静态成员函数"><a href="#3-4-静态成员变量和静态成员函数" class="headerlink" title="3.4    静态成员变量和静态成员函数"></a>3.4    静态成员变量和静态成员函数</h3><p>静态成员变量和静态成员函数加了<code>static</code>关键字，静态成员变量被所有同类对象共享，静态成员函数并不具体作用在某个对象上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> w, h;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> totalArea;<span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> totalNumber;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span><span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//静态成员函数不能访问非静态成员变量，也不能调用非静态成员函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; totalNumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; totalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle(<span class="keyword">int</span> w_, <span class="keyword">int</span> h_)</span><br><span class="line">&#123;</span><br><span class="line">w = w_;</span><br><span class="line">h = h_;</span><br><span class="line">totalNumber++;</span><br><span class="line">totalArea += w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle(CRectangle&amp; r)<span class="comment">//有些对象用复制构造函数初始化，需要编写专门的复制构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">totalNumber++;</span><br><span class="line">totalArea += r.w * r.h;</span><br><span class="line">w = r.w;</span><br><span class="line">h = r.h;</span><br><span class="line">&#125;</span><br><span class="line">~CRectangle()</span><br><span class="line">&#123;</span><br><span class="line">totalNumber--;</span><br><span class="line">totalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> CRectangle::totalArea = <span class="number">0</span>;<span class="comment">//必须对静态成员变量做声明或初始化</span></span><br><span class="line"><span class="keyword">int</span> CRectangle::totalNumber = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CRectangle r1(3, 3), r2(2, 2);</span><br><span class="line">CRectangle::PrintTotal();</span><br><span class="line">r1.PrintTotal();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-常量对象和常量成员函数"><a href="#3-5-常量对象和常量成员函数" class="headerlink" title="3.5    常量对象和常量成员函数"></a>3.5    常量对象和常量成员函数</h3><p>定义时加<code>const</code> 的对象和成员函数称为常量对象和常量成员函数，常量对象初始化后就再也不被改变，常量对象不能调用普通成员函数，但可以调用常量成员函数，常量成员函数不会修改任何非静态成员变量的值，也不允许调用其他非常量成员函数，但静态成员函数除外。两个名字和参数表不同的一个带const一个不带的函数算重载。如果一个成员函数没有调用非常量成员函数也没有修改成员变量，那么应写成常量成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTest()&#123;n=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> n;&#125;<span class="comment">//常量成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*n;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CTest o1;<span class="comment">//常量对象</span></span><br><span class="line">    CTest o2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;o1.GetValue()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;o2.GetValue();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-成员对象和封闭类"><a href="#3-6-成员对象和封闭类" class="headerlink" title="3.6    成员对象和封闭类"></a>3.6    成员对象和封闭类</h3><h4 id="3-6-1-封闭类构造函数的初始化列表"><a href="#3-6-1-封闭类构造函数的初始化列表" class="headerlink" title="3.6.1    封闭类构造函数的初始化列表"></a>3.6.1    封闭类构造函数的初始化列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CTyre(<span class="keyword">int</span> r,<span class="keyword">int</span> w):radius(r),width(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>//包含成员对象的类称为封闭类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    Ctyre tyre;<span class="comment">//成员对象</span></span><br><span class="line">    CEngine engine;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CCar(<span class="keyword">int</span> p,<span class="keyword">int</span> tr,<span class="keyword">int</span> tw):price(p),tyre(tr,tw)&#123;&#125;<span class="comment">//使用初始化列表编写构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封闭类对象生成时先执行所有成员对象的构造函数，在执行封闭类构造函数。封闭类对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数。</p><h4 id="3-6-2-封闭类的复制构造函数"><a href="#3-6-2-封闭类的复制构造函数" class="headerlink" title="3.6.2    封闭类的复制构造函数"></a>3.6.2    封闭类的复制构造函数</h4><p>封闭类对象如果使用默认复制构造函数初始化，其成员对象也会用复制构造函数初始化。</p><h3 id="3-7-const成员和引用成员"><a href="#3-7-const成员和引用成员" class="headerlink" title="3.7    const成员和引用成员"></a>3.7    const成员和引用成员</h3><p>常量成员变量和引用成员变量必须在构造函数初始化列表进行初始化，常量成员变量的值一旦初始化就不能改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num; <span class="comment">//常量型成员变量</span></span><br><span class="line"><span class="keyword">int</span> &amp; ref;     <span class="comment">//引用型成员变量</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CDemo( <span class="keyword">int</span> n):num(n),ref(f),value(<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(CDemo) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-友元"><a href="#3-8-友元" class="headerlink" title="3.8    友元"></a>3.8    友元</h3><h4 id="3-8-1-友元函数"><a href="#3-8-1-友元函数" class="headerlink" title="3.8.1    友元函数"></a>3.8.1    友元函数</h4><p>定义类时可以把一些函数（包括全局函数和其他类的成员函数）声明为友元，友元函数可以访问该类的私有成员。不能把其他类的私有成员函数声明为友元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span><span class="comment">//提前声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[],<span class="keyword">int</span> total)</span></span>;<span class="comment">//全局函数为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;<span class="comment">//其他类成员函数为友元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[],<span class="keyword">int</span> total)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-2-友元类"><a href="#3-8-2-友元类" class="headerlink" title="3.8.2    友元类"></a>3.8.2    友元类</h4><p>定义类时将某个其他类声明为自己的友元，该类的所有成员函数就能访问自己对象的私有成员。友元关系不能传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">nt price;</span><br><span class="line">riend <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span> <span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CCar myCar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span>  <span class="comment">//改装汽车</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myCar.price += <span class="number">1000</span>;<span class="comment">//因CDriver是CCar的友元类，故此处可以访问其私有成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-9-this指针"><a href="#3-9-this指针" class="headerlink" title="3.9    this指针"></a>3.9    this指针</h3><h4 id="3-9-1-C-程序到C程序的翻译"><a href="#3-9-1-C-程序到C程序的翻译" class="headerlink" title="3.9.1    C++程序到C程序的翻译"></a>3.9.1    C++程序到C程序的翻译</h4><p>类被翻译成结构体，对象被翻译成结构变量，成员函数被翻译成全局函数，全局函数比成员函数多一个参数，即指向结构变量的this指针。</p><h4 id="3-9-2-this指针的作用"><a href="#3-9-2-this指针的作用" class="headerlink" title="3.9.2    this指针的作用"></a>3.9.2    this指针的作用</h4><p>静态成员函数内部不能使用this指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> real, imag;</span><br><span class="line">Complex(<span class="keyword">double</span> r, <span class="keyword">double</span> i) :real(r), imag(i) &#123; &#125;</span><br><span class="line"><span class="function">Complex <span class="title">AddOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;real++;<span class="comment">//相当于real++;</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-10-在多个文件中使用类"><a href="#3-10-在多个文件中使用类" class="headerlink" title="3.10    在多个文件中使用类"></a>3.10    在多个文件中使用类</h3><p>类的定义可以写在一个头文件中。非内联成员函数函数体只能出现在某一.cpp文件中，不能放在头文件。内联成员函数应当写在头文件中。</p><h2 id="四-运算符重载"><a href="#四-运算符重载" class="headerlink" title="四    运算符重载"></a>四    运算符重载</h2><h3 id="4-1-运算符重载的概念和原理"><a href="#4-1-运算符重载的概念和原理" class="headerlink" title="4.1    运算符重载的概念和原理"></a>4.1    运算符重载的概念和原理</h3><p>运算符重载即对已有运算符赋予多重含义，使其用于不同类型的数据时产生不同行为。这样运算符可以操作各种类的对象。运算符重载的实质是编写以运算符为名称的函数，包含运算符的表达式会被编译成对运算符函数的调用，操作数成为函数调用的实参，运算的结果是函数的返回值。运算符可以多次重载，可以重载为全局函数，也可以重载为成员函数。一般重载为成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; a,comst Complex&amp; b)</span><br><span class="line">&#123;<span class="comment">//全局函数</span></span><br><span class="line">    <span class="keyword">return</span> Complex(a.real+b.real,a.imag+b.imag);<span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(comst Complex&amp; c)</span><br><span class="line">&#123;<span class="comment">//成员函数</span></span><br><span class="line">    <span class="keyword">return</span> Complex(real-c.real,imag-c.imag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex a(4,4),b(1,1),c;</span><br><span class="line">    c=a+b;<span class="comment">//c=operator+(a,b);</span></span><br><span class="line">    c=a-b;<span class="comment">//c=a.operator-(b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-重载赋值运算符“-”"><a href="#4-2-重载赋值运算符“-”" class="headerlink" title="4.2    重载赋值运算符“=”"></a>4.2    重载赋值运算符“=”</h3><p>赋值运算符只能重载为成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">String() :str(<span class="literal">NULL</span>) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> str; &#125;;<span class="comment">//返回值为const的常量成员函数，成员变量不会在函数内部修改，也不允许调用函数后修改指针指向的内容</span></span><br><span class="line">String&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line">~String();</span><br><span class="line">&#125;;</span><br><span class="line">String&amp; String::<span class="keyword">operator</span> = (<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br><span class="line"><span class="comment">//重载&quot;=&quot;以使得 obj = &quot;hello&quot;能够成立</span></span><br><span class="line">&#123;<span class="comment">//返回值类型为T&amp;能够保留赋值运算符原本的特性</span></span><br><span class="line"><span class="keyword">if</span> (str)</span><br><span class="line"><span class="keyword">delete</span>[] str;</span><br><span class="line"><span class="keyword">if</span> (s) &#123;  <span class="comment">//s不为NULL才会执行拷贝</span></span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];<span class="comment">//&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str)<span class="comment">//防止错误delete</span></span><br><span class="line"><span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String s;</span><br><span class="line">s = <span class="string">&quot;Good Luck,&quot;</span>; <span class="comment">//等价于 s.operator=(&quot;Good Luck,&quot;);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// String s2 = &quot;hello!&quot;;   //这条语句要是不注释掉就会出错，此语句是初始化语句</span></span><br><span class="line">s = <span class="string">&quot;Shenzhou 8!&quot;</span>; <span class="comment">//等价于 s.operator=(&quot;Shenzhou 8!&quot;);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-浅拷贝和深拷贝"><a href="#4-3-浅拷贝和深拷贝" class="headerlink" title="4.3    浅拷贝和深拷贝"></a>4.3    浅拷贝和深拷贝</h3><p>执行逐个字节的拷贝称为浅拷贝，将一个对象中指针成员变量指向的内容复制到另一个对象中指针成员变量指向的地方的拷贝称为深拷贝。浅拷贝会导致存储空间不被释放或重复释放，引发严重的内存错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==s.str)<span class="comment">//防止自己复制自己时开辟存储空间</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(str)</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">    <span class="keyword">if</span>(s.str)</span><br><span class="line">    &#123;</span><br><span class="line">        str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">String::String(String&amp; s)</span><br><span class="line">&#123;<span class="comment">//复制构造函数同样需要深拷贝</span></span><br><span class="line">   <span class="keyword">if</span>(s.str)</span><br><span class="line">    &#123;</span><br><span class="line">        str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        str=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-运算符重载为友元函数"><a href="#4-4-运算符重载为友元函数" class="headerlink" title="4.4    运算符重载为友元函数"></a>4.4    运算符重载为友元函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r);<span class="comment">//复数加实数</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r,<span class="keyword">const</span> Complex&amp; c);<span class="comment">//实数加复数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-长度可变的整型数组类"><a href="#4-5-长度可变的整型数组类" class="headerlink" title="4.5    长度可变的整型数组类"></a>4.5    长度可变的整型数组类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span>* pit;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CArray(<span class="keyword">int</span> s=<span class="number">0</span>);<span class="comment">//s为0时指向NULL，否则动态分配</span></span><br><span class="line">    CArray(CArray&amp; s);<span class="comment">//使用memcpy()</span></span><br><span class="line">    ~CArray();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> v)</span></span>;<span class="comment">//重新分配空间并复制原数组内容和加入新元素</span></span><br><span class="line">    CArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CArray&amp; a);<span class="comment">//考虑a=a，a数组为空，原有空间够大等情况</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i)<span class="comment">//重载[]运算符，能作为左值使用的函数应返回引用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-6-重载流插入运算符和流提取运算符"><a href="#4-6-重载流插入运算符和流提取运算符" class="headerlink" title="4.6    重载流插入运算符和流提取运算符"></a>4.6    重载流插入运算符和流提取运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) :real(r), imag(i) &#123; &#125;;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Complex&amp; c);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Complex&amp; c)<span class="comment">//ostream类复制构造函数是私有的，因此os只能是引用</span></span><br><span class="line">&#123;</span><br><span class="line">os &lt;&lt; c.real &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;i&quot;</span>; <span class="comment">//以&quot;a+bi&quot;的形式输出</span></span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex&amp; c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">is &gt;&gt; s;  <span class="comment">//将&quot;a+bi&quot;作为字符串读入, &quot;a+bi&quot; 中间不能有空格</span></span><br><span class="line"><span class="keyword">int</span> pos = s.find(<span class="string">&quot;+&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">string</span> sTmp = s.substr(<span class="number">0</span>, pos); <span class="comment">//分离出代表实部的字符串</span></span><br><span class="line">c.real = atof(sTmp.c_str());<span class="comment">//atof库函数能将const char*指针指向的内容转换成 float</span></span><br><span class="line">sTmp = s.substr(pos + <span class="number">1</span>, s.length() - pos - <span class="number">2</span>);   <span class="comment">//分离出代表虚部的字符串</span></span><br><span class="line">c.imag = atof(sTmp.c_str());</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Complex c;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-重载强制类型转换运算符"><a href="#4-7-重载强制类型转换运算符" class="headerlink" title="4.7    重载强制类型转换运算符"></a>4.7    重载强制类型转换运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r=<span class="number">0</span>;<span class="keyword">double</span> i=<span class="number">0</span>):real(r),imag(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> real;&#125;<span class="comment">//强制类型转换运算符只能重载为成员函数，且无需指定返回值类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-8-重载自增自减运算符"><a href="#4-8-重载自增自减运算符" class="headerlink" title="4.8    重载自增自减运算符"></a>4.8    重载自增自减运算符</h3><p>自增自减运算符有前置后置之分，为了区分两种表达式，重载前置时使用正常的重载函数，重载后置时使用增加一个无用int类型形参的重载函数。前置运算符返回值是操作数的引用，后置运算符的返回值是操作数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CDemo(<span class="keyword">int</span> i = <span class="number">0</span>) :n(i) &#123; &#125;</span><br><span class="line">CDemo&amp; <span class="keyword">operator</span>++();      <span class="comment">//用于前置形式</span></span><br><span class="line">CDemo <span class="keyword">operator</span>++(<span class="keyword">int</span>);   <span class="comment">//用于后置形式</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">friend</span> CDemo&amp; <span class="keyword">operator</span>--(CDemo&amp;);</span><br><span class="line"><span class="keyword">friend</span> CDemo <span class="keyword">operator</span>--(CDemo&amp;, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">CDemo&amp; CDemo::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;<span class="comment">//前置 ++</span></span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span>++(<span class="keyword">int</span> k)</span><br><span class="line">&#123; <span class="comment">//后置 ++</span></span><br><span class="line"><span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//记录修改前的对象</span></span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">return</span> tmp; <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br><span class="line">CDemo&amp; <span class="keyword">operator</span>--(CDemo&amp; d)</span><br><span class="line">&#123;<span class="comment">//前置--</span></span><br><span class="line">d.n--;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">CDemo <span class="keyword">operator</span>--(CDemo&amp; d, <span class="keyword">int</span>)</span><br><span class="line">&#123;<span class="comment">//后置--</span></span><br><span class="line"><span class="function">CDemo <span class="title">tmp</span><span class="params">(d)</span></span>;</span><br><span class="line">d.n--;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">CDemo <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (d++) &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="comment">//等价于 d.operator++(0);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (++d) &lt;&lt; <span class="string">&quot;,&quot;</span>;   <span class="comment">//等价于 d.operator++();</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (d--) &lt;&lt; <span class="string">&quot;,&quot;</span>;  <span class="comment">//等价于 operator-(d,0);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (--d) &lt;&lt; <span class="string">&quot;,&quot;</span>;   <span class="comment">//等价于 operator-(d);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-运算符重载的注意事项"><a href="#4-9-运算符重载的注意事项" class="headerlink" title="4.9    运算符重载的注意事项"></a>4.9    运算符重载的注意事项</h3><ul><li>重载后运算符的含义要符合原有习惯。</li><li>重载不改变运算符优先级。</li><li><code>.</code>、<code>*</code>、<code>::</code>、<code>?:</code>、<code>sizeof</code>不能被重载。</li><li><code>()</code>、<code>[]</code>、<code>-&gt;</code>、<code>=</code>只能重载为成员函数。</li></ul><h2 id="五-继承和派生"><a href="#五-继承和派生" class="headerlink" title="五    继承和派生"></a>五    继承和派生</h2><h3 id="5-1-继承和派生的概念"><a href="#5-1-继承和派生的概念" class="headerlink" title="5.1    继承和派生的概念"></a>5.1    继承和派生的概念</h3><h4 id="5-1-1-基本概念"><a href="#5-1-1-基本概念" class="headerlink" title="5.1.1    基本概念"></a>5.1.1    基本概念</h4><p>当定义某个新类时，如果这个类和拥有某个已有类的全部特点，此外还有这个类没有的特点，那么可以把原有类作为基类，新类作为原有类的派生类。即基类派生了派生类，派生类继承了基类。基类的所有成员自动成为派生类的成员。派生类的成员函数不能访问基类的私有成员。继承方式可以是公有继承、私有继承和保护继承。一般使用公有继承。派生类对象占用内存大小等于基类对象占用内存空间大小加上派生类全体成员变量占用内存大小之和。派生类对象包含基类对象，而且基类对象存储位置在派生类对象新增的成员变量之前。</p><h4 id="5-1-2-程序实例"><a href="#5-1-2-程序实例" class="headerlink" title="5.1.2    程序实例"></a>5.1.2    程序实例</h4><p>在基类和派生类有同名成员的情况下，在派生类的函数中或通过派生类对象访问同名成员，默认访问派生类成员。如需访问基类同名成员则使用<code>基类名::函数名()</code>。一般不在派生类中定义和基类同名的成员变量。</p><h3 id="5-2-正确处理类的复合关系和继承关系"><a href="#5-2-正确处理类的复合关系和继承关系" class="headerlink" title="5.2    正确处理类的复合关系和继承关系"></a>5.2    正确处理类的复合关系和继承关系</h3><p>复合关系表现为封闭类，数学上可以称为属于。继承关系表现为派生类，数学上可以称为包含。一个类中有另一个类的指针的情况可以称为知道关系。</p><h3 id="5-3-protected访问范围说明符"><a href="#5-3-protected访问范围说明符" class="headerlink" title="5.3    protected访问范围说明符"></a>5.3    protected访问范围说明符</h3><p>基类的保护成员可以在派生类的成员函数中被访问。派生类的成员函数只能访问所作用的那个对象的基类保护成员，不能访问其他对象的基类保护成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> nPrivate;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> nPublic;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> nProtected;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span><span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AccessBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nPublic=<span class="number">1</span>;</span><br><span class="line">        nPrivate=<span class="number">1</span>;<span class="comment">//不能访问私有成员</span></span><br><span class="line">        nProtected=<span class="number">1</span>;</span><br><span class="line">        CBase f;</span><br><span class="line">        f.nProtected=<span class="number">1</span>;<span class="comment">//不能访问其他对象的保护成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-4-派生类的构造函数和析构函数"><a href="#5-4-派生类的构造函数和析构函数" class="headerlink" title="5.4    派生类的构造函数和析构函数"></a>5.4    派生类的构造函数和析构函数</h3><p>任何生成派生类对象的语句都要说明其包含的基类对象是如何初始化的，默认使用无参构造函数初始化，如果基类没有无参构造函数，则编译错误。派生类对象生成时总是先执行基类的构造函数再执行派生类的构造函数，派生类对象消亡时总是先执行派生类的析构函数再执行基类的析构函数。如果一个派生类对象使用默认复制构造函数初始化，那么它的基类对象也要使用基类的复制构造函数初始化。</p><h3 id="5-5-多层次的派生"><a href="#5-5-多层次的派生" class="headerlink" title="5.5    多层次的派生"></a>5.5    多层次的派生</h3><p>对于派生的派生，有直接基类和间接基类之分。定义派生类时只写直接基类，派生类自动继承所有间接基类。派生类的成员包括自己定义的成员、直接基类定义的成员以及所有间接基类的全部成员。</p><h3 id="5-6-包含成员对象的派生类"><a href="#5-6-包含成员对象的派生类" class="headerlink" title="5.6    包含成员对象的派生类"></a>5.6    包含成员对象的派生类</h3><p>在派生类也是封闭类的情况下，构造函数调用顺序为自上至下所有基类、成员对象、自身，析构函数调用顺序为自身、成员对象、自下至上所有基类。</p><h3 id="5-7-公有派生的赋值兼容规则"><a href="#5-7-公有派生的赋值兼容规则" class="headerlink" title="5.7    公有派生的赋值兼容规则"></a>5.7    公有派生的赋值兼容规则</h3><ul><li>派生类对象可以赋值给基类对象</li><li>派生类对象可以初始化基类引用</li><li>派生类指针可以赋值给基类指针</li></ul><p>此规则只有public派生才成立，private和protected派生不成立。</p><h3 id="5-8-基类和派生类指针的互相转换"><a href="#5-8-基类和派生类指针的互相转换" class="headerlink" title="5.8    基类和派生类指针的互相转换"></a>5.8    基类和派生类指针的互相转换</h3><p>即使基类指针指向派生类对象，也不能通过基类指针访问基类没有而派生类有的成员。基类指针指向派生类对象时仍然调用基类同名成员函数。基类指针不能赋值给派生类指针，除非经过强制类型转换。基类引用也可以强制转换为派生类引用。强制类型转换会导致不可预测的安全隐患。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CBase(<span class="keyword">int</span> i) :n(i) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CBase:n=&quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span><span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line">CDerived(<span class="keyword">int</span> i) :CBase(i), v(<span class="number">2</span> * i) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CDerived:n=&quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;CDerived:v=&quot;</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">CDerived <span class="title">objDerived</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">CBase <span class="title">objBase</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">CBase* pBase = &amp;objDerived; <span class="comment">// 使得基类指针指向派生类对象</span></span><br><span class="line"><span class="comment">//pBase-&gt;Func(); //错, CBase类没有Func()成员函数</span></span><br><span class="line"><span class="comment">//pBase-&gt;v = 5;  //错 CBase类没有v成员变量</span></span><br><span class="line">pBase-&gt;Print();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//CDerived * pDerived = &amp; objBase; //错，不能将基类指针赋值给派生类指针</span></span><br><span class="line">CDerived* pDerived = (CDerived*)(&amp;objBase);</span><br><span class="line">pDerived-&gt;Print();  <span class="comment">//慎用，可能出现不可预期的错误</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">objDerived.Print();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pDerived-&gt;v = <span class="number">128</span>;  <span class="comment">//往别人的空间里写入数据，会有问题</span></span><br><span class="line">objDerived.Print();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-9-私有派生和保护派生"><a href="#5-9-私有派生和保护派生" class="headerlink" title="5.9    私有派生和保护派生"></a>5.9    私有派生和保护派生</h3><table><thead><tr><th></th><th>公有派生</th><th>私有派生</th><th>保护派生</th></tr></thead><tbody><tr><td>私有成员</td><td>不可访问</td><td>不可访问</td><td>不可访问</td></tr><tr><td>保护成员</td><td>保护</td><td>私有</td><td>保护</td></tr><tr><td>公有成员</td><td>公有</td><td>私有</td><td>保护</td></tr></tbody></table><p>一般情况下都应使用公有派生。</p><h3 id="5-10-派生类和赋值运算符"><a href="#5-10-派生类和赋值运算符" class="headerlink" title="5.10    派生类和赋值运算符"></a>5.10    派生类和赋值运算符</h3><p>如果基类重载了赋值运算符而派生类没有，那么派生类互相赋值或是给基类对象赋值时基类部分调用被基类重载的赋值运算符。</p><h2 id="六-多态与虚函数"><a href="#六-多态与虚函数" class="headerlink" title="六    多态与虚函数"></a>六    多态与虚函数</h2><h3 id="6-1-多态的基本概念"><a href="#6-1-多态的基本概念" class="headerlink" title="6.1    多态的基本概念"></a>6.1    多态的基本概念</h3><h4 id="6-1-1-通过基类指针实现多态"><a href="#6-1-1-通过基类指针实现多态" class="headerlink" title="6.1.1    通过基类指针实现多态"></a>6.1.1    通过基类指针实现多态</h4><p>多态指的是同一名字的事物可以完成不同的功能，包括编译时的多态和运行时的多态。编译时的多态指函数的重载，运行时的多态则和虚函数有关。虚函数在通过基类指针调用时并不确定执行基类或派生类的同名函数，而是以运行时所指向的对象来判断。虚函数在声明时添加<code>virtual</code>关键字，且只能在声明时使用。静态成员函数不能是虚函数。包含虚函数的类称为多态类。</p><h4 id="6-1-2-通过基类引用实现多态"><a href="#6-1-2-通过基类引用实现多态" class="headerlink" title="6.1.2    通过基类引用实现多态"></a>6.1.2    通过基类引用实现多态</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;D&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">(A&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r.Print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;B b;C c;D d;</span><br><span class="line">    A* pa=&amp;a;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;b;<span class="comment">//指针的多态</span></span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;c;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    A* pa=&amp;d;</span><br><span class="line">    pa-&gt;Print();</span><br><span class="line">    PrintInfo(a);<span class="comment">//引用的多态</span></span><br><span class="line">    PrintInfo(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-多态的作用"><a href="#6-2-多态的作用" class="headerlink" title="6.2    多态的作用"></a>6.2    多态的作用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShape</span>  //基类：形体类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span> </span>&#123; &#125;;  <span class="comment">//求面积</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span> </span>&#123; &#125;; <span class="comment">//显示信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span> :</span><span class="keyword">public</span> CShape  <span class="comment">//派生类：矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> w, h;     <span class="comment">//宽和高</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCircle</span> :</span><span class="keyword">public</span> CShape  <span class="comment">//派生类：圆类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> r;      <span class="comment">//半径</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTriangle</span> :</span><span class="keyword">public</span> CShape <span class="comment">//派生类：三角形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a, b, c;      <span class="comment">//三边长</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CRectangle::Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CRectangle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CCircle::Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CCircle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Circle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CTriangle::Area</span><span class="params">()</span> </span>&#123;   <span class="comment">//根据海伦公式计算三角形面积</span></span><br><span class="line"><span class="keyword">double</span> p = (a + b + c) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(p * (p - a) * (p - b) * (p - c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTriangle::PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Triangle:&quot;</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">CShape* pShapes[<span class="number">100</span>]; <span class="comment">//用来存放各种几何形体，假设不超过100个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* s1, <span class="keyword">const</span> <span class="keyword">void</span>* s2)</span>  <span class="comment">//定义排序规则的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CShape** p1 = (CShape**)s1; <span class="comment">//s1是指向指针的指针,其指向的指针为CShape* 类型</span></span><br><span class="line">CShape** p2 = (CShape**)s2;</span><br><span class="line"><span class="keyword">double</span> a1 = (*p1)-&gt;Area(); <span class="comment">//p1指向几何形体对象的指针, *p1才指向几何形体对象</span></span><br><span class="line"><span class="keyword">double</span> a2 = (*p2)-&gt;Area();</span><br><span class="line"><span class="keyword">if</span> (a1 &lt; a2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//面积小的排前面</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a2 &lt; a1)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="keyword">int</span> n;</span><br><span class="line">CRectangle* pr; CCircle* pc; CTriangle* pt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="comment">//矩形</span></span><br><span class="line">pr = <span class="keyword">new</span> CRectangle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pr-&gt;w &gt;&gt; pr-&gt;h;</span><br><span class="line">pShapes[i] = pr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">//圆</span></span><br><span class="line">pc = <span class="keyword">new</span> CCircle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pc-&gt;r;</span><br><span class="line">pShapes[i] = pc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">//三角形</span></span><br><span class="line">pt = <span class="keyword">new</span> CTriangle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pt-&gt;a &gt;&gt; pt-&gt;b &gt;&gt; pt-&gt;c;</span><br><span class="line">pShapes[i] = pt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(pShapes, n, <span class="keyword">sizeof</span>(Cshape*), MyCompare);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">pShapes[i]-&gt;PrintInfo();</span><br><span class="line"><span class="keyword">delete</span> pShapes[i]; <span class="comment">//释放空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-多态的实现原理"><a href="#6-3-多态的实现原理" class="headerlink" title="6.3    多态的实现原理"></a>6.3    多态的实现原理</h3><p>有虚函数的类占用的存储空间比没有虚函数的多8个字节，位于存储空间的最前端，存放了虚函数表的地址。编译时不会确定要调用哪个函数，运行时先取出指针所指位置的虚函数表的地址，再通过虚函数表的地址找到虚函数表，在虚函数表中查找对应的虚函数的地址，最后根据找到的虚函数的地址调用虚函数。多态能够提高程序的开发效率，但也增加了程序运行时的开销。</p><h3 id="6-4-关于多态的注意事项"><a href="#6-4-关于多态的注意事项" class="headerlink" title="6.4    关于多态的注意事项"></a>6.4    关于多态的注意事项</h3><h4 id="6-4-1-在成员函数中调用虚函数"><a href="#6-4-1-在成员函数中调用虚函数" class="headerlink" title="6.4.1    在成员函数中调用虚函数"></a>6.4.1    在成员函数中调用虚函数</h4><p>在成员函数（静态成员函数、构造函数和析构函数除外）中调用其它成员虚函数的语句是多态的。</p><h4 id="6-4-2-在构造函数和析构函数中调用虚函数"><a href="#6-4-2-在构造函数和析构函数中调用虚函数" class="headerlink" title="6.4.2    在构造函数和析构函数中调用虚函数"></a>6.4.2    在构造函数和析构函数中调用虚函数</h4><p>在构造函数和析构函数中调用虚函数不是多态，如果本类有该函数则调用本类函数，否则依次看直接基类和间接基类的函数。</p><h4 id="6-4-3-注意区分多态和非多态的情况"><a href="#6-4-3-注意区分多态和非多态的情况" class="headerlink" title="6.4.3    注意区分多态和非多态的情况"></a>6.4.3    注意区分多态和非多态的情况</h4><p>只有成员函数是虚函数时才是多态。只要基类中某个函数被声明为虚函数，则派生类中同名同参数表的成员函数也自动成为虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;  <span class="comment">//func2自动成为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B  <span class="comment">// C以A为间接基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;; <span class="comment">//func1自动成为虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;; <span class="comment">//func2自动成为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C obj;</span><br><span class="line">A* pa = &amp;obj;</span><br><span class="line">B* pb = &amp;obj;</span><br><span class="line">pa-&gt;func2();  <span class="comment">//多态</span></span><br><span class="line">pa-&gt;func1();  <span class="comment">//不是多态</span></span><br><span class="line">pb-&gt;func1();  <span class="comment">//多态</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-虚析构函数"><a href="#6-5-虚析构函数" class="headerlink" title="6.5    虚析构函数"></a>6.5    虚析构函数</h3><p>为了让动态分配的内存释放时能够根据指针指向的对象调用对应的析构函数，需要将基类的析构函数声明为虚函数。一个类如果定义了虚函数，则最好将析构函数也定义成虚函数。基类析构函数是虚函数，派生类析构函数自动成为虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CShape</span>  //基类：形体类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~CShape()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-6-纯虚函数和抽象类"><a href="#6-6-纯虚函数和抽象类" class="headerlink" title="6.6    纯虚函数和抽象类"></a>6.6    纯虚函数和抽象类</h3><p>纯虚函数是没有函数体的函数，包含纯虚函数的类称为抽象类。抽象类不能生成独立的对象，但可以定义抽象类的指针和引用。抽象类的派生类当且仅当实现了所有纯虚函数才成为非抽象类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七-输入输出流"><a href="#七-输入输出流" class="headerlink" title="七    输入输出流"></a>七    输入输出流</h2><h3 id="7-1-流类"><a href="#7-1-流类" class="headerlink" title="7.1    流类"></a>7.1    流类</h3><p>流是数据从一个地方传送到另一个地方的抽象。C++把用于数据输入输出的类称为流类。<code>ios</code>是抽象的基类，派生出<code>istream</code>和<code>ostream</code>，这两个类又共同派生出<code>iostream</code>。为避免多继承的二义性，从<code>ios</code>派生出<code>istream</code>和<code>ostream</code>时使用了虚继承。</p><h3 id="7-2-标准流对象"><a href="#7-2-标准流对象" class="headerlink" title="7.2    标准流对象"></a>7.2    标准流对象</h3><p><code>cin</code>对应标准输入流，用于从键盘读取数据，可重定向为从文件读取数据。</p><p><code>cout</code>对应标准输出流，用于向屏幕输出数据，可重定向为从文件写入数据。</p><p><code>cerr</code>对应标准错误输出流，不使用缓冲区，不能被重定向。 </p><p><code>clog</code>对应标准错误输出流，使用缓冲区，不能被重定向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">freopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);  <span class="comment">//将标准输出重定向到 test.txt文件</span></span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>)  <span class="comment">//除数为0则输出错误信息</span></span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;error.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x / y;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-使用流操纵算子控制输出格式"><a href="#7-3-使用流操纵算子控制输出格式" class="headerlink" title="7.3    使用流操纵算子控制输出格式"></a>7.3    使用流操纵算子控制输出格式</h3><p>使用流操纵算子（又叫格式控制符）需要包含<code>iomanip</code>头文件。 </p><table><thead><tr><th>流操纵算子</th><th>作用</th></tr></thead><tbody><tr><td><code>hex</code></td><td>十六进制输出整数</td></tr><tr><td><code>oct</code></td><td>八进制输出整数</td></tr><tr><td><code>fixed</code></td><td>普通小数形式输出浮点数</td></tr><tr><td><code>scientific</code></td><td>科学计数法输出浮点数</td></tr><tr><td><code>left</code></td><td>左对齐，宽度不足时填充字符添加到左边</td></tr><tr><td><code>setbase(b)</code></td><td>设置输出整数时的进制，为8、10或16</td></tr><tr><td><code>setw(w)</code></td><td>输出宽度或读入w个字符</td></tr><tr><td><code>setfill(c)</code></td><td>输出宽度不足时用c填充</td></tr><tr><td><code>setprecision(n)</code></td><td>设置浮点数输出精度为n</td></tr><tr><td><code>setiosflags(格式)</code></td><td>将某个格式标志置为1</td></tr><tr><td><code>reseriosflags(格式)</code></td><td>将某个格式标志置为0</td></tr><tr><td><code>boolapha</code></td><td>true和false输出为字符串</td></tr><tr><td><code>showbase</code></td><td>输出进制前缀</td></tr><tr><td><code>showpoint</code></td><td>总是输出小数点</td></tr><tr><td><code>showpos</code></td><td>非负数显示+</td></tr><tr><td><code>noskipws</code></td><td>输入时不跳过空白字符</td></tr><tr><td><code>uppercase</code></td><td>使用大写字母输出十六进制、前缀和科学计数法</td></tr><tr><td><code>internal</code></td><td>符号左对齐，数值右对齐</td></tr></tbody></table><p>流操纵算子影响整个语句，但setw算子只影响下一次输出或输入。</p><h3 id="7-4-调用cout的成员函数"><a href="#7-4-调用cout的成员函数" class="headerlink" title="7.4    调用cout的成员函数"></a>7.4    调用cout的成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::scientific);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">12.23</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//cout&lt;&lt;setiosflags(ios::scientific)&lt;&lt;setprecision(8)&lt;&lt;12.23&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.put(<span class="number">98</span>).put(<span class="string">&#x27;c&#x27;</span>).put(<span class="string">&#x27;z&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="7-5-cin的高级用法"><a href="#7-5-cin的高级用法" class="headerlink" title="7.5    cin的高级用法"></a>7.5    cin的高级用法</h3><h4 id="7-5-1-判断输入结束"><a href="#7-5-1-判断输入结束" class="headerlink" title="7.5.1    判断输入结束"></a>7.5.1    判断输入结束</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,maxN=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;<span class="comment">//istream类重载了bool运算符，读取到输入结尾或输入错误返回false</span></span><br><span class="line">        <span class="keyword">if</span>(maxN&lt;n)</span><br><span class="line">            maxN=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-2-istream类的成员函数"><a href="#7-5-2-istream类的成员函数" class="headerlink" title="7.5.2    istream类的成员函数"></a>7.5.2    istream类的成员函数</h4><h5 id="1-get"><a href="#1-get" class="headerlink" title="1.get"></a>1.get</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;<span class="comment">//注意c的类型为int，若为char则读入ASCII码为0xFF的字符会导致输入终止</span></span><br><span class="line">    freopen(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(c=<span class="built_in">cin</span>.get()!=EOF)<span class="comment">//get函数可以正常读入所有字符，EOF是iostream类定义的整型常量，值为-1，表示输入终止</span></span><br><span class="line">        <span class="built_in">cout</span>.put(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-getline"><a href="#2-getline" class="headerlink" title="2.getline"></a>2.getline</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">cin</span>.getline(szBuf, <span class="number">6</span>))  <span class="comment">//如果输入流中一行字符超过5个，就会出错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line"><span class="built_in">cin</span>.clear(); <span class="comment">//clear能够清除cin内部的错误标记，使之恢复正常</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-eof"><a href="#3-eof" class="headerlink" title="3.eof"></a>3.eof</h5><p><code>bool eof()</code>判断输入流是否结束，若结束返回<code>true</code>。</p><h5 id="4-ignore"><a href="#4-ignore" class="headerlink" title="4.ignore"></a>4.ignore</h5><p><code>istream&amp; ignore(int n=1,int delim=EOF)</code>用于跳过n个字符或delim前所有字符。</p><h5 id="5-peek"><a href="#5-peek" class="headerlink" title="5.peek"></a>5.peek</h5><p>此函数返回下一个字符，但不会将该字符从输入流中取走。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> Months[<span class="number">12</span>] = &#123; <span class="string">&quot;Jan&quot;</span>,<span class="string">&quot;Feb&quot;</span>,<span class="string">&quot;Mar&quot;</span>,<span class="string">&quot;Apr&quot;</span>,<span class="string">&quot;May&quot;</span>,<span class="string">&quot;Jun&quot;</span>,<span class="string">&quot;Jul&quot;</span>,<span class="string">&quot;Aug&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Sep&quot;</span>,<span class="string">&quot;Oct&quot;</span>,<span class="string">&quot;Nov&quot;</span>,<span class="string">&quot;Dec&quot;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">cin</span>.peek()) != EOF) &#123; <span class="comment">//取输入流中的第一个字符进行查看</span></span><br><span class="line"><span class="keyword">int</span> year, month, day;</span><br><span class="line"><span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123; <span class="comment">//美国日期格式</span></span><br><span class="line"><span class="built_in">string</span> sMonth;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sMonth &gt;&gt; day &gt;&gt; year;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)  <span class="comment">//查找月份</span></span><br><span class="line"><span class="keyword">if</span> (sMonth == Months[i]) &#123;</span><br><span class="line">month = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//中国日期格式</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; year;</span><br><span class="line"><span class="built_in">cin</span>.ignore() &gt;&gt; month; <span class="comment">//用ignore跳过 &quot;2011.12.3&quot;中的&#x27;.&#x27;</span></span><br><span class="line"><span class="built_in">cin</span>.ignore() &gt;&gt; day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>.ignore();   <span class="comment">//跳过行末 &#x27;\n&#x27;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; month;<span class="comment">//设置填充字符&#x27;\0&#x27;，输出宽度2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; day &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用get和putback配合达到同样的效果。</p><h2 id="八-文件操作"><a href="#八-文件操作" class="headerlink" title="八 文件操作"></a>八 文件操作</h2><h3 id="8-1-文件的概念"><a href="#8-1-文件的概念" class="headerlink" title="8.1    文件的概念"></a>8.1    文件的概念</h3><p>所有的文件本质上都是0和1的比特串，这些比特串代表什么内容取决于用怎样的格式读取它们。</p><h3 id="8-2-C-文件流类"><a href="#8-2-C-文件流类" class="headerlink" title="8.2    C++文件流类"></a>8.2    C++文件流类</h3><p>C++标准类库中，ifstream、ofstream和fstream类可用于文件操作，称为文件流类。使用这三个类需要包含fstream头文件。ifstream和fstream由istream派生来，拥有istream的全部成员函数，同样ofstream和fstream拥有ostream的全部成员函数。要使用一个文件要先打开才能读写，读写完后要关闭。</p><h3 id="8-3-文件的打开和关闭"><a href="#8-3-文件的打开和关闭" class="headerlink" title="8.3    文件的打开和关闭"></a>8.3    文件的打开和关闭</h3><table><thead><tr><th>模式标记</th><th>适用对象</th><th>作用</th></tr></thead><tbody><tr><td><code>ios::in</code></td><td>ifstream fstream</td><td>打开文件用于读取数据。如果文件不存在。则打开出错</td></tr><tr><td><code>ios::out</code></td><td>ofstream fstream</td><td>打开文件用于写入数据。如果文件不存在，则新建该文件果文件原来就存在，则打开时清除原来的内容</td></tr><tr><td><code>ios::app</code></td><td>ofstream fstream</td><td>打开文件，用于在其尾部添加数据。如果文件不存在，则新建该文件</td></tr><tr><td><code>ios::ate</code></td><td>ifstream</td><td>打开一个已有的文件，并将文件读指针指向文件末尾（读写指针的概念后面解释)。如果文件不存在，则打开出错</td></tr><tr><td><code>ios::trunc</code></td><td>ofstream</td><td>单独使用时与ios::out相同</td></tr><tr><td><code>ios::binary</code></td><td>ifstream ofstream fstream</td><td>以二进制方式打开文件。若不指定此模式，则以文本模式打开</td></tr><tr><td>`ios::in</td><td>ios::out`</td><td>fstream</td></tr><tr><td>`ios::in</td><td>ios::out`</td><td>ofstream</td></tr><tr><td>`ios::in</td><td>ios::out</td><td>ios::trunc`</td></tr></tbody></table><p><code>void open(const char* szFileName,int mode)</code>调用该成员函数时，给出的文件名可以是全路径的，也可以给出相对路径。</p><p><code>ifstream(const char* szFileName,int mode=ios::in,int)</code>构造函数也可以打开文件。</p><h3 id="8-4-文件的读写"><a href="#8-4-文件的读写" class="headerlink" title="8.4    文件的读写"></a>8.4    文件的读写</h3><h4 id="8-4-1-文本文件的读写"><a href="#8-4-1-文本文件的读写" class="headerlink" title="8.4.1    文本文件的读写"></a>8.4.1    文本文件的读写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //qsort在此头文件中声明</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX_NUM]; <span class="comment">//存放文件中读入的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* e1, <span class="keyword">const</span> <span class="keyword">void</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//用于qsort的比较函数</span></span><br><span class="line"><span class="keyword">return</span> *((<span class="keyword">int</span>*)e1) - *((<span class="keyword">int</span>*)e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;<span class="comment">//读入的整数个数</span></span><br><span class="line"><span class="function">ifstream <span class="title">srcFile</span><span class="params">(<span class="string">&quot;in.txt&quot;</span>, ios::in)</span></span>; <span class="comment">//以文本模式打开in.txt备读</span></span><br><span class="line"><span class="keyword">if</span> (!srcFile) &#123; <span class="comment">//打开失败</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error opening source file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ofstream <span class="title">destFile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>, ios::out)</span></span>; <span class="comment">//以文本模式打开out.txt备写</span></span><br><span class="line"><span class="keyword">if</span> (!destFile) &#123;</span><br><span class="line">srcFile.close(); <span class="comment">//程序结束前不能忘记关闭以前打开过的文件</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error opening destination file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (srcFile &gt;&gt; x) <span class="comment">//可以像用cin那样用ifstream对象</span></span><br><span class="line">a[total++] = x;</span><br><span class="line">qsort(a, total, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), MyCompare); <span class="comment">//排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span><br><span class="line">destFile &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//可以像用cout那样用ofstream对象</span></span><br><span class="line">destFile.close();</span><br><span class="line">srcFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-2-二进制文件的读写"><a href="#8-4-2-二进制文件的读写" class="headerlink" title="8.4.2    二进制文件的读写"></a>8.4.2    二进制文件的读写</h4><p>使用二进制文件可以节约空间，提升文件查找效率。读写二进制文件不能使用流读写，需要使用read和write成员函数。写函数从写指针指向的位置开始写入，读函数从读指针指向的位置开始读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CStudent s;</span><br><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;students.dat&quot;</span>, ios::in | ios::binary)</span></span>; <span class="comment">//二进制读方式打开</span></span><br><span class="line"><span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (inFile.read((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s))) &#123; <span class="comment">//一直读到文件结束</span></span><br><span class="line"><span class="keyword">int</span> readedBytes = inFile.gcount(); <span class="comment">//看刚才读了多少字节</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.szName &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">inFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用put和get成员函数读写文件。</p><h4 id="8-4-3-操作文件读写指针"><a href="#8-4-3-操作文件读写指针" class="headerlink" title="8.4.3    操作文件读写指针"></a>8.4.3    操作文件读写指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">seekp</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> mode)</span></span>;<span class="comment">//ios::begios::curios::end</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">seekg</span><span class="params">(<span class="keyword">int</span> offset,<span class="keyword">int</span> mode)</span></span>;<span class="comment">//文件开始向后当前位置文件结尾向前</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tellg</span><span class="params">()</span></span>;<span class="comment">//返回读指针的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tellp</span><span class="params">()</span></span>;<span class="comment">//返回写指针的位置</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CStudent s;</span><br><span class="line"><span class="function">fstream <span class="title">ioFile</span><span class="params">(<span class="string">&quot;students.dat&quot;</span>, ios::in | ios::out)</span></span>;<span class="comment">//用既读又写的方式打开</span></span><br><span class="line"><span class="keyword">if</span> (!ioFile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ioFile.seekg(<span class="number">0</span>, ios::end); <span class="comment">//定位读指针到文件尾部，</span></span><br><span class="line">  <span class="comment">//以便用以后tellg 获取文件长度</span></span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>, R; <span class="comment">// L是折半查找范围内第一个记录的序号</span></span><br><span class="line">  <span class="comment">// R是折半查找范围内最后一个记录的序号</span></span><br><span class="line">R = ioFile.tellg() / <span class="keyword">sizeof</span>(CStudent) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//首次查找范围的最后一个记录的序号就是: 记录总数- 1</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>; <span class="comment">//要用查找范围正中的记录和待查找的名字比对</span></span><br><span class="line">ioFile.seekg(mid * <span class="keyword">sizeof</span>(CStudent), ios::beg); <span class="comment">//定位到正中的记录</span></span><br><span class="line">ioFile.read((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">strcmp</span>(s.szName, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123; <span class="comment">//找到了</span></span><br><span class="line">s.age = <span class="number">20</span>;</span><br><span class="line">ioFile.seekp(mid * <span class="keyword">sizeof</span>(CStudent), ios::beg);</span><br><span class="line">ioFile.write((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) <span class="comment">//继续到前一半查找</span></span><br><span class="line">R = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//继续到后一半查找</span></span><br><span class="line">L = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (L &lt;= R);</span><br><span class="line">ioFile.close();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-文本方式打开文件与二进制方式打开文件的区别"><a href="#8-5-文本方式打开文件与二进制方式打开文件的区别" class="headerlink" title="8.5    文本方式打开文件与二进制方式打开文件的区别"></a>8.5    文本方式打开文件与二进制方式打开文件的区别</h3><p>UNIX/Linux中文本方式和二进制方式打开文件没有任何区别。Windows中用文本方式打开二进制文件读写的内容可能与文件内容有出入。</p>]]></content>
    
    
    <summary type="html">&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;/2020/12/28/fundamentals-of-Cpp-programming-and-algorithms/IMG_20201223_235334.jpg&quot;&gt;
    &lt;br&gt;
    &lt;div style=&quot;color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;&quot;&gt;为了做这句话，我还学了一点HTML。&lt;/div&gt;
&lt;/center&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
